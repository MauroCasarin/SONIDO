<!DOCTYPE html>
<html>
<head>
    <title>Calculador distancia de graves según Hz.</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1e1e1e;
            color: #ffffff;
            text-align: center;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden; /* Evitar scroll horizontal en pantallas pequeñas */
            font-size: clamp(14px, 2.5vw, 16px); /* Base font size responsive */
        }
        
        /* Contenedor del Logo */
        #logo-container {
            width: 95vw;
            max-width: 800px;
            text-align: center;
            margin-top: 10px;
            padding: 10px;
            background-color: #2c2c2c;
            border-radius: 8px;
            border: 1px solid #1e90ff;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }
        #logo-container img {
            width: 50px;
            height: auto;
            cursor: pointer;
            border-radius: 50%;
            transition: transform 0.2s;
        }
        #logo-container img:hover {
            transform: scale(1.1);
        }
        #logo-container p {
            font-size: 0.75em; /* Scales with body font size */
            color: #aaa;
            margin-top: 5px;
        }
        
        h1 {
            color: #4CAF50;
            padding-top: 5px;
            font-size: 1.4em; /* Scales with body font size */
            margin-bottom: 5px;
        }
        
        #info-panel {
            flex-shrink: 0;
            font-size: 0.95em; /* Scales with body font size, affecting its children */
            padding: 15px;
            background-color: #2c2c2c;
            width: 95vw;
            max-width: 800px;
            margin: 10px auto 5px auto;
            border-radius: 8px;
            text-align: left;
            border: 1px solid #1e90ff;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }
        
        #container {
            flex-grow: 1;
            width: 95vw;
            max-width: 800px;
            margin: 5px auto 10px auto;
            min-height: 250px;
            position: relative; 
            border-radius: 8px;
            overflow: hidden; /* Asegura que el canvas no se desborde */
        }
        #container canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
            border: 2px solid #555; /* Será cubierto por el borde del contenedor */
            border-radius: 8px; /* Será cubierto por el borde del contenedor */
        }

        .scene-label {
            position: absolute;
            background-color: rgba(30, 30, 30, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            white-space: nowrap;
            transform: translate(-50%, -50%); 
            pointer-events: none;
            border: 1px solid #444;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            z-index: 10; /* Asegurar que las etiquetas estén por encima del canvas */
        }
        #label-freq { font-size: 1.14em; /* Approx 16px if body is 14px */ font-weight: bold; color: #4CAF50; }
        #label-distancia { font-size: 0.85em; /* Approx 12px if body is 14px */ color: #f0ad4e; }
        
        .control-group { margin-bottom: 10px; color: #ccc;}
        .slider-container { width: 95%; margin: 0 auto 12px auto; position: relative; }
        .slider-label { display: block; font-size: 0.85em; /* Scales with body font size */ margin-bottom: 5px; font-weight: bold; color: #1e90ff; }
        input[type=range] { 
            width: 100%; height: 5px; background: #555; -webkit-appearance: none; border-radius: 5px; cursor: pointer;
            background: linear-gradient(to right, #1e90ff, #00bfff); /* Degradado para el slider */
            outline: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffffff;
            border: 2px solid #1e90ff;
            cursor: grab;
            box-shadow: 0 0 5px rgba(0, 191, 255, 0.7);
            transition: background 0.2s, transform 0.2s;
        }
        input[type=range]::-webkit-slider-thumb:active {
            cursor: grabbing;
            transform: scale(1.1);
        }
        
        #rango-description {
            font-weight: bold;
            color: #f0ad4e;
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #444;
            font-size: 0.8em; /* Scales with body font size */
            line-height: 1.4;
        }
        
        /* --- ESTILOS DEL ANALIZADOR DE ONDA DE TIEMPO --- */
        #frequency-spectrum-analyzer {
            width: 95vw;
            max-width: 800px;
            margin: 10px auto;
            padding: 15px;
            background-color: #2c2c2c;
            border-radius: 8px;
            border: 1px solid #1e90ff;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            position: relative;
        }
        #frequency-spectrum-analyzer p { /* Estilo para el título del espectro */
            color: #ffffff;
            font-weight: bold;
            font-size: 0.9em; /* Scales with body font size */
            margin-bottom: 10px;
        }
        #frequency-spectrum-canvas {
            background-color: #2a2a2a; /* Fondo del canvas para el espectro */
            border-radius: 8px; /* Bordes redondeados para el canvas */
            display: block; /* Eliminar espacio extra */
        }

        #spectrum-audio-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85); /* Más oscuro */
            color: #1e90ff; /* Color de texto más vibrante */
            font-size: 1.1em; /* Scales with body font size */
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 21; /* Higher z-index */
            border-radius: 8px;
            transition: background-color 0.3s;
        }
        #spectrum-audio-overlay:hover {
            background-color: rgba(0, 0, 0, 0.7);
        }
        
        /* Bloque 'spectrum-freq-ticks-labels' eliminado según la solicitud del usuario. */
        
        #spectrum-dominant-freq { font-size: 0.9em; /* Scales with body font size */ color: #1e90ff; margin-top: 10px; }
        #spectrum-rango-label { font-size: 0.8em; /* Scales with body font size */ font-weight: bold; color: #ccc; margin-top: 5px; }

        /* --- IMAGEN DE REFERENCIA --- */
        #imagen-referencia {
            width: 95vw;
            max-width: 800px;
            margin: 20px auto;
            padding: 15px;
            background-color: #2c2c2c;
            border-radius: 8px;
            border: 1px solid #444;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }
        #imagen-referencia h2 {
            font-size: 1.2em; /* Scales with body font size */
            margin-bottom: 10px; 
            color: #ffffff;
        }
        #imagen-referencia img {
            width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }

    </style>
<link rel="stylesheet" href="/index.css">
</head>
<body>
    
    <div id="logo-container">
        <a href="https://www.instagram.com/3d_mc_3d/" target="_blank" rel="noopener noreferrer">
            <img src="https://raw.githubusercontent.com/MauroCasarin/SONIDO/refs/heads/main/MC%2048%20N.png" alt="Logo MC 3D" />
        </a>
        <p>Powered by MC 3D</p>
    </div>

    <div id="info-panel">
        <h1>Calculador distancia de graves según Hz.</h1>
        
        <div id="frecuencia-info" class="control-group">Frecuencia: 100 Hz (L.O.: 3.40 m) | Ideal: 1.70 m</div>
        <label for="sliderFrecuencia" class="slider-label">Control de Frecuencia (Hz) [30 - 400 Hz]:</label>
        <div class="slider-container">
            <input type="range" id="sliderFrecuencia" min="30" max="400" step="5" value="100" oninput="actualizarValores()"> 
        </div>
        
        <div id="separacion-info" class="control-group">Separación: 0.85 metros - Máxima Coherencia</div>
        <label for="sliderSeparacion" class="slider-label">Control de Separación (Metros) [0.1 - 4.0 m]:</label>
        <div class="slider-container">
            <input type="range" id="sliderSeparacion" min="0.1" max="4.0" step="0.05" value="0.85" oninput="actualizarValores()">
        </div>
        
        <div id="rango-description"></div>

        <p style="font-size: 0.75em; margin-top: 5px;">
            <span style="color:#4CAF50; font-weight: bold;">Verde</span> = Refuerzo (Suma) | <span style="color:#FF5733; font-weight: bold;">Rojo</span> = Cancelación (Resta)
        </p>
    </div>

    <div id="container">
        <div id="label-freq" class="scene-label"></div>
        <div id="label-distancia" class="scene-label"></div>
    </div>
    
    <div id="frequency-spectrum-analyzer">
        <p style="font-size: 0.9em; margin-bottom: 3px;">Análisis de Onda en Tiempo Real</p>
        <div style="position: relative; width: 100%; height: 180px; border: 1px solid #444; border-radius: 8px; overflow: hidden; background-color: #2a2a2a;">
            <canvas id="frequency-spectrum-canvas" style="width: 100%; height: 100%; display: block;"></canvas>
            <div id="spectrum-audio-overlay" onclick="iniciarAudio()">
                Toca aquí para activar el micrófono y el análisis (HTTPS Requerido)
            </div>
        </div>
        <!-- Bloque 'spectrum-freq-ticks-labels' eliminado según la solicitud del usuario. -->
        <p id="spectrum-dominant-freq" style="font-size: 0.9em; color: #1e90ff; margin-top: 10px;">Frecuencia Predominante: No iniciado</p>
        <p id="spectrum-rango-label" style="font-size: 0.8em; font-weight: bold; color: #ccc; margin-top: 5px;">Rango: Esperando análisis...</p>
    </div>

    <div id="imagen-referencia">
        <h2>Rangos de Frecuencia Musical</h2>
        <img src="https://raw.githubusercontent.com/MauroCasarin/SONIDO/refs/heads/main/image005.jpg" alt="Gráfico de Rangos de Frecuencia para Mezcla de Sonido" />
    </div>

    <!-- Carga de la librería Three.js (la necesitamos para WebGL) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // --- CONSTANTES ---
        const SIMULATION_SIZE_Y = 8; 
        const SEGMENTS = 256;
        const VELOCIDAD_SONIDO = 340; // meters/second

        const DOMINANT_FREQ_SEARCH_LIMIT = 1000; // Max frequency to search for dominant (focus on bass/mid-bass)
        const AUDIO_PRESENCE_THRESHOLD = 1000; // Sum of all frequency values to consider "sound" present


        // --- FUNCIONES DE UTILIDAD ---
        function getRangeDescription(f) {
            if (f < 63) {
                return "Sub Bajos (25-63 Hz): A menudo se percibe como una vibración en lugar de un tono puro. La mayoría de la música generalmente no baja de los 30 Hz.";
            } else if (f >= 63 && f < 250) {
                return "Bajos (63-250 Hz): Una frecuencia que puede sentirse retumbante, pero también añade calidez y potencia. Frecuencia donde instrumentos como el bombo o las cuerdas más graves del bajo pueden tener su fundamental, proporcionando esa sensación de 'retumbo'.";
            } else if (f >= 250 && f <= 400) {
                return "Medios Bajos (250-500 Hz): Frecuencia que da 'cuerpo' y calidez al sonido. Un exceso de esta frecuencia puede hacer que el audio suene apagado, mientras que una cantidad adecuada proporciona una base sólida para la mezcla. Fundamental para la sensación de ritmo y potencia.";
            }
            return "";
        }
        
        function classifyFrequency(f) {
            if (f < 20) return "INFRA SONIDO";
            if (f < 60) return "SUB GRAVE";
            if (f < 200) return "GRAVE";
            if (f < 500) return "MEDIO GRAVE";
            if (f < 2000) return "MEDIO";
            if (f < 8000) return "MEDIO ALTO";
            if (f <= 20000) return "ALTO";
            return "ULTRA SONIDO";
        }


        // --- THREE.JS / WEBGL ---
        let scene, camera, renderer, plane, material, sub1, sub2;
        const container = document.getElementById('container');
        const labelFreq = document.getElementById('label-freq');
        const labelDistancia = document.getElementById('label-distancia');
        const vectorFreq = new THREE.Vector3(0, 0, SIMULATION_SIZE_Y / 2 * 0.875); 
        const vectorDist = new THREE.Vector3(0, 0, -0.5); 
        let startTime = performance.now(); // Para el uniforme de tiempo

        function initThree() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setClearColor(0x1e1e1e);
            container.appendChild(renderer.domElement);

            scene = new THREE.Scene();
            scene.add(new THREE.AmbientLight(0xffffff, 0.5)); // Luz ambiente para ver los objetos
            camera = new THREE.OrthographicCamera();
            camera.position.set(0, 5, 0); 
            camera.lookAt(0, 0, 0);

            const geometry = new THREE.PlaneGeometry(SIMULATION_SIZE_Y, SIMULATION_SIZE_Y, SEGMENTS, SEGMENTS);
            material = new THREE.ShaderMaterial({
                uniforms: {
                    u_lambda: { value: 3.4 }, // Initial value, updated by props
                    u_separation: { value: 0.85 }, // Initial value, updated by props
                    u_size: { value: SIMULATION_SIZE_Y },
                    u_red_color: { value: new THREE.Color(0xFF5733) }, // Original red
                    u_green_color: { value: new THREE.Color(0x4CAF50) }, // Original green
                    u_time: { value: 0.0 }, // Nuevo uniforme de tiempo para la animación
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
                `,
                fragmentShader: `
                    uniform float u_lambda;
                    uniform float u_separation;
                    uniform float u_size;
                    uniform vec3 u_red_color;
                    uniform vec3 u_green_color;
                    uniform float u_time; // Uniforme para el tiempo
                    varying vec2 vUv;

                    void main() {
                        vec2 pos = (vUv - 0.5) * u_size;
                        float sub_offset = u_separation / 2.0;

                        // Distancia a cada altavoz
                        float r1 = distance(pos, vec2(-sub_offset, 0.0));
                        float r2 = distance(pos, vec2(sub_offset, 0.0));

                        // Diferencia de fase para el patrón de interferencia estático (color base)
                        float deltaR = r2 - r1;
                        float interference_phase_diff = (deltaR / u_lambda) * 6.2831853; // 2 * PI

                        // Calculo del "power" de la interferencia estática (0=cancelación, 1=refuerzo)
                        float intensity_static = 2.0 * abs(cos(interference_phase_diff / 2.0));
                        float power_static = pow(intensity_static / 2.0, 4.0); // Potencia para mayor contraste

                        // LÓGICA DE COLOR PARA VERDE CLARO Y ROJO INTENSO
                        // El verde se vuelve más claro a medida que power_static aumenta (refuerzo)
                        // El rojo se vuelve más intenso a medida que power_static disminuye (cancelación)
                        vec3 lighter_green = mix(u_green_color, vec3(1.0, 1.0, 1.0), power_static * 0.3); // Mezclar verde con blanco
                        vec3 intense_red = mix(u_red_color, u_red_color * 1.5, 1.0 - power_static); // Intensificar rojo

                        vec3 base_color = mix(intense_red, lighter_green, power_static);


                        // Ondas animadas saliendo de cada altavoz (más rápidas)
                        float wave_speed = 15.0; // Velocidad de las ondas (más rápido)
                        float wave_frequency = 4.0; // Frecuencia de las "crestas" de las ondas (más "puntos")
                        float animated_wave1 = cos((r1 / u_lambda * wave_frequency * 6.2831853) - u_time * wave_speed);
                        float animated_wave2 = cos((r2 / u_lambda * wave_frequency * 6.2831853) - u_time * wave_speed);

                        // Combinar ambas ondas animadas para mostrar su interacción en el movimiento
                        float combined_animated_wave = (animated_wave1 + animated_wave2) / 2.0; // De -1 a 1

                        // Modulación de brillo/opacidad para crear el efecto de "puntos/curvas" animadas
                        // Usamos smoothstep para hacer las "ondas" más suaves y visibles en las crestas
                        float brightness_mod = smoothstep(0.6, 1.0, combined_animated_wave); // Hace las crestas más brillantes

                        // La opacidad también se modula para que las ondas se desvanezcan un poco
                        float final_alpha_mod = smoothstep(0.5, 1.0, combined_animated_wave);

                        // Aplicar la modulación al color base y la opacidad final
                        vec3 final_color_rgb = base_color * brightness_mod * 1.5; // Multiplicar por 1.5 para que las crestas sean más visibles
                        float final_alpha = power_static * final_alpha_mod; // Opacidad influenciada por la interferencia y la onda animada

                        // Degradado de borde para desvanecer el efecto lejos del centro
                        float border_fade = 1.0 - smoothstep(2.5, 4.0, length(pos));
                        final_color_rgb *= border_fade;
                        final_alpha *= border_fade;

                        gl_FragColor = vec4(final_color_rgb, final_alpha);
                    }
                `,
                transparent: true, side: THREE.DoubleSide
            });

            plane = new THREE.Mesh(geometry, material);
            plane.rotation.x = -Math.PI / 2;
            scene.add(plane);
            
            // Speakers
            const bafleGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            const bafleMat = new THREE.MeshBasicMaterial({ color: 0x444444, wireframe: false }); 
            const bafleEdgeMat = new THREE.LineBasicMaterial({ color: 0xffffff }); 
            const coneGeo = new THREE.ConeGeometry(0.15, 0.15, 16);
            const coneMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            coneGeo.translate(0, 0.15, -0.15); // Adjust cone position relative to box
            
            sub1 = new THREE.Mesh(bafleGeo, bafleMat);
            sub1.add(new THREE.LineSegments(new THREE.EdgesGeometry(bafleGeo), bafleEdgeMat));
            sub1.add(new THREE.Mesh(coneGeo, coneMat));
            scene.add(sub1);
            
            sub2 = new THREE.Mesh(bafleGeo, bafleMat);
            sub2.add(new THREE.LineSegments(new THREE.EdgesGeometry(bafleGeo), bafleEdgeMat));
            sub2.add(new THREE.Mesh(coneGeo, coneMat));
            scene.add(sub2);
            
            window.addEventListener('resize', onWindowResize, false);
            onWindowResize(); // Llama una vez para establecer el tamaño inicial
        }

        function onWindowResize() {
            const rect = container.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;
            
            const aspectRatio = width / height;
            
            let viewHeight = SIMULATION_SIZE_Y;
            let viewWidth = viewHeight * aspectRatio;

            // Ajustar el frustum para que se ajuste al contenedor mientras se mantiene la relación de aspecto
            if (width > height) { // Si el contenedor es más ancho que alto
                viewWidth = (SIMULATION_SIZE_Y / height) * width;
                viewHeight = SIMULATION_SIZE_Y; // Mantener la altura del mundo constante
            } else { // Si el contenedor es más alto que ancho o cuadrado
                viewHeight = (SIMULATION_SIZE_Y / width) * height;
                viewWidth = SIMULATION_SIZE_Y; // Mantener el ancho del mundo constante
            }

            camera.left = -viewWidth / 2;
            camera.right = viewWidth / 2;
            camera.top = viewHeight / 2;
            camera.bottom = -viewHeight / 2;
            
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            
            // Ajustar el overlay del analizador de audio
            const audioAnalyzerContainer = document.querySelector('#frequency-spectrum-analyzer > div'); 
            const audioAnalyzerCanvasEl = document.getElementById('frequency-spectrum-canvas');
            if (audioAnalyzerContainer && audioAnalyzerCanvasEl) {
                const audioOverlay = document.getElementById('spectrum-audio-overlay');
                if (audioOverlay) {
                    audioOverlay.style.width = `${audioAnalyzerContainer.offsetWidth}px`;
                    audioOverlay.style.height = `${audioAnalyzerContainer.offsetHeight}px`;
                    audioAnalyzerCanvasEl.width = audioAnalyzerContainer.offsetWidth;
                    audioAnalyzerCanvasEl.height = audioAnalyzerContainer.offsetHeight;
                }
            }
        }

        function updateLabels() {
            const rect = container.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;

            let posFreq = vectorFreq.clone().project(camera);
            labelFreq.style.left = `${(posFreq.x * 0.5 + 0.5) * width}px`;
            labelFreq.style.top = `${(-posFreq.y * 0.5 + 0.5) * height}px`;

            let posDist = vectorDist.clone().project(camera);
            labelDistancia.style.left = `${(posDist.x * 0.5 + 0.5) * width}px`;
            labelDistancia.style.top = `${(-posDist.y * 0.5 + 0.5) * height - 30}px`;
        }

        function animate() {
            requestAnimationFrame(animate);
            if (renderer && scene && camera && material) {
                // Actualizar el uniforme de tiempo
                const elapsedTime = (performance.now() - startTime) / 1000; // Segundos
                material.uniforms.u_time.value = elapsedTime;

                updateLabels(); 
                renderer.render(scene, camera);
                updateAudioVisualization(); 
            }
        }
        
        window.actualizarValores = function() {
            const frecuenciaHz = parseFloat(document.getElementById('sliderFrecuencia').value);
            const separacionMetros = parseFloat(document.getElementById('sliderSeparacion').value);
            const LONGITUD_ONDA = VELOCIDAD_SONIDO / frecuenciaHz;
            
            if (material) {
                material.uniforms.u_lambda.value = LONGITUD_ONDA; 
                material.uniforms.u_separation.value = separacionMetros;
            }
            const offset = separacionMetros / 2;
            if (sub1 && sub2) {
                sub1.position.x = -offset;
                sub2.position.x = offset;
            }

            labelFreq.textContent = `Frecuencia: ${frecuenciaHz.toFixed(0)} Hz`;
            labelDistancia.textContent = `Separación: ${separacionMetros.toFixed(2)} Metros`;

            const controlDirectividad = LONGITUD_ONDA / 2;
            const coherenciaMax = LONGITUD_ONDA / 4;
            let comentarioSeparacion = '';

            if (separacionMetros < coherenciaMax * 1.1) {
                comentarioSeparacion = " - Máxima Coherencia (Fuente única)";
            } else if (separacionMetros < controlDirectividad * 1.1) {
                comentarioSeparacion = " - Ideal para Control de Directividad (Arreglo Lineal)";
            } else if (separacionMetros >= controlDirectividad * 1.1) {
                 comentarioSeparacion = " - **LOBING** Severo (Cancelaciones fuertes)";
            } 
            
            document.getElementById('frecuencia-info').innerHTML = `Frecuencia: <span style="font-weight: bold; color: #4CAF50;">${frecuenciaHz.toFixed(0)} Hz</span> (L.O.: ${LONGITUD_ONDA.toFixed(2)} m) | Ideal: ${controlDirectividad.toFixed(2)} m`;
            document.getElementById('separacion-info').innerHTML = `Separación: <span style="font-weight: bold; color: #4CAF50;">${separacionMetros.toFixed(2)} m</span> <span style="color:#f0ad4e; font-weight: bold;">${comentarioSeparacion}</span>`;
            document.getElementById('rango-description').innerHTML = getRangeDescription(frecuenciaHz);
        }
        
        // --- ANALIZADOR DE AUDIO: Waveform y Frecuencia Predominante ---
        let audioContext = null;
        let analyser = null;
        let frequencyData = null; // Para la detección de frecuencia predominante
        let timeDomainData = null; // Para la visualización de la onda de tiempo
        let audioInitialized = false;
        let audioError = null; // Para almacenar mensajes de error del audio

        let audioAnalyzerCanvas = null;
        let audioAnalyzerCtx = null;
        const spectrumDominantFreqElement = document.getElementById('spectrum-dominant-freq');
        const spectrumRangoLabel = document.getElementById('spectrum-rango-label');
        const spectrumAudioOverlay = document.getElementById('spectrum-audio-overlay');

        window.iniciarAudio = function() {
            if (audioInitialized) return;
            if (audioError) return; // Si ya hay un error, no intentar de nuevo

            // Inicializar canvas y contexto aquí para asegurar que estén listos.
            audioAnalyzerCanvas = document.getElementById('frequency-spectrum-canvas');
            audioAnalyzerCtx = audioAnalyzerCanvas.getContext('2d');
            onWindowResize(); // Asegurar que el canvas tenga el tamaño correcto antes de dibujar

            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                audioError = 'Tu navegador no soporta la API de Micrófono.';
                spectrumDominantFreqElement.innerHTML = `<span style="color:red;">${audioError}</span>`;
                spectrumAudioOverlay.textContent = audioError;
                spectrumAudioOverlay.style.cursor = 'default';
                return;
            }

            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048; // Mayor FFT size para más resolución en el espectro y waveform
                analyser.smoothingTimeConstant = 0.95; // Más suavizado para una onda más estable y lenta
                frequencyData = new Uint8Array(analyser.frequencyBinCount);
                timeDomainData = new Uint8Array(analyser.fftSize); // Se usará para la visualización de la onda
                
                if (audioContext.state === 'suspended') { audioContext.resume(); }
                
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => {
                        try {
                            if (!audioContext || !analyser) { 
                                stream.getTracks().forEach(track => track.stop());
                                return;
                            }
                            const source = audioContext.createMediaStreamSource(stream);
                            source.connect(analyser);
                            spectrumAudioOverlay.style.display = 'none'; 
                            audioInitialized = true;
                            audioError = null; // Limpiar cualquier error previo
                            onWindowResize(); // Reajustar el tamaño del overlay y canvas por si acaso
                        } catch (innerError) {
                            console.error('Error connecting audio stream:', innerError);
                            audioError = 'Error al conectar el stream de audio.';
                            spectrumDominantFreqElement.innerHTML = `<span style="color:red;">${audioError}</span>`;
                            spectrumAudioOverlay.textContent = audioError;
                            spectrumAudioOverlay.style.display = 'flex';
                            spectrumAudioOverlay.style.cursor = 'default';
                            if (audioContext && audioContext.state !== 'closed') { audioContext.close().catch(console.error); }
                            stream.getTracks().forEach(track => track.stop());
                        }
                    })
                    .catch(err => {
                        console.error('Microphone access denied:', err);
                        let errorMessage = 'Acceso denegado al micrófono.';
                        if (window.location.protocol !== 'https:') {
                            errorMessage += ' (HTTPS Requerido)';
                        } else if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                            errorMessage += ' Por favor, permite el acceso en la configuración de tu navegador.';
                        } else if (err.name === 'NotFoundError') {
                            errorMessage += ' No se encontró un micrófono.';
                        } else if (err.name === 'NotReadableError') {
                            errorMessage += ' El micrófono está en uso o no disponible.';
                        } else {
                            errorMessage += ` Error desconocido: ${err.message}`;
                        }
                        audioError = errorMessage;
                        spectrumDominantFreqElement.innerHTML = `<span style="color:red;">${audioError}</span>`;
                        spectrumAudioOverlay.textContent = audioError;
                        spectrumAudioOverlay.style.display = 'flex';
                        spectrumAudioOverlay.style.cursor = 'default';
                        if (audioContext && audioContext.state !== 'closed') { audioContext.close().catch(console.error); }
                    });
            } catch (e) {
                 console.error('AudioContext error:', e);
                 audioError = 'Error de AudioContext o configuración inicial.';
                 spectrumDominantFreqElement.innerHTML = `<span style="color:red;">${audioError}</span>`;
                 spectrumAudioOverlay.textContent = audioError;
                 spectrumAudioOverlay.style.display = 'flex';
                 spectrumAudioOverlay.style.cursor = 'default';
                 if (audioContext && audioContext.state !== 'closed') { audioContext.close().catch(console.error); }
            }
        }

        function updateAudioVisualization() {
            if (!analyser || !audioInitialized || audioError) {
                if(audioError) {
                    spectrumAudioOverlay.style.display = 'flex';
                    spectrumAudioOverlay.textContent = audioError;
                }
                return;
            };
            
            // Asegurar que el canvas tenga el tamaño correcto antes de dibujar
            if (audioAnalyzerCanvas.width === 0 || audioAnalyzerCanvas.height === 0) {
                 onWindowResize();
            }

            // --- Parte de la Visualización de Onda de Tiempo ---
            analyser.getByteTimeDomainData(timeDomainData);
            audioAnalyzerCtx.clearRect(0, 0, audioAnalyzerCanvas.width, audioAnalyzerCanvas.height);
            
            audioAnalyzerCtx.lineWidth = 1;
            audioAnalyzerCtx.strokeStyle = 'rgba(68, 68, 68, 0.7)'; // Color de las líneas de la cuadrícula, más sutil
            
            // Dibujar cuadrícula horizontal (líneas punteadas)
            const horizontalLines = 4; // 2 arriba, 2 abajo del centro
            for (let i = 1; i <= horizontalLines / 2; i++) {
                const y_up = audioAnalyzerCanvas.height / 2 - (audioAnalyzerCanvas.height / horizontalLines) * i;
                const y_down = audioAnalyzerCanvas.height / 2 + (audioAnalyzerCanvas.height / horizontalLines) * i;
                audioAnalyzerCtx.setLineDash([2, 2]); // Líneas punteadas
                audioAnalyzerCtx.beginPath();
                audioAnalyzerCtx.moveTo(0, y_up);
                audioAnalyzerCtx.lineTo(audioAnalyzerCanvas.width, y_up);
                audioAnalyzerCtx.stroke();
                audioAnalyzerCtx.beginPath();
                audioAnalyzerCtx.moveTo(0, y_down);
                audioAnalyzerCtx.lineTo(audioAnalyzerCanvas.width, y_down);
                audioAnalyzerCtx.stroke();
            }

            // Dibujar cuadrícula vertical (líneas punteadas)
            const verticalLines = 6;
            for (let i = 1; i < verticalLines; i++) {
                const x_pos = (audioAnalyzerCanvas.width / verticalLines) * i;
                audioAnalyzerCtx.setLineDash([2, 2]); // Líneas punteadas
                audioAnalyzerCtx.beginPath();
                audioAnalyzerCtx.moveTo(x_pos, 0);
                audioAnalyzerCtx.lineTo(x_pos, audioAnalyzerCanvas.height);
                audioAnalyzerCtx.stroke();
            }

            // Dibujar línea central (representando 0 amplitud)
            audioAnalyzerCtx.setLineDash([]); // Línea sólida
            audioAnalyzerCtx.strokeStyle = '#cccccc'; // Color de la línea central
            audioAnalyzerCtx.lineWidth = 1;
            audioAnalyzerCtx.beginPath();
            audioAnalyzerCtx.moveTo(0, audioAnalyzerCanvas.height / 2);
            audioAnalyzerCtx.lineTo(audioAnalyzerCanvas.width, audioAnalyzerCanvas.height / 2);
            audioAnalyzerCtx.stroke();

            // *** Las etiquetas de Decibelios / Amplitud se han eliminado según la solicitud del usuario. ***

            // Dibujar la forma de onda
            audioAnalyzerCtx.lineWidth = 2; // Línea más gruesa para la onda
            audioAnalyzerCtx.strokeStyle = '#1e90ff'; // Color de la onda
            audioAnalyzerCtx.beginPath();

            const sliceWidth = audioAnalyzerCanvas.width * 1.0 / timeDomainData.length;
            let x = 0;

            for (let i = 0; i < timeDomainData.length; i++) {
                const v = timeDomainData[i] / 128.0; // Normalizar a 0-2 (1 es el centro)
                const y = v * audioAnalyzerCanvas.height / 2; // Mapear a la altura del canvas (centrado)

                if (i === 0) {
                    audioAnalyzerCtx.moveTo(x, y);
                } else {
                    audioAnalyzerCtx.lineTo(x, y);
                }
                x += sliceWidth;
            }
            audioAnalyzerCtx.lineTo(audioAnalyzerCanvas.width, audioAnalyzerCanvas.height / 2); // Asegurar que la línea termine en el borde
            audioAnalyzerCtx.stroke();

            // --- Parte de Detección de Frecuencia Predominante (usa frequencyData) ---
            analyser.getByteFrequencyData(frequencyData); // Re-obtener datos de frecuencia para el análisis
            
            let maxVolume = 0;
            let currentDominantFreq = 0;
            let totalPower = 0; // Suma de todos los valores de frecuencia para detectar presencia de audio
            const sampleRate = analyser.context.sampleRate;
            const binWidth = sampleRate / analyser.fftSize;

            for (let i = 0; i < analyser.frequencyBinCount; i++) {
                const value = frequencyData[i];
                const freq = i * binWidth;
                totalPower += value;

                // Detección de frecuencia predominante dentro de un rango específico
                if (freq >= 30 && freq <= DOMINANT_FREQ_SEARCH_LIMIT && value > maxVolume) { 
                    maxVolume = value;
                    currentDominantFreq = freq;
                }
            }

            // Actualizar UI para frecuencia predominante
            if (totalPower > AUDIO_PRESENCE_THRESHOLD) { // Solo si hay suficiente señal de audio
                spectrumDominantFreqElement.innerHTML = `Frecuencia Predominante: <span style="font-weight: bold; color:#4CAF50;">${currentDominantFreq.toFixed(1)} Hz</span>`;
                spectrumRangoLabel.innerHTML = `Rango: <span style="font-weight: bold; color:#ccc;">${classifyFrequency(currentDominantFreq)}</span>`;
            } else {
                spectrumDominantFreqElement.innerHTML = `Frecuencia Predominante: <span style="font-weight: bold; color:#aaa;">(Nivel bajo o silencioso)</span>`;
                spectrumRangoLabel.innerHTML = `Rango: <span style="font-weight: bold; color:#aaa;">(Esperando sonido...)</span>`;
            }
        }

        // --- INICIO DE LA APLICACIÓN ---
        initThree();
        window.onload = () => {
          onWindowResize(); // Para asegurar el tamaño inicial y del overlay de Three.js y Spectrum
          actualizarValores(); // Inicializar valores de la interfaz
        };
        animate();
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>