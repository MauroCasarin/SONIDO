<!DOCTYPE html>
<html>
<head>
    <title>Calculador distancia de graves según Hz.</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* --- Estilos Generales y Reseteo --- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1e1e1e;
            color: #ffffff;
            text-align: center;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden; /* Previene el scroll horizontal */
            font-size: clamp(14px, 2.5vw, 16px); /* Tamaño de fuente base responsivo */
        }
        
        /* --- Contenedor del Logo --- */
        #logo-container {
            width: 95vw;
            max-width: 800px;
            margin-top: 10px;
            padding: 10px;
            background-color: #2c2c2c;
            border-radius: 8px;
            border: 1px solid #1e90ff;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            text-align: center;
        }
        #logo-container img {
            width: 50px;
            height: auto;
            cursor: pointer;
            border-radius: 50%;
            transition: transform 0.2s;
        }
        #logo-container img:hover {
            transform: scale(1.1);
        }
        #logo-container p {
            font-size: 0.75em;
            color: #aaa;
            margin-top: 5px;
        }
        
        h1 {
            color: #4CAF50;
            padding-top: 5px;
            font-size: 1.4em;
            margin-bottom: 5px;
        }
        
        /* --- Panel de Información y Controles --- */
        #info-panel {
            flex-shrink: 0;
            font-size: 0.95em;
            padding: 15px;
            background-color: #2c2c2c;
            width: 95vw;
            max-width: 800px;
            margin: 10px auto 5px auto;
            border-radius: 8px;
            border: 1px solid #1e90ff;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            text-align: left;
        }
        
        .control-group {
            margin-bottom: 10px;
            color: #ccc;
        }
        .slider-container {
            width: 95%;
            margin: 0 auto 12px auto;
            position: relative;
        }
        .slider-label {
            display: block;
            font-size: 0.85em;
            margin-bottom: 5px;
            font-weight: bold;
            color: #1e90ff;
        }
        input[type=range] { 
            width: 100%;
            height: 5px;
            background: linear-gradient(to right, #1e90ff, #00bfff); /* Degradado para el slider */
            -webkit-appearance: none;
            border-radius: 5px;
            cursor: pointer;
            outline: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffffff;
            border: 2px solid #1e90ff;
            cursor: grab;
            box-shadow: 0 0 5px rgba(0, 191, 255, 0.7);
            transition: background 0.2s, transform 0.2s;
        }
        input[type=range]::-webkit-slider-thumb:active {
            cursor: grabbing;
            transform: scale(1.1);
        }
        
        #rango-description {
            font-weight: bold;
            color: #f0ad4e;
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #444;
            font-size: 0.8em;
            line-height: 1.4;
        }
        
        /* --- Contenedor 3D (Three.js) --- */
        #container {
            flex-grow: 1;
            width: 95vw;
            max-width: 800px;
            margin: 5px auto 10px auto;
            min-height: 250px;
            position: relative; 
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #555; /* Borde del contenedor, no del canvas */
        }
        #container canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
            border-radius: 8px;
        }

        /* --- Etiquetas en Escena 3D --- */
        .scene-label {
            position: absolute;
            background-color: rgba(30, 30, 30, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            white-space: nowrap;
            transform: translate(-50%, -50%); /* Centra la etiqueta en su posición */
            pointer-events: none; /* No interfiere con eventos del ratón */
            border: 1px solid #444;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }
        #label-freq {
            font-size: 1.14em;
            font-weight: bold;
            color: #4CAF50;
        }
        #label-distancia {
            font-size: 0.85em;
            color: #f0ad4e;
        }

        #interactive-label { /* Estilo específico para la etiqueta interactiva */
            background-color: rgba(0, 191, 255, 0.8); /* Azul claro */
            color: white;
            border: 1px solid #1e90ff;
            font-size: 0.8em;
            font-weight: bold;
            display: none; /* Inicialmente oculto */
            padding: 7px 12px;
            z-index: 11; /* Ligeramente superior a las otras etiquetas */
        }
        
        /* --- Analizador de Onda en Tiempo Real --- */
        #frequency-spectrum-analyzer {
            width: 95vw;
            max-width: 800px;
            margin: 10px auto;
            padding: 15px;
            background-color: #2c2c2c;
            border-radius: 8px;
            border: 1px solid #1e90ff;
            /* Enhanced box-shadow for a tech-inspired glow */
            box-shadow: 0 0 20px rgba(30, 144, 255, 0.4), 0 4px 8px rgba(0, 0, 0, 0.4);
            position: relative;
        }
        #frequency-spectrum-analyzer p {
            color: #ffffff;
            font-weight: bold;
            font-size: 0.9em;
            margin-bottom: 10px;
        }
        #frequency-spectrum-canvas {
            background-color: #2a2a2a;
            border-radius: 8px;
            display: block;
        }

        #spectrum-audio-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95); /* Slightly more opaque */
            color: #00bfff; /* Brighter blue for tech theme */
            font-size: 1.1em;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 21;
            border-radius: 8px;
            border: 2px solid #00bfff; /* Matching brighter blue border */
            text-shadow: 0 0 10px rgba(0, 191, 255, 0.8); /* Glow effect for text */
            transition: background-color 0.3s, color 0.3s, text-shadow 0.3s;
        }
        #spectrum-audio-overlay:hover {
            background-color: rgba(0, 0, 0, 0.8); /* Slightly less opaque on hover */
            color: white; /* White text on hover for stronger contrast */
            text-shadow: none; /* Remove glow on hover for a subtle change */
        }
        
        #spectrum-dominant-freq {
            font-size: 0.9em;
            color: #1e90ff;
            margin-top: 10px;
        }
        #spectrum-rango-label {
            font-size: 0.8em;
            font-weight: bold;
            color: #ccc;
            margin-top: 5px;
        }

        /* --- Imagen de Referencia --- */
        #imagen-referencia {
            width: 95vw;
            max-width: 800px;
            margin: 20px auto;
            padding: 15px;
            background-color: #2c2c2c;
            border-radius: 8px;
            border: 1px solid #444;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }
        #imagen-referencia h2 {
            font-size: 1.2em;
            margin-bottom: 10px; 
            color: #ffffff;
        }
        #imagen-referencia img {
            width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }

    </style>
<link rel="stylesheet" href="/index.css">
</head>
<body>
    
    <div id="logo-container">
        <a href="https://www.instagram.com/3d_mc_3d/" target="_blank" rel="noopener noreferrer">
            <img src="https://raw.githubusercontent.com/MauroCasarin/SONIDO/refs/heads/main/MC%2048%20N.png" alt="Logo MC 3D" />
        </a>
        <p>Powered by MC 3D</p>
    </div>

    <div id="info-panel">
        <h1>Calculador distancia de graves según Hz.</h1>
        
        <div id="frecuencia-info" class="control-group">Frecuencia: 100 Hz (L.O.: 3.40 m) | Ideal: 1.70 m</div>
        <label for="sliderFrecuencia" class="slider-label">Control de Frecuencia (Hz) [30 - 400 Hz]:</label>
        <div class="slider-container">
            <input type="range" id="sliderFrecuencia" min="30" max="400" step="5" value="100" oninput="actualizarValores()"> 
        </div>
        
        <div id="separacion-info" class="control-group">Separación: 0.85 metros - Máxima Coherencia</div>
        <label for="sliderSeparacion" class="slider-label">Control de Separación (Metros) [0.1 - 4.0 m]:</label>
        <div class="slider-container">
            <input type="range" id="sliderSeparacion" min="0.1" max="4.0" step="0.05" value="0.85" oninput="actualizarValores()">
        </div>

        <div class="control-group">
            <span id="zoom-info">Zoom 3D: 1.00x</span>
            <label for="sliderZoom" class="slider-label">Control de Zoom 3D [1.0x - 5.0x]:</label>
            <div class="slider-container">
                <input type="range" id="sliderZoom" min="1.0" max="5.0" step="0.1" value="1.0" oninput="actualizarZoom()">
            </div>
        </div>
        
        <div id="rango-description"></div>

        <p style="font-size: 0.75em; margin-top: 5px;">
            <span style="color:#4CAF50; font-weight: bold;">Verde</span> = Refuerzo (Suma) | <span style="color:#FF5733; font-weight: bold;">Rojo</span> = Cancelación (Resta)
        </p>
    </div>

    <div id="container">
        <div id="label-freq" class="scene-label"></div>
        <div id="label-distancia" class="scene-label"></div>
        <div id="interactive-label" class="scene-label"></div> <!-- Nueva etiqueta interactiva -->
    </div>
    
    <div id="frequency-spectrum-analyzer">
        <p style="font-size: 0.9em; margin-bottom: 3px;">Análisis de Onda en Tiempo Real</p>
        <div style="position: relative; width: 100%; height: 180px; border: 2px solid #00bfff; border-radius: 8px; overflow: hidden; background-color: #2a2a2a; box-shadow: inset 0 0 15px rgba(0, 191, 255, 0.3);">
            <canvas id="frequency-spectrum-canvas" style="width: 100%; height: 100%; display: block;"></canvas>
            <div id="spectrum-audio-overlay" onclick="iniciarAudio()">
                Toca aquí para activar el micrófono y el análisis (HTTPS Requerido)
            </div>
        </div>
        <p id="spectrum-dominant-freq" style="font-size: 0.9em; color: #1e90ff; margin-top: 10px;">Frecuencia Predominante: No iniciado</p>
        <p id="spectrum-rango-label" style="font-size: 0.8em; font-weight: bold; color: #ccc; margin-top: 5px;">Rango: Esperando análisis...</p>
    </div>

    <div id="imagen-referencia">
        <h2>Rangos de Frecuencia Musical</h2>
        <img src="https://raw.githubusercontent.com/MauroCasarin/SONIDO/refs/heads/main/image005.jpg" alt="Gráfico de Rangos de Frecuencia para Mezcla de Sonido" />
    </div>

    <!-- Carga de la librería Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // --- CONSTANTES GLOBALES ---
        const SIMULATION_SIZE_Y = 20; // Altura visual fija de la simulación 3D en unidades Three.js (AUMENTADO de 8 a 20)
        const SEGMENTS = 256; // Número de segmentos para la geometría del plano de onda
        const VELOCIDAD_SONIDO = 340; // Velocidad del sonido en metros/segundo
        const SPEAKER_HEIGHT = 5.0; // Altura de los bafles por encima del plano (Y=0), ajustada para el 20% superior, AUMENTADA a 5.0
        const LABEL_BASE_Y = 1.25; // Altura base para las etiquetas, por encima del plano (Y=0) (AUMENTADO de 0.5 a 1.25)

        // Constantes para el analizador de audio
        const DOMINANT_FREQ_SEARCH_LIMIT = 1000; // Límite superior para buscar la frecuencia dominante (foco en graves/medios-graves)
        const AUDIO_PRESENCE_THRESHOLD = 1000; // Umbral para considerar que hay "sonido" presente en el micrófono

        // --- FUNCIONES DE UTILIDAD ---
        /**
         * Retorna una descripción textual del rango de frecuencia dado.
         * @param {number} f Frecuencia en Hz.
         * @returns {string} Descripción del rango.
         */
        function getRangeDescription(f) {
            if (f < 63) {
                return "Sub Bajos (25-63 Hz): A menudo se percibe como una vibración en lugar de un tono puro. La mayoría de la música generalmente no baja de los 30 Hz.";
            } else if (f >= 63 && f < 250) {
                return "Bajos (63-250 Hz): Una frecuencia que puede sentirse retumbante, pero también añade calidez y potencia. Frecuencia donde instrumentos como el bombo o las cuerdas más graves del bajo pueden tener su fundamental, proporcionando esa sensación de 'retumbo'.";
            } else if (f >= 250 && f <= 400) {
                return "Medios Bajos (250-500 Hz): Frecuencia que da 'cuerpo' y calidez al sonido. Un exceso de esta frecuencia puede hacer que el audio suene apagado, mientras que una cantidad adecuada proporciona una base sólida para la mezcla. Fundamental para la sensación de ritmo y potencia.";
            }
            return "";
        }
        
        /**
         * Clasifica una frecuencia en un rango audible.
         * @param {number} f Frecuencia en Hz.
         * @returns {string} Clasificación del rango audible.
         */
        function classifyFrequency(f) {
            if (f < 20) return "INFRA SONIDO";
            if (f < 60) return "SUB GRAVE";
            if (f < 200) return "GRAVE";
            if (f < 500) return "MEDIO GRAVE";
            if (f < 2000) return "MEDIO";
            if (f < 8000) return "MEDIO ALTO";
            if (f <= 20000) return "ALTO";
            return "ULTRA SONIDO";
        }

        // --- VARIABLES Y CONFIGURACIÓN DE THREE.JS / WEBGL ---
        let scene, camera, renderer, plane, material, sub1, sub2;
        let ambientLight, directionalLight; // Declarar luces
        const container = document.getElementById('container');
        const labelFreq = document.getElementById('label-freq');
        const labelDistancia = document.getElementById('label-distancia');
        
        // Raycasting para interactividad
        let raycaster;
        let mouse;
        let interactiveLabel;
        let interactiveLabelTimeout;
        let clickMarker; // Nuevo marcador 3D para el clic

        // Posiciones 3D para las etiquetas de texto en la escena (AJUSTADAS para no superponerse y estar al frente)
        const vectorDistPos = new THREE.Vector3(-4, LABEL_BASE_Y, 7); // Izquierda, al frente
        const vectorFreqPos = new THREE.Vector3(4, LABEL_BASE_Y, 7);  // Derecha, al frente
        
        let startTime = performance.now(); // Para el uniforme de tiempo del shader
        let currentZoomLevel = 1.0; // Nivel de zoom actual, por defecto 1x

        /**
         * Inicializa la escena de Three.js, cámara, renderizador y objetos 3D.
         */
        function initThree() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setClearColor(0x1e1e1e); // Fondo oscuro
            renderer.shadowMap.enabled = true; // Habilitar mapas de sombras
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Sombras suaves
            container.appendChild(renderer.domElement);

            scene = new THREE.Scene();
            
            // Luz ambiente (AJUSTADA de 0.5 a 0.3)
            ambientLight = new THREE.AmbientLight(0xffffff, 0.3); 
            scene.add(ambientLight);

            // Luz direccional (simula el sol)
            directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(SIMULATION_SIZE_Y / 2, SPEAKER_HEIGHT * 2.5, SIMULATION_SIZE_Y / 4);
            directionalLight.castShadow = true;
            
            // Configuración de la cámara de sombra de la luz direccional
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.left = -SIMULATION_SIZE_Y / 2;
            directionalLight.shadow.camera.right = SIMULATION_SIZE_Y / 2;
            directionalLight.shadow.camera.top = SIMULATION_SIZE_Y / 2;
            directionalLight.shadow.camera.bottom = -SIMULATION_SIZE_Y / 2;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = SPEAKER_HEIGHT * 3;
            directionalLight.target.position.set(0, SPEAKER_HEIGHT / 2, 0); // Apuntar al centro de los bafles
            scene.add(directionalLight);
            scene.add(directionalLight.target); // Añadir el target a la escena


            // Configuración inicial de la cámara ortográfica (AJUSTADA para SIMULATION_SIZE_Y = 20)
            camera = new THREE.OrthographicCamera();
            camera.position.set(0, 5 + SPEAKER_HEIGHT * 0.8, 0); // Más arriba para ver los bafles (0, 9, 0)
            camera.lookAt(0, SPEAKER_HEIGHT / 2, 0); // Mirar entre el plano y la altura de los bafles (0, 2.5, 0)

            // Shader para el plano de interferencia
            material = new THREE.ShaderMaterial({
                uniforms: {
                    u_lambda: { value: 3.4 },          // Longitud de onda (inicial)
                    u_separation: { value: 0.85 },     // Separación de los subwoofers (inicial)
                    u_size: { value: SIMULATION_SIZE_Y }, // Tamaño del plano de simulación
                    u_red_color: { value: new THREE.Color(0xFF5733) }, // Color para cancelaciones
                    u_green_color: { value: new THREE.Color(0x4CAF50) }, // Color para refuerzos
                    u_time: { value: 0.0 },            // Tiempo para animar las ondas
                    u_speaker_height: { value: SPEAKER_HEIGHT }, // Altura de los bafles en el shader
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
                `,
                fragmentShader: `
                    uniform float u_lambda;
                    uniform float u_separation;
                    uniform float u_size;
                    uniform vec3 u_red_color;
                    uniform vec3 u_green_color;
                    uniform float u_time;
                    uniform float u_speaker_height; // Uniform para la altura de los bafles
                    varying vec2 vUv;

                    void main() {
                        vec2 pos_xz_plane = (vUv - 0.5) * u_size; // Coordenadas XZ del punto en el plano (Y=0)

                        float sub_offset = u_separation / 2.0;

                        // Definir las posiciones 3D de los altavoces
                        vec3 speaker1_pos_3d = vec3(-sub_offset, u_speaker_height, 0.0);
                        vec3 speaker2_pos_3d = vec3(sub_offset, u_speaker_height, 0.0);

                        // Definir la posición 3D del punto en el plano
                        vec3 point_on_plane_3d = vec3(pos_xz_plane.x, 0.0, pos_xz_plane.y);

                        // Calcular la distancia 3D desde cada altavoz al punto en el plano
                        float r1 = distance(point_on_plane_3d, speaker1_pos_3d);
                        float r2 = distance(point_on_plane_3d, speaker2_pos_3d);

                        // Diferencia de fase estática para el patrón de interferencia
                        float deltaR = r2 - r1;
                        float interference_phase_diff = (deltaR / u_lambda) * 6.2831853; // 2*PI

                        // Intensidad estática del patrón de interferencia (0 a 2, donde 2 es refuerzo máximo)
                        float intensity_static = 2.0 * abs(cos(interference_phase_diff / 2.0));
                        // Potencia normalizada del patrón de interferencia (0 a 1)
                        float power_static = pow(intensity_static / 2.0, 2.0); // Exponente para picos más amplios

                        // Colores basados en el patrón de interferencia
                        vec3 lighter_green = mix(u_green_color, vec3(1.0, 1.0, 1.0), power_static * 0.3); // Verde más brillante en refuerzo
                        vec3 intense_red = mix(u_red_color, u_red_color * 1.5, 1.0 - power_static);     // Rojo más intenso en cancelación
                        vec3 base_color = mix(intense_red, lighter_green, power_static);               // Mezcla entre rojo y verde

                        // Ondas animadas para simular propagación
                        float wave_speed = 15.0;
                        float wave_frequency = 0.4; // Multiplicador para la frecuencia visual de la onda (REDUCIDO de 0.6 a 0.4 para ondas aún más grandes)
                        float animated_wave1 = cos((r1 / u_lambda * wave_frequency * 6.2831853) - u_time * wave_speed);
                        float animated_wave2 = cos((r2 / u_lambda * wave_frequency * 6.2831853) - u_time * wave_speed);

                        float combined_animated_wave = (animated_wave1 + animated_wave2) / 2.0;

                        // Modular el brillo y el alfa basado en la onda animada (AJUSTADO para mayor cobertura y brillo)
                        float brightness_mod = smoothstep(-0.7, 1.0, combined_animated_wave); // Umbral inferior para visibilidad ampliado
                        float final_alpha_mod = smoothstep(-0.9, 1.0, combined_animated_wave); // Umbral inferior para visibilidad ampliado

                        // Calcular el color final y el alfa (Multiplicador de brillo aumentado)
                        vec3 final_color_rgb = base_color * brightness_mod * 2.5; 
                        float final_alpha = power_static * final_alpha_mod;

                        // Efecto de desvanecimiento en los bordes para un look más suave (AJUSTADO de (3.8, 4.0) a (9.8, 10.0))
                        float border_fade = 1.0 - smoothstep(9.8, 10.0, length(pos_xz_plane)); 
                        final_color_rgb *= border_fade;
                        final_alpha *= border_fade;

                        gl_FragColor = vec4(final_color_rgb, final_alpha);
                    }
                `,
                transparent: true, // Habilitar transparencia
                side: THREE.DoubleSide // Renderizar ambos lados del plano
            });

            plane = new THREE.Mesh(new THREE.PlaneGeometry(SIMULATION_SIZE_Y, SIMULATION_SIZE_Y, SEGMENTS, SEGMENTS), material);
            plane.rotation.x = -Math.PI / 2; // Orientar el plano horizontalmente
            plane.receiveShadow = true; // El plano recibe sombras
            scene.add(plane);
            
            // Subwoofers (cajas y conos) (AJUSTADOS para SIMULATION_SIZE_Y = 20)
            const bafleGeo = new THREE.BoxGeometry(1.5, 1.5, 1.5); // AUMENTADO de 0.6 a 1.5
            // MATERIAL AJUSTADO para soportar sombras (MeshPhongMaterial o MeshLambertMaterial)
            const bafleMat = new THREE.MeshPhongMaterial({ color: 0x444444 }); 
            const bafleEdgeMat = new THREE.LineBasicMaterial({ color: 0xffffff }); 
            const coneGeo = new THREE.ConeGeometry(0.75, 0.75, 16); // AUMENTADO de 0.3 a 0.75
            // MATERIAL AJUSTADO para soportar sombras
            const coneMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
            coneGeo.translate(0, 0.375, -0.75); // Ajustado para el nuevo tamaño del bafle (1.5/2 = 0.75 de profundidad, 0.75/2 = 0.375 de offset Y)
            
            sub1 = new THREE.Mesh(bafleGeo, bafleMat);
            sub1.add(new THREE.LineSegments(new THREE.EdgesGeometry(bafleGeo), bafleEdgeMat));
            sub1.add(new THREE.Mesh(coneGeo, coneMat));
            sub1.position.y = SPEAKER_HEIGHT; // Elevar bafle 1
            sub1.castShadow = true; // El subwoofer 1 proyecta sombras
            scene.add(sub1);
            
            sub2 = new THREE.Mesh(bafleGeo, bafleMat);
            sub2.add(new THREE.LineSegments(new THREE.EdgesGeometry(bafleGeo), bafleEdgeMat));
            sub2.add(new THREE.Mesh(coneGeo, coneMat));
            sub2.position.y = SPEAKER_HEIGHT; // Elevar bafle 2
            sub2.castShadow = true; // El subwoofer 2 proyecta sombras
            scene.add(sub2);
            
            // Inicializar Raycaster e interactividad
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            interactiveLabel = document.getElementById('interactive-label');

            // Inicializar marcador 3D para el clic (AJUSTADO para SIMULATION_SIZE_Y = 20)
            const markerGeometry = new THREE.SphereGeometry(0.2, 16, 16); // AUMENTADO de 0.08 a 0.2
            const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 }); // Amarillo brillante
            clickMarker = new THREE.Mesh(markerGeometry, markerMaterial);
            clickMarker.visible = false; // Oculto inicialmente
            scene.add(clickMarker);

            renderer.domElement.addEventListener('mousedown', onMouseDown, false);

            // Listeners para redimensionamiento de ventana
            window.addEventListener('resize', onWindowResize, false);

            // Llamar a onWindowResize una vez para configurar el renderizador y la cámara inicialmente
            onWindowResize();
        }

        /**
         * Ajusta el tamaño del renderizador y la proyección de la cámara cuando la ventana cambia de tamaño.
         */
        function onWindowResize() {
            const rect = container.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;
            
            renderer.setSize(width, height);

            // Ajustar la cámara ortográfica para mantener el aspecto y la altura de la simulación
            const aspect = width / height;
            // viewHeight se calcula para que los speakers (en Y=SPEAKER_HEIGHT) estén al 20% desde el top visible
            // y el plano (en Y=0) sea visible, incluyendo SIMULATION_SIZE_Y en su extensión
            // El zoom se aplica aquí
            const viewHeight = (SIMULATION_SIZE_Y / 0.4) / currentZoomLevel; 

            camera.left = -viewHeight * aspect / 2;
            camera.right = viewHeight * aspect / 2;
            camera.top = viewHeight / 2;
            camera.bottom = -viewHeight / 2;
            camera.updateProjectionMatrix();
            
            // Asegurarse de que el canvas del analizador de audio también se redimensione
            const audioAnalyzerContainer = document.querySelector('#frequency-spectrum-analyzer > div'); 
            const audioAnalyzerCanvasEl = document.getElementById('frequency-spectrum-canvas');
            if (audioAnalyzerContainer && audioAnalyzerCanvasEl) {
                audioAnalyzerCanvasEl.width = audioAnalyzerContainer.offsetWidth;
                audioAnalyzerCanvasEl.height = audioAnalyzerContainer.offsetHeight;
                const audioOverlay = document.getElementById('spectrum-audio-overlay');
                if (audioOverlay) {
                    // Update overlay size dynamically
                    audioOverlay.style.width = `${audioAnalyzerContainer.offsetWidth}px`;
                    audioOverlay.style.height = `${audioAnalyzerContainer.offsetHeight}px`;
                }
            }
        }

        /**
         * Actualiza las posiciones en pantalla de las etiquetas de frecuencia y distancia.
         */
        function updateLabels() {
            const rect = container.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;

            // Proyectar la posición 3D de la etiqueta de frecuencia a coordenadas de pantalla
            let posFreq = vectorFreqPos.clone().project(camera);
            labelFreq.style.left = `${(posFreq.x * 0.5 + 0.5) * width}px`;
            labelFreq.style.top = `${(-posFreq.y * 0.5 + 0.5) * height}px`;

            // Proyectar la posición 3D de la etiqueta de distancia a coordenadas de pantalla
            let posDist = vectorDistPos.clone().project(camera);
            labelDistancia.style.left = `${(posDist.x * 0.5 + 0.5) * width}px`;
            labelDistancia.style.top = `${(-posDist.y * 0.5 + 0.5) * height}px`;
        }

        /**
         * Maneja el evento mousedown para detectar clics en el plano 3D.
         * @param {MouseEvent} event
         */
        function onMouseDown(event) {
            event.preventDefault();

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObject(plane);

            if (intersects.length > 0) {
                const intersectPoint = intersects[0].point;
                showInteractiveLabel(intersectPoint);
            } else {
                // Si no se hizo clic en el plano, ocultar la etiqueta interactiva y el marcador
                if (interactiveLabelTimeout) clearTimeout(interactiveLabelTimeout);
                interactiveLabel.style.display = 'none';
                clickMarker.visible = false;
            }
        }

        /**
         * Muestra una etiqueta interactiva con información de la onda en un punto 3D.
         * @param {THREE.Vector3} point El punto 3D donde se hizo clic.
         */
        function showInteractiveLabel(point) {
            const separation = material.uniforms.u_separation.value;
            const lambda = material.uniforms.u_lambda.value;
            const speakerHeight = material.uniforms.u_speaker_height.value;
            
            const subOffset = separation / 2;

            // Distancia desde cada "subwoofer" al punto actual (el punto ya está en el plano XZ)
            // Recalcular distancias 3D como en el shader
            const pointOnPlane3D = new THREE.Vector3(point.x, point.y, point.z); // point.y debería ser 0 para el plano
            const speaker1Pos3D = new THREE.Vector3(-subOffset, speakerHeight, 0);
            const speaker2Pos3D = new THREE.Vector3(subOffset, speakerHeight, 0);

            const r1 = pointOnPlane3D.distanceTo(speaker1Pos3D);
            const r2 = pointOnPlane3D.distanceTo(speaker2Pos3D);

            // Diferencia de fase estática para el patrón de interferencia
            const deltaR = r2 - r1;
            const interferencePhaseDiff = (deltaR / lambda) * (2 * Math.PI);

            // Intensidad estática del patrón de interferencia (0 a 2, donde 2 es refuerzo máximo)
            const intensityStatic = 2 * Math.abs(Math.cos(interferencePhaseDiff / 2));
            // Potencia normalizada del patrón de interferencia (0 a 1)
            const powerStatic = Math.pow(intensityStatic / 2, 2.0); // Usar la misma lógica del shader (modificada)

            let interpretation = "";
            if (powerStatic > 0.95) {
                interpretation = "Refuerzo Fuerte";
            } else if (powerStatic > 0.6) {
                interpretation = "Refuerzo Moderado";
            } else if (powerStatic < 0.05) {
                interpretation = "Cancelación Fuerte";
            } else if (powerStatic < 0.3) {
                interpretation = "Cancelación Moderada";
            } else {
                interpretation = "Zona de Transición";
            }

            interactiveLabel.textContent = `Intensidad: ${(powerStatic * 100).toFixed(0)}% (${interpretation})`;
            
            // Proyectar la posición 3D del punto de clic a coordenadas de pantalla
            const screenPosition = point.clone().project(camera);
            const rect = container.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;

            interactiveLabel.style.left = `${(screenPosition.x * 0.5 + 0.5) * width}px`;
            interactiveLabel.style.top = `${(-screenPosition.y * 0.5 + 0.5) * height}px`;
            interactiveLabel.style.display = 'block';

            // Posicionar y mostrar el marcador 3D (AJUSTADO para SIMULATION_SIZE_Y = 20)
            clickMarker.position.copy(point);
            clickMarker.position.y = 0.05; // Asegurarse de que esté ligeramente por encima del plano (AUMENTADO de 0.01 a 0.05)
            clickMarker.visible = true;

            if (interactiveLabelTimeout) clearTimeout(interactiveLabelTimeout);
            interactiveLabelTimeout = setTimeout(() => {
                interactiveLabel.style.display = 'none';
                clickMarker.visible = false; // Ocultar también el marcador 3D
            }, 3000); // Ocultar después de 3 segundos
        }


        /**
         * Bucle principal de animación de Three.js.
         */
        function animate() {
            requestAnimationFrame(animate);
            if (renderer && scene && camera && material) {
                const elapsedTime = (performance.now() - startTime) / 1000;
                material.uniforms.u_time.value = elapsedTime;
                
                updateLabels(); // Actualizar la posición de las etiquetas HTML
                renderer.render(scene, camera); // Renderizar la escena 3D
                updateAudioVisualization(); // Actualizar la visualización del analizador de audio
            }
        }
        
        /**
         * Actualiza los valores de los uniformes del shader y la información mostrada en el panel de control.
         */
        window.actualizarValores = function() {
            const frecuenciaHz = parseFloat(document.getElementById('sliderFrecuencia').value);
            const separacionMetros = parseFloat(document.getElementById('sliderSeparacion').value);
            const LONGITUD_ONDA = VELOCIDAD_SONIDO / frecuenciaHz;
            
            if (material) {
                material.uniforms.u_lambda.value = LONGITUD_ONDA; 
                material.uniforms.u_separation.value = separacionMetros;
            }

            // Mover los subwoofers 3D
            const offset = separacionMetros / 2;
            if (sub1 && sub2) {
                sub1.position.x = -offset;
                sub2.position.x = offset;
            }

            // Actualizar texto de las etiquetas HTML 3D de forma concisa
            labelFreq.textContent = `${frecuenciaHz.toFixed(0)} Hz`;
            labelDistancia.textContent = `${separacionMetros.toFixed(2)} Metros`;

            // Calcular y mostrar información de control de directividad y coherencia
            const controlDirectividad = LONGITUD_ONDA / 2;
            const coherenciaMax = LONGITUD_ONDA / 4;
            let comentarioSeparacion = '';

            if (separacionMetros < coherenciaMax * 1.1) {
                comentarioSeparacion = " - Máxima Coherencia (Fuente única)";
            } else if (separacionMetros < controlDirectividad * 1.1) {
                comentarioSeparacion = " - Ideal para Control de Directividad (Arreglo Lineal)";
            } else if (separacionMetros >= controlDirectividad * 1.1) {
                 comentarioSeparacion = " - **LOBING** Severo (Cancelaciones fuertes)";
            } 
            
            document.getElementById('frecuencia-info').innerHTML = `Frecuencia: <span style="font-weight: bold; color: #4CAF50;">${frecuenciaHz.toFixed(0)} Hz</span> (L.O.: ${LONGITUD_ONDA.toFixed(2)} m) | Ideal: ${controlDirectividad.toFixed(2)} m`;
            document.getElementById('separacion-info').innerHTML = `Separación: <span style="font-weight: bold; color: #4CAF50;">${separacionMetros.toFixed(2)} m</span> <span style="color:#f0ad4e; font-weight: bold;">${comentarioSeparacion}</span>`;
            document.getElementById('rango-description').innerHTML = getRangeDescription(frecuenciaHz);
        }

        /**
         * Actualiza el nivel de zoom de la cámara 3D.
         */
        window.actualizarZoom = function() {
            currentZoomLevel = parseFloat(document.getElementById('sliderZoom').value);
            document.getElementById('zoom-info').textContent = `Zoom 3D: ${currentZoomLevel.toFixed(2)}x`;
            onWindowResize(); // Re-calcular la proyección de la cámara con el nuevo zoom
        }
        
        // --- ANALIZADOR DE AUDIO: Waveform y Frecuencia Predominante ---
        let audioContext = null;
        let analyser = null;
        let frequencyData = null;
        let timeDomainData = null;
        let audioInitialized = false;
        let audioError = null;

        let audioAnalyzerCanvas = null;
        let audioAnalyzerCtx = null;
        const spectrumDominantFreqElement = document.getElementById('spectrum-dominant-freq');
        const spectrumRangoLabel = document.getElementById('spectrum-rango-label');
        const spectrumAudioOverlay = document.getElementById('spectrum-audio-overlay');

        /**
         * Inicializa el AudioContext y solicita acceso al micrófono.
         */
        window.iniciarAudio = function() {
            if (audioInitialized || audioError) return;

            audioAnalyzerCanvas = document.getElementById('frequency-spectrum-canvas');
            audioAnalyzerCtx = audioAnalyzerCanvas.getContext('2d');
            onWindowResize(); // Asegurar que el canvas tenga el tamaño correcto antes de dibujar

            // Verificar compatibilidad del navegador
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                audioError = 'Tu navegador no soporta la API de Micrófono.';
                spectrumDominantFreqElement.innerHTML = `<span style="color:red;">${audioError}</span>`;
                spectrumAudioOverlay.textContent = audioError;
                spectrumAudioOverlay.style.cursor = 'default';
                return;
            }

            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048; // Número de muestras para FFT
                analyser.smoothingTimeConstant = 0.95; // Suavizado de los datos de frecuencia
                frequencyData = new Uint8Array(analyser.frequencyBinCount); // Array para datos de frecuencia
                timeDomainData = new Uint8Array(analyser.fftSize); // Array para datos de tiempo
                
                // Reanudar el AudioContext si está suspendido (necesario para la interacción del usuario)
                if (audioContext.state === 'suspended') { audioContext.resume(); }
                
                // Solicitar acceso al micrófono
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => {
                        try {
                            if (!audioContext || !analyser) { 
                                stream.getTracks().forEach(track => track.stop()); // Detener stream si AudioContext no existe
                                return;
                            }
                            const source = audioContext.createMediaStreamSource(stream);
                            source.connect(analyser); // Conectar el micrófono al analizador
                            spectrumAudioOverlay.style.display = 'none'; // Ocultar overlay
                            audioInitialized = true;
                            audioError = null;
                            onWindowResize(); // Re-ajustar canvas después de ocultar el overlay
                        } catch (innerError) {
                            console.error('Error al conectar el stream de audio:', innerError);
                            audioError = 'Error al conectar el stream de audio.';
                            spectrumDominantFreqElement.innerHTML = `<span style="color:red;">${audioError}</span>`;
                            spectrumAudioOverlay.textContent = audioError;
                            spectrumAudioOverlay.style.display = 'flex';
                            spectrumAudioOverlay.style.cursor = 'default';
                            if (audioContext && audioContext.state !== 'closed') { audioContext.close().catch(console.error); }
                            stream.getTracks().forEach(track => track.stop()); // Detener el stream si hay error
                        }
                    })
                    .catch(err => {
                        console.error('Acceso denegado al micrófono:', err);
                        let errorMessage = 'Acceso denegado al micrófono.';
                        if (window.location.protocol !== 'https:') {
                            errorMessage += ' (HTTPS Requerido)';
                        } else if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                            errorMessage += ' Por favor, permite el acceso en la configuración de tu navegador.';
                        } else if (err.name === 'NotFoundError') {
                            errorMessage += ' No se encontró un micrófono.';
                        } else if (err.name === 'NotReadableError') {
                            errorMessage += ' El micrófono está en uso o no disponible.';
                        } else {
                            errorMessage += ` Error desconocido: ${err.message}`;
                        }
                        audioError = errorMessage;
                        spectrumDominantFreqElement.innerHTML = `<span style="color:red;">${audioError}</span>`;
                        spectrumAudioOverlay.textContent = errorMessage;
                        spectrumAudioOverlay.style.display = 'flex';
                        spectrumAudioOverlay.style.cursor = 'default';
                        if (audioContext && audioContext.state !== 'closed') { audioContext.close().catch(console.error); }
                    });
            } catch (e) {
                 console.error('Error de AudioContext:', e);
                 audioError = 'Error de AudioContext o configuración inicial.';
                 spectrumDominantFreqElement.innerHTML = `<span style="color:red;">${audioError}</span>`;
                 spectrumAudioOverlay.textContent = audioError;
                 spectrumAudioOverlay.style.display = 'flex';
                 spectrumAudioOverlay.style.cursor = 'default';
                 if (audioContext && audioContext.state !== 'closed') { audioContext.close().catch(console.error); }
            }
        }

        /**
         * Dibuja la visualización de la forma de onda y detecta la frecuencia predominante.
         */
        function updateAudioVisualization() {
            if (!analyser || !audioInitialized || audioError) {
                if(audioError) {
                    spectrumAudioOverlay.style.display = 'flex';
                    spectrumAudioOverlay.textContent = audioError;
                }
                return;
            }
            
            // Asegurar que el canvas tenga el tamaño correcto
            if (audioAnalyzerCanvas.width === 0 || audioAnalyzerCanvas.height === 0) {
                 onWindowResize();
            }

            // Limpiar el canvas antes de dibujar
            audioAnalyzerCtx.clearRect(0, 0, audioAnalyzerCanvas.width, audioAnalyzerCanvas.height);
            
            // --- Dibujar cuadrícula y línea central ---
            audioAnalyzerCtx.lineWidth = 1;
            audioAnalyzerCtx.strokeStyle = 'rgba(68, 68, 68, 0.7)';
            audioAnalyzerCtx.setLineDash([2, 2]); // Líneas punteadas
            
            const horizontalLines = 4; // Número de secciones horizontales
            for (let i = 1; i <= horizontalLines / 2; i++) {
                const y_offset = (audioAnalyzerCanvas.height / horizontalLines) * i;
                const y_up = audioAnalyzerCanvas.height / 2 - y_offset;
                const y_down = audioAnalyzerCanvas.height / 2 + y_offset;
                
                audioAnalyzerCtx.beginPath(); audioAnalyzerCtx.moveTo(0, y_up); audioAnalyzerCtx.lineTo(audioAnalyzerCanvas.width, y_up); audioAnalyzerCtx.stroke();
                audioAnalyzerCtx.beginPath(); audioAnalyzerCtx.moveTo(0, y_down); audioAnalyzerCtx.lineTo(audioAnalyzerCanvas.width, y_down); audioAnalyzerCtx.stroke();
            }
            const verticalLines = 6; // Número de secciones verticales
            for (let i = 1; i < verticalLines; i++) {
                const x_pos = (audioAnalyzerCanvas.width / verticalLines) * i;
                audioAnalyzerCtx.beginPath(); audioAnalyzerCtx.moveTo(x_pos, 0); audioAnalyzerCtx.lineTo(x_pos, audioAnalyzerCanvas.height); audioAnalyzerCtx.stroke();
            }
            
            audioAnalyzerCtx.setLineDash([]); // Restablecer a líneas sólidas
            audioAnalyzerCtx.strokeStyle = '#cccccc'; // Color para la línea central
            audioAnalyzerCtx.lineWidth = 1;
            audioAnalyzerCtx.beginPath();
            audioAnalyzerCtx.moveTo(0, audioAnalyzerCanvas.height / 2);
            audioAnalyzerCtx.lineTo(audioAnalyzerCanvas.width, audioAnalyzerCanvas.height / 2);
            audioAnalyzerCtx.stroke();

            // --- Dibujar la forma de onda del tiempo ---
            analyser.getByteTimeDomainData(timeDomainData); // Obtener datos de la forma de onda
            audioAnalyzerCtx.lineWidth = 2;
            audioAnalyzerCtx.strokeStyle = '#1e90ff'; // Color de la onda
            audioAnalyzerCtx.beginPath();

            const sliceWidth = audioAnalyzerCanvas.width * 1.0 / timeDomainData.length;
            let x = 0;

            for (let i = 0; i < timeDomainData.length; i++) {
                let v = timeDomainData[i] / 128.0; // Normalizar a 0-2 (128 es el centro)
                let y = v * audioAnalyzerCanvas.height / 2; // Escalar a la altura del canvas

                if (i === 0) {
                    audioAnalyzerCtx.moveTo(x, y);
                } else {
                    audioAnalyzerCtx.lineTo(x, y);
                }
                x += sliceWidth;
            }
            audioAnalyzerCtx.lineTo(audioAnalyzerCanvas.width, audioAnalyzerCanvas.height / 2); // Cerrar la línea en el centro al final
            audioAnalyzerCtx.stroke();

            // --- Detección de Frecuencia Predominante ---
            analyser.getByteFrequencyData(frequencyData); // Obtener datos del espectro de frecuencia
            
            let maxVolume = 0;
            let currentDominantFreq = 0;
            let totalPower = 0;
            const sampleRate = analyser.context.sampleRate;
            const binWidth = sampleRate / analyser.fftSize; // Ancho de cada "banda" de frecuencia

            for (let i = 0; i < analyser.frequencyBinCount; i++) {
                const value = frequencyData[i];
                const freq = i * binWidth;
                totalPower += value; // Suma total de la potencia de todas las frecuencias

                // Buscar la frecuencia con mayor volumen dentro de un rango específico
                if (freq >= 30 && freq <= DOMINANT_FREQ_SEARCH_LIMIT && value > maxVolume) { 
                    maxVolume = value;
                    currentDominantFreq = freq;
                }
            }

            // Actualizar el texto de la frecuencia dominante solo si hay suficiente volumen
            if (totalPower > AUDIO_PRESENCE_THRESHOLD) {
                spectrumDominantFreqElement.innerHTML = `Frecuencia Predominante: <span style="font-weight: bold; color:#4CAF50;">${currentDominantFreq.toFixed(1)} Hz</span>`;
                spectrumRangoLabel.innerHTML = `Rango: <span style="font-weight: bold; color:#ccc;">${classifyFrequency(currentDominantFreq)}</span>`;
            } else {
                spectrumDominantFreqElement.innerHTML = `Frecuencia Predominante: <span style="font-weight: bold; color:#aaa;">(Nivel bajo o silencioso)</span>`;
                spectrumRangoLabel.innerHTML = `Rango: <span style="font-weight: bold; color:#aaa;">(Esperando sonido...)</span>`;
            }
        }

        // --- INICIO DE LA APLICACIÓN ---
        initThree(); // Inicializar Three.js
        window.onload = () => {
          actualizarValores(); // Establecer valores iniciales de los sliders y actualizar la UI
          actualizarZoom(); // Establecer el zoom inicial
        };
        animate(); // Iniciar el bucle de animación
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>