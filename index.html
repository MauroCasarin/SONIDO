<!DOCTYPE html>
<html>
<head>
    <title>Calculador distancia de graves según Hz.</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* --- Estilos Generales y Reseteo --- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1e1e1e;
            color: #ffffff;
            text-align: center;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden; /* Previene el scroll horizontal */
            font-size: clamp(14px, 2.5vw, 16px); /* Tamaño de fuente base responsivo */
        }
        
        /* --- Contenedor del Logo --- */
        #logo-container {
            width: 95vw;
            max-width: 800px;
            margin-top: 10px;
            padding: 10px;
            background-color: #2c2c2c;
            border-radius: 8px;
            border: 1px solid #1e90ff;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            text-align: center;
        }
        #logo-container img {
            width: 50px;
            height: auto;
            cursor: pointer;
            border-radius: 50%;
            transition: transform 0.2s;
        }
        #logo-container img:hover {
            transform: scale(1.1);
        }
        #logo-container p {
            font-size: 0.75em;
            color: #aaa;
            margin-top: 5px;
        }
        
        h1 {
            color: #4CAF50;
            padding-top: 5px;
            font-size: 1.4em;
            margin-bottom: 5px;
        }
        
        /* --- Panel de Información y Controles --- */
        #info-panel {
            flex-shrink: 0;
            font-size: 0.95em;
            padding: 15px;
            background-color: #2c2c2c;
            width: 95vw;
            max-width: 800px;
            margin: 10px auto 5px auto;
            border-radius: 8px;
            border: 1px solid #1e90ff;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            text-align: left;
        }
        
        .control-group {
            margin-bottom: 10px;
            color: #ccc;
        }
        .slider-container {
            width: 95%;
            margin: 0 auto 12px auto;
            position: relative;
        }
        .slider-label {
            display: block;
            font-size: 0.85em;
            margin-bottom: 5px;
            font-weight: bold;
            color: #1e90ff;
        }
        input[type=range] { 
            width: 100%;
            height: 5px;
            background: linear-gradient(to right, #1e90ff, #00bfff); /* Degradado para el slider */
            -webkit-appearance: none;
            border-radius: 5px;
            cursor: pointer;
            outline: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffffff;
            border: 2px solid #1e90ff;
            cursor: grab;
            box-shadow: 0 0 5px rgba(0, 191, 255, 0.7);
            transition: background 0.2s, transform 0.2s;
        }
        input[type=range]::-webkit-slider-thumb:active {
            cursor: grabbing;
            transform: scale(1.1);
        }
        
        #rango-description {
            font-weight: bold;
            color: #f0ad4e;
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #444;
            font-size: 0.8em;
            line-height: 1.4;
        }
        
        /* --- Contenedor 3D (Three.js) --- */
        #container {
            flex-grow: 1;
            width: 95vw;
            max-width: 800px;
            margin: 5px auto 10px auto;
            min-height: 250px;
            position: relative; 
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #555; /* Borde del contenedor, no del canvas */
        }
        #container canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
            border-radius: 8px;
        }

        /* --- Etiquetas en Escena 3D --- */
        .scene-label {
            position: absolute;
            background-color: rgba(30, 30, 30, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            white-space: nowrap;
            transform: translate(-50%, -50%); /* Centra la etiqueta en su posición */
            pointer-events: none; /* No interfiere con eventos del ratón */
            border: 1px solid #444;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }
        #label-freq {
            font-size: 1.14em;
            font-weight: bold;
            color: #4CAF50;
        }
        #label-distancia {
            font-size: 0.85em;
            color: #f0ad4e;
        }
        
        /* --- Analizador de Onda en Tiempo Real --- */
        #frequency-spectrum-analyzer {
            width: 95vw;
            max-width: 800px;
            margin: 10px auto;
            padding: 15px;
            background-color: #2c2c2c;
            border-radius: 8px;
            border: 1px solid #1e90ff;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            position: relative;
        }
        #frequency-spectrum-analyzer p {
            color: #ffffff;
            font-weight: bold;
            font-size: 0.9em;
            margin-bottom: 10px;
        }
        #frequency-spectrum-canvas {
            background-color: #2a2a2a;
            border-radius: 8px;
            display: block;
        }

        #spectrum-audio-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            color: #1e90ff;
            font-size: 1.1em;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 21;
            border-radius: 8px;
            transition: background-color 0.3s;
        }
        #spectrum-audio-overlay:hover {
            background-color: rgba(0, 0, 0, 0.7);
        }
        
        #spectrum-dominant-freq {
            font-size: 0.9em;
            color: #1e90ff;
            margin-top: 10px;
        }
        #spectrum-rango-label {
            font-size: 0.8em;
            font-weight: bold;
            color: #ccc;
            margin-top: 5px;
        }

        /* --- Imagen de Referencia --- */
        #imagen-referencia {
            width: 95vw;
            max-width: 800px;
            margin: 20px auto;
            padding: 15px;
            background-color: #2c2c2c;
            border-radius: 8px;
            border: 1px solid #444;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }
        #imagen-referencia h2 {
            font-size: 1.2em;
            margin-bottom: 10px; 
            color: #ffffff;
        }
        #imagen-referencia img {
            width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }

    </style>
<link rel="stylesheet" href="/index.css">
</head>
<body>
    
    <div id="logo-container">
        <a href="https://www.instagram.com/3d_mc_3d/" target="_blank" rel="noopener noreferrer">
            <img src="https://raw.githubusercontent.com/MauroCasarin/SONIDO/refs/heads/main/MC%2048%20N.png" alt="Logo MC 3D" />
        </a>
        <p>Powered by MC 3D</p>
    </div>

    <div id="info-panel">
        <h1>Calculador distancia de graves según Hz.</h1>
        
        <div id="frecuencia-info" class="control-group">Frecuencia: 100 Hz (L.O.: 3.40 m) | Ideal: 1.70 m</div>
        <label for="sliderFrecuencia" class="slider-label">Control de Frecuencia (Hz) [30 - 400 Hz]:</label>
        <div class="slider-container">
            <input type="range" id="sliderFrecuencia" min="30" max="400" step="5" value="100" oninput="actualizarValores()"> 
        </div>
        
        <div id="separacion-info" class="control-group">Separación: 0.85 metros - Máxima Coherencia</div>
        <label for="sliderSeparacion" class="slider-label">Control de Separación (Metros) [0.1 - 4.0 m]:</label>
        <div class="slider-container">
            <input type="range" id="sliderSeparacion" min="0.1" max="4.0" step="0.05" value="0.85" oninput="actualizarValores()">
        </div>
        
        <div id="rango-description"></div>

        <p style="font-size: 0.75em; margin-top: 5px;">
            <span style="color:#4CAF50; font-weight: bold;">Verde</span> = Refuerzo (Suma) | <span style="color:#FF5733; font-weight: bold;">Rojo</span> = Cancelación (Resta)
        </p>
    </div>

    <div id="container">
        <div id="label-freq" class="scene-label"></div>
        <div id="label-distancia" class="scene-label"></div>
    </div>
    
    <div id="frequency-spectrum-analyzer">
        <p style="font-size: 0.9em; margin-bottom: 3px;">Análisis de Onda en Tiempo Real</p>
        <div style="position: relative; width: 100%; height: 180px; border: 1px solid #444; border-radius: 8px; overflow: hidden; background-color: #2a2a2a;">
            <canvas id="frequency-spectrum-canvas" style="width: 100%; height: 100%; display: block;"></canvas>
            <div id="spectrum-audio-overlay" onclick="iniciarAudio()">
                Toca aquí para activar el micrófono y el análisis (HTTPS Requerido)
            </div>
        </div>
        <p id="spectrum-dominant-freq" style="font-size: 0.9em; color: #1e90ff; margin-top: 10px;">Frecuencia Predominante: No iniciado</p>
        <p id="spectrum-rango-label" style="font-size: 0.8em; font-weight: bold; color: #ccc; margin-top: 5px;">Rango: Esperando análisis...</p>
    </div>

    <div id="imagen-referencia">
        <h2>Rangos de Frecuencia Musical</h2>
        <img src="https://raw.githubusercontent.com/MauroCasarin/SONIDO/refs/heads/main/image005.jpg" alt="Gráfico de Rangos de Frecuencia para Mezcla de Sonido" />
    </div>

    <!-- Carga de la librería Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // --- CONSTANTES GLOBALES ---
        const SIMULATION_SIZE_Y = 8; // Altura visual fija de la simulación 3D en unidades Three.js
        const SEGMENTS = 256; // Número de segmentos para la geometría del plano de onda
        const VELOCIDAD_SONIDO = 340; // Velocidad del sonido en metros/segundo

        // Constantes para el analizador de audio
        const DOMINANT_FREQ_SEARCH_LIMIT = 1000; // Límite superior para buscar la frecuencia dominante (foco en graves/medios-graves)
        const AUDIO_PRESENCE_THRESHOLD = 1000; // Umbral para considerar que hay "sonido" presente en el micrófono

        // --- FUNCIONES DE UTILIDAD ---
        /**
         * Retorna una descripción textual del rango de frecuencia dado.
         * @param {number} f Frecuencia en Hz.
         * @returns {string} Descripción del rango.
         */
        function getRangeDescription(f) {
            if (f < 63) {
                return "Sub Bajos (25-63 Hz): A menudo se percibe como una vibración en lugar de un tono puro. La mayoría de la música generalmente no baja de los 30 Hz.";
            } else if (f >= 63 && f < 250) {
                return "Bajos (63-250 Hz): Una frecuencia que puede sentirse retumbante, pero también añade calidez y potencia. Frecuencia donde instrumentos como el bombo o las cuerdas más graves del bajo pueden tener su fundamental, proporcionando esa sensación de 'retumbo'.";
            } else if (f >= 250 && f <= 400) {
                return "Medios Bajos (250-500 Hz): Frecuencia que da 'cuerpo' y calidez al sonido. Un exceso de esta frecuencia puede hacer que el audio suene apagado, mientras que una cantidad adecuada proporciona una base sólida para la mezcla. Fundamental para la sensación de ritmo y potencia.";
            }
            return "";
        }
        
        /**
         * Clasifica una frecuencia en un rango audible.
         * @param {number} f Frecuencia en Hz.
         * @returns {string} Clasificación del rango audible.
         */
        function classifyFrequency(f) {
            if (f < 20) return "INFRA SONIDO";
            if (f < 60) return "SUB GRAVE";
            if (f < 200) return "GRAVE";
            if (f < 500) return "MEDIO GRAVE";
            if (f < 2000) return "MEDIO";
            if (f < 8000) return "MEDIO ALTO";
            if (f <= 20000) return "ALTO";
            return "ULTRA SONIDO";
        }

        // --- VARIABLES Y CONFIGURACIÓN DE THREE.JS / WEBGL ---
        let scene, camera, renderer, plane, material, sub1, sub2;
        const container = document.getElementById('container');
        const labelFreq = document.getElementById('label-freq');
        const labelDistancia = document.getElementById('label-distancia');

        // Posiciones 3D para las etiquetas de texto en la escena
        // Ajustadas para que "Separación" esté a la izquierda y "Frecuencia" a la derecha, en la parte superior.
        const vectorDistPos = new THREE.Vector3(-SIMULATION_SIZE_Y / 4, 0, SIMULATION_SIZE_Y / 2 * 0.90); // Izquierda
        const vectorFreqPos = new THREE.Vector3(SIMULATION_SIZE_Y / 4, 0, SIMULATION_SIZE_Y / 2 * 0.90);  // Derecha
        
        let startTime = performance.now(); // Para el uniforme de tiempo del shader

        /**
         * Inicializa la escena de Three.js, cámara, renderizador y objetos 3D.
         */
        function initThree() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setClearColor(0x1e1e1e); // Fondo oscuro
            container.appendChild(renderer.domElement);

            scene = new THREE.Scene();
            scene.add(new THREE.AmbientLight(0xffffff, 0.5)); // Luz ambiente
            
            // Configuración inicial de la cámara ortográfica
            camera = new THREE.OrthographicCamera();
            camera.position.set(0, 5, 0); // Posición de la cámara
            camera.lookAt(0, 0, 0); // Apuntando al centro de la escena

            // Shader para el plano de interferencia
            material = new THREE.ShaderMaterial({
                uniforms: {
                    u_lambda: { value: 3.4 },          // Longitud de onda (inicial)
                    u_separation: { value: 0.85 },     // Separación de los subwoofers (inicial)
                    u_size: { value: SIMULATION_SIZE_Y }, // Tamaño del plano de simulación
                    u_red_color: { value: new THREE.Color(0xFF5733) }, // Color para cancelaciones
                    u_green_color: { value: new THREE.Color(0x4CAF50) }, // Color para refuerzos
                    u_time: { value: 0.0 },            // Tiempo para animar las ondas
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
                `,
                fragmentShader: `
                    uniform float u_lambda;
                    uniform float u_separation;
                    uniform float u_size;
                    uniform vec3 u_red_color;
                    uniform vec3 u_green_color;
                    uniform float u_time;
                    varying vec2 vUv;

                    void main() {
                        vec2 pos_xz = (vUv - 0.5) * u_size; // Convertir UV a coordenadas XZ del mundo

                        float sub_offset = u_separation / 2.0;

                        // Distancia desde cada "subwoofer" al punto actual
                        float r1 = distance(pos_xz, vec2(-sub_offset, 0.0));
                        float r2 = distance(pos_xz, vec2(sub_offset, 0.0));

                        // Diferencia de fase estática para el patrón de interferencia
                        float deltaR = r2 - r1;
                        float interference_phase_diff = (deltaR / u_lambda) * 6.2831853; // 2*PI

                        // Intensidad estática del patrón de interferencia (0 a 2, donde 2 es refuerzo máximo)
                        float intensity_static = 2.0 * abs(cos(interference_phase_diff / 2.0));
                        // Potencia normalizada del patrón de interferencia (0 a 1)
                        float power_static = pow(intensity_static / 2.0, 4.0); // Exponente para hacer los picos más definidos

                        // Colores basados en el patrón de interferencia
                        vec3 lighter_green = mix(u_green_color, vec3(1.0, 1.0, 1.0), power_static * 0.3); // Verde más brillante en refuerzo
                        vec3 intense_red = mix(u_red_color, u_red_color * 1.5, 1.0 - power_static);     // Rojo más intenso en cancelación
                        vec3 base_color = mix(intense_red, lighter_green, power_static);               // Mezcla entre rojo y verde

                        // Ondas animadas para simular propagación
                        float wave_speed = 15.0;
                        float wave_frequency = 4.0; // Multiplicador para la frecuencia visual de la onda
                        float animated_wave1 = cos((r1 / u_lambda * wave_frequency * 6.2831853) - u_time * wave_speed);
                        float animated_wave2 = cos((r2 / u_lambda * wave_frequency * 6.2831853) - u_time * wave_speed);

                        float combined_animated_wave = (animated_wave1 + animated_wave2) / 2.0;

                        // El efecto de rebote del escenario ha sido eliminado.
                        // combined_animated_wave permanece sin modificar por el escenario.

                        // Modular el brillo y el alfa basado en la onda animada
                        float brightness_mod = smoothstep(0.6, 1.0, combined_animated_wave);
                        float final_alpha_mod = smoothstep(0.5, 1.0, combined_animated_wave);

                        // Calcular el color final y el alfa
                        vec3 final_color_rgb = base_color * brightness_mod * 1.5;
                        float final_alpha = power_static * final_alpha_mod;

                        // Efecto de desvanecimiento en los bordes para un look más suave
                        float border_fade = 1.0 - smoothstep(2.5, 4.0, length(pos_xz));
                        final_color_rgb *= border_fade;
                        final_alpha *= border_fade;

                        gl_FragColor = vec4(final_color_rgb, final_alpha);
                    }
                `,
                transparent: true, // Habilitar transparencia
                side: THREE.DoubleSide // Renderizar ambos lados del plano
            });

            plane = new THREE.Mesh(new THREE.PlaneGeometry(SIMULATION_SIZE_Y, SIMULATION_SIZE_Y, SEGMENTS, SEGMENTS), material);
            plane.rotation.x = -Math.PI / 2; // Orientar el plano horizontalmente
            scene.add(plane);
            
            // Subwoofers (cajas y conos)
            const bafleGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            const bafleMat = new THREE.MeshBasicMaterial({ color: 0x444444, wireframe: false }); 
            const bafleEdgeMat = new THREE.LineBasicMaterial({ color: 0xffffff }); 
            const coneGeo = new THREE.ConeGeometry(0.15, 0.15, 16);
            const coneMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            coneGeo.translate(0, 0.15, -0.15); // Ajustar la posición del cono respecto a la caja
            
            sub1 = new THREE.Mesh(bafleGeo, bafleMat);
            sub1.add(new THREE.LineSegments(new THREE.EdgesGeometry(bafleGeo), bafleEdgeMat));
            sub1.add(new THREE.Mesh(coneGeo, coneMat));
            scene.add(sub1);
            
            sub2 = new THREE.Mesh(bafleGeo, bafleMat);
            sub2.add(new THREE.LineSegments(new THREE.EdgesGeometry(bafleGeo), bafleEdgeMat));
            sub2.add(new THREE.Mesh(coneGeo, coneMat));
            scene.add(sub2);
            
            // Listeners para redimensionamiento de ventana
            window.addEventListener('resize', onWindowResize, false);

            // Llamar a onWindowResize una vez para configurar el renderizador y la cámara inicialmente
            onWindowResize();
        }

        /**
         * Ajusta el tamaño del renderizador y la proyección de la cámara cuando la ventana cambia de tamaño.
         */
        function onWindowResize() {
            const rect = container.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;
            
            renderer.setSize(width, height);

            // Ajustar la cámara ortográfica para mantener el aspecto y la altura de la simulación
            const aspect = width / height;
            const sceneHeight = SIMULATION_SIZE_Y; // La altura fija de nuestra simulación en unidades Three.js
            
            camera.left = -sceneHeight * aspect / 2;
            camera.right = sceneHeight * aspect / 2;
            camera.top = sceneHeight / 2;
            camera.bottom = -sceneHeight / 2;
            camera.updateProjectionMatrix();
            
            // Asegurarse de que el canvas del analizador de audio también se redimensione
            const audioAnalyzerContainer = document.querySelector('#frequency-spectrum-analyzer > div'); 
            const audioAnalyzerCanvasEl = document.getElementById('frequency-spectrum-canvas');
            if (audioAnalyzerContainer && audioAnalyzerCanvasEl) {
                audioAnalyzerCanvasEl.width = audioAnalyzerContainer.offsetWidth;
                audioAnalyzerCanvasEl.height = audioAnalyzerContainer.offsetHeight;
                const audioOverlay = document.getElementById('spectrum-audio-overlay');
                if (audioOverlay) {
                    audioOverlay.style.width = `${audioAnalyzerContainer.offsetWidth}px`;
                    audioOverlay.style.height = `${audioAnalyzerContainer.offsetHeight}px`;
                }
            }
        }

        /**
         * Actualiza las posiciones en pantalla de las etiquetas de frecuencia y distancia.
         */
        function updateLabels() {
            const rect = container.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;

            // Proyectar la posición 3D de la etiqueta de frecuencia a coordenadas de pantalla
            let posFreq = vectorFreqPos.clone().project(camera);
            labelFreq.style.left = `${(posFreq.x * 0.5 + 0.5) * width}px`;
            labelFreq.style.top = `${(-posFreq.y * 0.5 + 0.5) * height}px`;

            // Proyectar la posición 3D de la etiqueta de distancia a coordenadas de pantalla
            let posDist = vectorDistPos.clone().project(camera);
            labelDistancia.style.left = `${(posDist.x * 0.5 + 0.5) * width}px`;
            labelDistancia.style.top = `${(-posDist.y * 0.5 + 0.5) * height}px`;
        }

        /**
         * Bucle principal de animación de Three.js.
         */
        function animate() {
            requestAnimationFrame(animate);
            if (renderer && scene && camera && material) {
                const elapsedTime = (performance.now() - startTime) / 1000;
                material.uniforms.u_time.value = elapsedTime;
                
                updateLabels(); // Actualizar la posición de las etiquetas HTML
                renderer.render(scene, camera); // Renderizar la escena 3D
                updateAudioVisualization(); // Actualizar la visualización del analizador de audio
            }
        }
        
        /**
         * Actualiza los valores de los uniformes del shader y la información mostrada en el panel de control.
         */
        window.actualizarValores = function() {
            const frecuenciaHz = parseFloat(document.getElementById('sliderFrecuencia').value);
            const separacionMetros = parseFloat(document.getElementById('sliderSeparacion').value);
            const LONGITUD_ONDA = VELOCIDAD_SONIDO / frecuenciaHz;
            
            if (material) {
                material.uniforms.u_lambda.value = LONGITUD_ONDA; 
                material.uniforms.u_separation.value = separacionMetros;
            }

            // Mover los subwoofers 3D
            const offset = separacionMetros / 2;
            if (sub1 && sub2) {
                sub1.position.x = -offset;
                sub2.position.x = offset;
            }

            // Actualizar texto de las etiquetas HTML 3D de forma concisa
            labelFreq.textContent = `${frecuenciaHz.toFixed(0)} Hz`;
            labelDistancia.textContent = `${separacionMetros.toFixed(2)} Metros`;

            // Calcular y mostrar información de control de directividad y coherencia
            const controlDirectividad = LONGITUD_ONDA / 2;
            const coherenciaMax = LONGITUD_ONDA / 4;
            let comentarioSeparacion = '';

            if (separacionMetros < coherenciaMax * 1.1) {
                comentarioSeparacion = " - Máxima Coherencia (Fuente única)";
            } else if (separacionMetros < controlDirectividad * 1.1) {
                comentarioSeparacion = " - Ideal para Control de Directividad (Arreglo Lineal)";
            } else if (separacionMetros >= controlDirectividad * 1.1) {
                 comentarioSeparacion = " - **LOBING** Severo (Cancelaciones fuertes)";
            } 
            
            document.getElementById('frecuencia-info').innerHTML = `Frecuencia: <span style="font-weight: bold; color: #4CAF50;">${frecuenciaHz.toFixed(0)} Hz</span> (L.O.: ${LONGITUD_ONDA.toFixed(2)} m) | Ideal: ${controlDirectividad.toFixed(2)} m`;
            document.getElementById('separacion-info').innerHTML = `Separación: <span style="font-weight: bold; color: #4CAF50;">${separacionMetros.toFixed(2)} m</span> <span style="color:#f0ad4e; font-weight: bold;">${comentarioSeparacion}</span>`;
            document.getElementById('rango-description').innerHTML = getRangeDescription(frecuenciaHz);
        }
        
        // --- ANALIZADOR DE AUDIO: Waveform y Frecuencia Predominante ---
        let audioContext = null;
        let analyser = null;
        let frequencyData = null;
        let timeDomainData = null;
        let audioInitialized = false;
        let audioError = null;

        let audioAnalyzerCanvas = null;
        let audioAnalyzerCtx = null;
        const spectrumDominantFreqElement = document.getElementById('spectrum-dominant-freq');
        const spectrumRangoLabel = document.getElementById('spectrum-rango-label');
        const spectrumAudioOverlay = document.getElementById('spectrum-audio-overlay');

        /**
         * Inicializa el AudioContext y solicita acceso al micrófono.
         */
        window.iniciarAudio = function() {
            if (audioInitialized || audioError) return;

            audioAnalyzerCanvas = document.getElementById('frequency-spectrum-canvas');
            audioAnalyzerCtx = audioAnalyzerCanvas.getContext('2d');
            onWindowResize(); // Asegurar que el canvas tenga el tamaño correcto antes de dibujar

            // Verificar compatibilidad del navegador
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                audioError = 'Tu navegador no soporta la API de Micrófono.';
                spectrumDominantFreqElement.innerHTML = `<span style="color:red;">${audioError}</span>`;
                spectrumAudioOverlay.textContent = audioError;
                spectrumAudioOverlay.style.cursor = 'default';
                return;
            }

            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048; // Número de muestras para FFT
                analyser.smoothingTimeConstant = 0.95; // Suavizado de los datos de frecuencia
                frequencyData = new Uint8Array(analyser.frequencyBinCount); // Array para datos de frecuencia
                timeDomainData = new Uint8Array(analyser.fftSize); // Array para datos de tiempo
                
                // Reanudar el AudioContext si está suspendido (necesario para la interacción del usuario)
                if (audioContext.state === 'suspended') { audioContext.resume(); }
                
                // Solicitar acceso al micrófono
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => {
                        try {
                            if (!audioContext || !analyser) { 
                                stream.getTracks().forEach(track => track.stop()); // Detener stream si AudioContext no existe
                                return;
                            }
                            const source = audioContext.createMediaStreamSource(stream);
                            source.connect(analyser); // Conectar el micrófono al analizador
                            spectrumAudioOverlay.style.display = 'none'; // Ocultar overlay
                            audioInitialized = true;
                            audioError = null;
                            onWindowResize(); // Re-ajustar canvas después de ocultar el overlay
                        } catch (innerError) {
                            console.error('Error al conectar el stream de audio:', innerError);
                            audioError = 'Error al conectar el stream de audio.';
                            spectrumDominantFreqElement.innerHTML = `<span style="color:red;">${audioError}</span>`;
                            spectrumAudioOverlay.textContent = audioError;
                            spectrumAudioOverlay.style.display = 'flex';
                            spectrumAudioOverlay.style.cursor = 'default';
                            if (audioContext && audioContext.state !== 'closed') { audioContext.close().catch(console.error); }
                            stream.getTracks().forEach(track => track.stop()); // Detener el stream si hay error
                        }
                    })
                    .catch(err => {
                        console.error('Acceso denegado al micrófono:', err);
                        let errorMessage = 'Acceso denegado al micrófono.';
                        if (window.location.protocol !== 'https:') {
                            errorMessage += ' (HTTPS Requerido)';
                        } else if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                            errorMessage += ' Por favor, permite el acceso en la configuración de tu navegador.';
                        } else if (err.name === 'NotFoundError') {
                            errorMessage += ' No se encontró un micrófono.';
                        } else if (err.name === 'NotReadableError') {
                            errorMessage += ' El micrófono está en uso o no disponible.';
                        } else {
                            errorMessage += ` Error desconocido: ${err.message}`;
                        }
                        audioError = errorMessage;
                        spectrumDominantFreqElement.innerHTML = `<span style="color:red;">${audioError}</span>`;
                        spectrumAudioOverlay.textContent = errorMessage;
                        spectrumAudioOverlay.style.display = 'flex';
                        spectrumAudioOverlay.style.cursor = 'default';
                        if (audioContext && audioContext.state !== 'closed') { audioContext.close().catch(console.error); }
                    });
            } catch (e) {
                 console.error('Error de AudioContext:', e);
                 audioError = 'Error de AudioContext o configuración inicial.';
                 spectrumDominantFreqElement.innerHTML = `<span style="color:red;">${audioError}</span>`;
                 spectrumAudioOverlay.textContent = audioError;
                 spectrumAudioOverlay.style.display = 'flex';
                 spectrumAudioOverlay.style.cursor = 'default';
                 if (audioContext && audioContext.state !== 'closed') { audioContext.close().catch(console.error); }
            }
        }

        /**
         * Dibuja la visualización de la forma de onda y detecta la frecuencia predominante.
         */
        function updateAudioVisualization() {
            if (!analyser || !audioInitialized || audioError) {
                if(audioError) {
                    spectrumAudioOverlay.style.display = 'flex';
                    spectrumAudioOverlay.textContent = audioError;
                }
                return;
            }
            
            // Asegurar que el canvas tenga el tamaño correcto
            if (audioAnalyzerCanvas.width === 0 || audioAnalyzerCanvas.height === 0) {
                 onWindowResize();
            }

            // Limpiar el canvas antes de dibujar
            audioAnalyzerCtx.clearRect(0, 0, audioAnalyzerCanvas.width, audioAnalyzerCanvas.height);
            
            // --- Dibujar cuadrícula y línea central ---
            audioAnalyzerCtx.lineWidth = 1;
            audioAnalyzerCtx.strokeStyle = 'rgba(68, 68, 68, 0.7)';
            audioAnalyzerCtx.setLineDash([2, 2]); // Líneas punteadas
            
            const horizontalLines = 4; // Número de secciones horizontales
            for (let i = 1; i <= horizontalLines / 2; i++) {
                const y_offset = (audioAnalyzerCanvas.height / horizontalLines) * i;
                const y_up = audioAnalyzerCanvas.height / 2 - y_offset;
                const y_down = audioAnalyzerCanvas.height / 2 + y_offset;
                
                audioAnalyzerCtx.beginPath(); audioAnalyzerCtx.moveTo(0, y_up); audioAnalyzerCtx.lineTo(audioAnalyzerCanvas.width, y_up); audioAnalyzerCtx.stroke();
                audioAnalyzerCtx.beginPath(); audioAnalyzerCtx.moveTo(0, y_down); audioAnalyzerCtx.lineTo(audioAnalyzerCanvas.width, y_down); audioAnalyzerCtx.stroke();
            }
            const verticalLines = 6; // Número de secciones verticales
            for (let i = 1; i < verticalLines; i++) {
                const x_pos = (audioAnalyzerCanvas.width / verticalLines) * i;
                audioAnalyzerCtx.beginPath(); audioAnalyzerCtx.moveTo(x_pos, 0); audioAnalyzerCtx.lineTo(x_pos, audioAnalyzerCanvas.height); audioAnalyzerCtx.stroke();
            }
            
            audioAnalyzerCtx.setLineDash([]); // Restablecer a líneas sólidas
            audioAnalyzerCtx.strokeStyle = '#cccccc'; // Color para la línea central
            audioAnalyzerCtx.lineWidth = 1;
            audioAnalyzerCtx.beginPath();
            audioAnalyzerCtx.moveTo(0, audioAnalyzerCanvas.height / 2);
            audioAnalyzerCtx.lineTo(audioAnalyzerCanvas.width, audioAnalyzerCanvas.height / 2);
            audioAnalyzerCtx.stroke();

            // --- Dibujar la forma de onda del tiempo ---
            analyser.getByteTimeDomainData(timeDomainData); // Obtener datos de la forma de onda
            audioAnalyzerCtx.lineWidth = 2;
            audioAnalyzerCtx.strokeStyle = '#1e90ff'; // Color de la onda
            audioAnalyzerCtx.beginPath();

            const sliceWidth = audioAnalyzerCanvas.width * 1.0 / timeDomainData.length;
            let x = 0;

            for (let i = 0; i < timeDomainData.length; i++) {
                let v = timeDomainData[i] / 128.0; // Normalizar a 0-2 (128 es el centro)
                let y = v * audioAnalyzerCanvas.height / 2; // Escalar a la altura del canvas

                if (i === 0) {
                    audioAnalyzerCtx.moveTo(x, y);
                } else {
                    audioAnalyzerCtx.lineTo(x, y);
                }
                x += sliceWidth;
            }
            audioAnalyzerCtx.lineTo(audioAnalyzerCanvas.width, audioAnalyzerCanvas.height / 2); // Cerrar la línea en el centro al final
            audioAnalyzerCtx.stroke();

            // --- Detección de Frecuencia Predominante ---
            analyser.getByteFrequencyData(frequencyData); // Obtener datos del espectro de frecuencia
            
            let maxVolume = 0;
            let currentDominantFreq = 0;
            let totalPower = 0;
            const sampleRate = analyser.context.sampleRate;
            const binWidth = sampleRate / analyser.fftSize; // Ancho de cada "banda" de frecuencia

            for (let i = 0; i < analyser.frequencyBinCount; i++) {
                const value = frequencyData[i];
                const freq = i * binWidth;
                totalPower += value; // Suma total de la potencia de todas las frecuencias

                // Buscar la frecuencia con mayor volumen dentro de un rango específico
                if (freq >= 30 && freq <= DOMINANT_FREQ_SEARCH_LIMIT && value > maxVolume) { 
                    maxVolume = value;
                    currentDominantFreq = freq;
                }
            }

            // Actualizar el texto de la frecuencia dominante solo si hay suficiente volumen
            if (totalPower > AUDIO_PRESENCE_THRESHOLD) {
                spectrumDominantFreqElement.innerHTML = `Frecuencia Predominante: <span style="font-weight: bold; color:#4CAF50;">${currentDominantFreq.toFixed(1)} Hz</span>`;
                spectrumRangoLabel.innerHTML = `Rango: <span style="font-weight: bold; color:#ccc;">${classifyFrequency(currentDominantFreq)}</span>`;
            } else {
                spectrumDominantFreqElement.innerHTML = `Frecuencia Predominante: <span style="font-weight: bold; color:#aaa;">(Nivel bajo o silencioso)</span>`;
                spectrumRangoLabel.innerHTML = `Rango: <span style="font-weight: bold; color:#aaa;">(Esperando sonido...)</span>`;
            }
        }

        // --- INICIO DE LA APLICACIÓN ---
        initThree(); // Inicializar Three.js
        window.onload = () => {
          actualizarValores(); // Establecer valores iniciales de los sliders y actualizar la UI
        };
        animate(); // Iniciar el bucle de animación
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>