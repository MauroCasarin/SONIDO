<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Simulador Educativo de Sonidos Graves</title>
    <style>
        :root {
            --bg-dark: #09090b; /* Zinc 950 */
            --bg-panel: rgba(10, 10, 12, 1.0); /* 100% Opaque initially */
            --border: rgba(255, 255, 255, 0.1);
            --accent: #3b82f6;   /* Blue 500 */
            --accent-glow: rgba(59, 130, 246, 0.3);
            --text-main: #e4e4e7;
            --text-dim: #a1a1aa;
            --danger: #ef4444;
            --success: #22c55e;
            --warning: #f59e0b;
            --gold: #ffd700;
        }

        body {
            background-color: var(--bg-dark);
            color: var(--text-main);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior: none;
        }

        /* HEADER */
        header {
            height: 40px; 
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
            background: rgba(5,5,5,0.95);
            backdrop-filter: blur(5px);
            flex-shrink: 0;
            z-index: 50;
        }

        .brand-area {
            display: flex;
            flex-direction: column; /* Changed to column to stack title and author */
            align-items: flex-start; /* Align items to the start for stacking */
            gap: 2px; /* Smaller gap */
            margin-left: 8px; /* Added left margin for consistency */
        }

        .brand-link {
            text-decoration: none;
            display: flex;
            align-items: center;
        }

        .logo-img {
            height: 28px;
            width: auto;
            transition: transform 0.2s;
            cursor: pointer;
            position: absolute; /* Position absolute to move it out of flex flow */
            left: 10px; /* Align to the left edge of the header */
            top: 6px; /* Center vertically in the header */
        }
        
        h1 {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 0;
            color: #fff;
            line-height: 1;
            margin-left: 40px; /* Offset to make space for the logo */
        }

        h1 span {
            font-size: 8px;
            color: var(--accent);
            letter-spacing: 1px;
        }

        /* New styles for author link in header */
        .author-link {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            color: #52525b; /* Same as old footer color */
            text-decoration: none;
            font-size: 9px; /* Same as old footer font size */
            font-weight: 500;
            letter-spacing: 0.5px;
            margin-left: 40px; /* Offset to align with title */
            transition: color 0.2s;
        }
        .author-link:hover {
            color: var(--accent);
        }
        .author-icon {
            width: 10px;
            height: 10px;
            fill: currentColor;
        }


        /* LAYOUT */
        #main-layout {
            display: flex;
            flex: 1;
            height: calc(100vh - 40px); /* Adjusted height, no footer now */
            overflow: hidden;
            position: relative;
        }

        /* SIDEBAR (CONTROLES) */
        #controles {
            width: 280px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow-y: auto;
            flex-shrink: 0;
            z-index: 20;
            overscroll-behavior: contain;
            transition: opacity 0.2s ease;
        }

        /* Top Controls Bar */
        .controls-top-bar {
            display: flex;
            gap: 5px;
            margin-bottom: 5px;
        }
        
        .controls-top-bar button {
            flex: 1;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        /* Animation for Play Button when Paused */
        @keyframes pulse-glow {
            0% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.0); transform: scale(1); border-color: rgba(80, 80, 90, 0.5); }
            50% { box-shadow: 0 0 12px 2px rgba(59, 130, 246, 0.4); transform: scale(1.02); border-color: var(--accent); color: #fff; text-shadow: 0 0 8px var(--accent); }
            100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.0); transform: scale(1); border-color: rgba(80, 80, 90, 0.5); }
        }

        .vp-btn.paused {
            animation: pulse-glow 2.5s infinite;
        }

        /* CLASE PARA AUTO-OCULTAR (70% OPACIDAD) */
        .controls-dimmed {
            opacity: 0.7 !important;
            pointer-events: none; /* Prevent interaction while dragging canvas */
        }

        /* CANVAS AREA */
        #viewport {
            flex: 1;
            position: relative;
            background: #000;
            overflow: hidden;
            cursor: crosshair;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        canvas {
            display: block;
            touch-action: none;
            /* SUAVIZADO VISUAL */
            filter: blur(0.5px) contrast(1.1); 
            image-rendering: optimizeQuality;
        }

        .btn-help-main {
            border-radius: 4px;
            font-weight: bold;
            font-size: 14px;
        }

        /* CUSTOM TOOLTIP (ANIMATED & DELAYED) */
        .custom-tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 11px;
            pointer-events: none;
            z-index: 1000;
            max-width: 220px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.6);
            text-align: center; /* Centered horizontally */
            line-height: 1.4;
            opacity: 0;
            transition: opacity 0.4s ease; /* Only opacity for fade in/out */

            /* New centering styles */
            top: 20px; /* Distance from the top */
            left: 50%;
            transform: translateX(-50%);
        }
        
        .custom-tooltip.visible {
            opacity: 1;
        }

        .custom-tooltip strong {
            display: block;
            color: var(--accent);
            margin-bottom: 3px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* UI ELEMENTS */
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            background: rgba(255,255,255,0.03);
            padding: 8px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.05);
        }

        .group-title {
            font-size: 8px;
            font-weight: 700;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 2px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .slider-row {
            margin-bottom: 2px;
            position: relative; /* Make it a positioning context for absolute children */
        }
        .slider-row.disabled { opacity: 0.3; pointer-events: none; }
        .slider-label {
            display: flex; justify-content: space-between; font-size: 9px;
            color: var(--text-dim); margin-bottom: 1px;
        }
        .slider-val { 
            color: var(--accent); 
            font-family: monospace; 
            font-weight: bold; 
            transition: font-size 0.1s ease-out, transform 0.1s ease-out, color 0.1s ease-out; /* Smooth transition */
            display: inline-block; /* Required for transform to work properly */
        }

        input[type=range] {
            -webkit-appearance: none; width: 100%; background: transparent; padding: 4px 0; margin: 0;
        }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 14px; width: 14px;
            border-radius: 50%; background: #e4e4e7; cursor: pointer;
            margin-top: -6px; box-shadow: 0 1px 3px rgba(0,0,0,0.8); border: 1px solid #000;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 2px; cursor: pointer;
            background: rgba(255, 255, 255, 0.2); border-radius: 1px;
        }

        /* Styles for enlarged slider values */
        .slider-val.enlarged-value {
            font-size: 1.5em; /* Example: 1.5 times current size */
            transform: scale(1.1); /* Slightly scale it as well */
            color: var(--warning); /* Different color for emphasis */
        }

        .btn-row { display: flex; gap: 4px; }
        
        button {
            background: rgba(30, 30, 35, 0.9);
            border: 1px solid rgba(80, 80, 90, 0.5);
            color: var(--text-dim);
            padding: 6px; font-size: 9px; font-weight: 600;
            border-radius: 3px; cursor: pointer; transition: all 0.2s; text-transform: uppercase;
        }
        button:hover { background: rgba(60, 60, 70, 0.9); color: #fff; }
        button.active { background: var(--accent); color: #fff; border-color: var(--accent); box-shadow: 0 0 8px var(--accent-glow); }
        button.danger { color: var(--danger); border-color: rgba(239, 68, 68, 0.3); background: rgba(239, 68, 68, 0.05); }
        button.magic { background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%); color: white; border: none; box-shadow: 0 0 8px rgba(124, 58, 237, 0.3); }
        button.red-magic { background: linear-gradient(135deg, #ef4444 0%, #b91c1c 100%); color: white; border: none; box-shadow: 0 0 8px rgba(239, 68, 68, 0.3); }
        button.small-btn { padding: 4px; font-size: 8px; }

        /* BAFFLE CONTROL GRID */
        .baffle-list {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .baffle-row {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(0,0,0,0.2);
            padding: 4px 6px;
            border-radius: 3px;
            justify-content: space-between;
        }
        .baffle-info {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .baffle-controls {
            display: flex;
            align-items: center;
            gap: 4px;
            flex: 1;
        }
        .baffle-num {
            font-size: 9px;
            color: #a1a1aa;
            width: 12px;
            font-weight: bold;
        }
        .baffle-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 20px;
            font-size: 9px;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 2px;
            cursor: pointer;
            background: rgba(255,255,255,0.05);
            color: #71717a;
            padding: 0 4px;
        }
        .baffle-btn.active {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border-color: #ef4444;
            font-weight: bold;
        }
        .baffle-btn.dir-active {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
            border-color: #3b82f6;
            font-weight: bold;
        }
        /* Delay Slider in Baffle Row */
        .delay-slider-container {
            flex: 1.5;
            display: flex;
            flex-direction: column;
            margin-left: 2px;
        }
        .delay-slider-container input {
            height: 2px;
            margin: 2px 0;
        }
        .delay-val {
            font-size: 8px; /* Base size for delay values */
            color: var(--warning); /* Keep warning color for delay, will override with original color if needed */
            text-align: right;
            font-family: monospace;
            line-height: 1;
            transition: font-size 0.1s ease-out, transform 0.1s ease-out, color 0.1s ease-out; /* Smooth transition */
            display: inline-block; /* Required for transform to work properly */
        }
        .delay-val.enlarged-value {
            font-size: 1.5em; /* Enlarge delay values */
            transform: scale(1.1);
            color: var(--gold); /* Use gold for enlarged delay for distinction */
        }


        /* HUD & OVERLAYS */
        .hud-panel {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0, 0, 0, 0.6); border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(3px); padding: 8px; border-radius: 44px;
            width: 140px; pointer-events: none; z-index: 15; transition: opacity 0.3s;
        }
        .hud-row { display: flex; justify-content: space-between; font-size: 9px; margin-bottom: 3px; font-family: monospace; }
        .hud-label { color: #a1a1aa; }
        .hud-value { color: #fff; font-weight: bold; }
        
        /* MODAL GUÍA */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); backdrop-filter: blur(5px);
            z-index: 200; display: flex; align-items: center; justify-content: center;
            opacity: 0; pointer-events: none; transition: opacity 0.3s ease;
        }
        .modal-overlay.open { opacity: 1; pointer-events: auto; }
        .modal-content {
            background: #18181b; border: 1px solid #3f3f46; border-radius: 8px;
            padding: 20px; width: 85%; max-width: 320px; /* Adjust max-width if more content is desired */
            max-height: 80vh; /* Max height to fit screen */
            overflow-y: auto; /* Enable scrolling if content overflows */
            box-shadow: 0 20px 50px rgba(0,0,0,0.8); transform: translateY(15px); transition: transform 0.3s ease;
        }
        .modal-overlay.open .modal-content { transform: translateY(0); }
        .modal-title {
            color: #fff; font-size: 13px; margin: 0 0 15px 0; padding-bottom: 8px;
            border-bottom: 1px solid #27272a; text-align: center; text-transform: uppercase;
        }
        .guide-item { display: flex; gap: 10px; margin-bottom: 12px; color: #e4e4e7; }
        .guide-icon { font-size: 16px; width: 20px; text-align: center; flex-shrink: 0; }
        .guide-item strong { color: var(--accent); display: block; margin-bottom: 2px; font-size: 11px; }
        .guide-item p { margin: 0; font-size: 10px; color: #a1a1aa; line-height: 1.3; }
        
        /* Visual Wave Examples */
        .wave-example {
            height: 35px; width: 100%; background: #000; border: 1px solid #333;
            margin-top: 4px; border-radius: 4px; position: relative; overflow: hidden;
            display: flex; align-items: center; justify-content: center;
        }
        .wave-svg { width: 100%; height: 100%; display: block; }
        
        .modal-close-btn {
            width: 100%; padding: 8px; background: var(--accent); color: white;
            border: none; border-radius: 4px; font-weight: bold; cursor: pointer;
            margin-top: 5px; font-size: 10px; text-transform: uppercase;
        }

        /* MOBILE RESPONSIVE */
        @media (max-width: 768px) {
            header { height: 60px; /* Increased height to accommodate new author link */ padding: 0 8px; }
            h1 { font-size: 11px; margin-left: 40px; }
            .author-link { margin-left: 40px; }
            .logo-img { top: 16px; /* Adjust position for new header height */ }

            #main-layout { display: block; position: relative; height: calc(100vh - 60px); /* Adjusted height, no footer */ }
            #viewport { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
            #controles {
                position: absolute; bottom: 0; left: 0; width: 100%; 
                height: auto; /* Allow height to adjust to content */
                max-height: min(45vh, 300px); /* Limit height to 45% of viewport or 300px, whichever is smaller */
                overflow-y: auto; /* Enable scrolling for controls if content exceeds max-height */
                box-sizing: border-box; border-right: none; border-top: 1px solid var(--border);
                z-index: 20; background: rgba(8, 8, 10, 0.95); padding-bottom: 20px;
                transition: none;
            }
            .hud-panel { top: 5px; left: 5px; width: 110px; padding: 6px; }
        }
    </style>
<link rel="stylesheet" href="/index.css">
</head>
<body>

    <header>
        <div class="brand-area">
            <a href="https://www.instagram.com/3d_mc_3d/" target="_blank" title="Visitar Instagram de MC" class="brand-link">
                <img src="https://raw.githubusercontent.com/MauroCasarin/SONIDO/refs/heads/main/MC%2048%20N.png" alt="MC Logo" class="logo-img">
            </a>
            <h1 id="main-title">Simulador Educativo de Sonidos Graves</h1>
            <!-- Relocated footer content -->
            <a href="https://www.instagram.com/3d_mc_3d/" target="_blank" class="author-link">
                <svg class="author-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2-6.782-2.618-6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zM12 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zM12 16c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/></svg>
                <span>Creado por Mauro Casarin</span>
            </a>
        </div>
    </header>

    <div id="tooltip" class="custom-tooltip"></div>

    <div id="modal-guide" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-title">Guía de Interpretación Técnica</h3>
            
            <div style="color: #a1a1aa; font-size: 11px; line-height: 1.4;">
                <p style="margin-bottom: 8px; color: var(--text-main);">
                    Esta guía esencial te ofrece una visión clara de cómo interpretar y optimizar el sonido grave en nuestro simulador.
                </p>

                <p style="margin-bottom: 4px; color: var(--text-main);"><b>1. Osciloscopio (Feedback Dinámico):</b></p>
                <ul style="padding-left: 20px; margin-top: 4px; margin-bottom: 12px;">
                    <li><strong style="color:#ffd700">DORADO:</strong> Alineación de fase óptima (&lt;10°), máxima suma de energía. Sonido potente y claro.</li>
                    <li><strong style="color:#ef4444">ROJO (CANCELACIÓN):</strong> Fases desalineadas, reducción drástica del sonido. Genera "agujeros" o falta de impacto.</li>
                    <li><strong style="color:#00ff00">VERDE (SUMA NORMAL):</strong> Combinación constructiva/destructiva moderada, sonido perceptible y coherente.</li>
                    <li><strong style="color:#52525b">GRIS (NO SONIDO):</strong> Baja emisión o cancelación casi total.</li>
                    <li>"Coh" (Coherencia): % de alineación de fases entre fuentes. Un valor alto es clave para la calidad.</li>
                </ul>

                <p style="margin-bottom: 4px; color: var(--text-main);"><b>2. Direccionalidad de Bafles (Cardioide):</b></p>
                <p style="margin-top: 4:px; margin-bottom: 12px;">
                    Los bafles simulan un patrón cardioide: emiten hacia el frente y minimizan la energía hacia atrás, reduciendo el sonido no deseado en el escenario.
                </p>

                <p style="margin-bottom: 4px; color: var(--text-main);"><b>3. Mapa de Calor (SPL Relativo):</b></p>
                <p style="margin-top: 4px; margin-bottom: 12px;">
                    Visualiza niveles de presión sonora (SPL) de forma *relativa*. Colores cálidos = mayor presión; fríos = menor presión/cancelación. Ayuda a identificar patrones de cobertura (los dB son de referencia visual).
                </p>

                <p style="margin-bottom: 4px; color: var(--text-main);"><b>4. Rangos de Frecuencias Graves:</b></p>
                <ul style="padding-left: 20px; margin-top: 4px; margin-bottom: 12px;">
                    <li><strong style="color:var(--gold)">SUB GRAVES (20 – 60 Hz):</strong> Frecuencias sentidas (físicas) más que oídas. Generan potencia y "presión en el pecho". Cruciales para el impacto. Muy largas longitudes de onda, complejas de controlar.</li>
                    <li><strong style="color:var(--accent)">GRAVES (61 – 250 Hz):</strong> Base rítmica (bombo, bajo), aportan "calor", "grosor" y "punch". Vital su control para evitar el "barro" y mantener la claridad.</li>
                </ul>
            </div>

            <button class="modal-close-btn" onclick="app.toggleGuide()">Cerrar</button>
        </div>
    </div>

    <div id="main-layout">
        
        <div id="viewport">
            <canvas id="simCanvas" width="800" height="600" data-tooltip="Visor de Predicción: Colores cálidos = mayor presión sonora. Arrastra bafles para ajustar distancia/delay."></canvas>
            
            <div id="hud-panel" class="hud-panel">
                <div class="hud-row"><span class="hud-label">Longitud Onda:</span><span class="hud-value" id="hud-lambda">--</span></div>
                <div class="hud-row"><span class="hud-label">Estado:</span><span class="hud-value" id="hud-status">--</span></div>
                <div class="hud-row" id="row-delay"><span class="hud-label">Delay E.F.:</span><span class="hud-value" id="hud-delay" style="color:var(--warning)">--</span></div>
            </div>
        </div>

        <div id="controles">
            <!-- Top Controls -->
            <div class="controls-top-bar">
                <button id="btn-play" class="vp-btn paused" onclick="app.togglePlay()" title="Play/Pausa">▶</button>
                <button class="btn-help-main" onclick="app.toggleGuide()" title="Guía Técnica">?</button>
            </div>

            <!-- Global Params -->
            <div class="control-group">
                <div class="group-title" id="freq-group-title">FUENTE (SUBGRAVES)</div>
                <div class="slider-row" data-tooltip="<strong>FRECUENCIA</strong><br>Define la longitud de onda. 80Hz es ideal para subgraves estándar.">
                    <div class="slider-label"><span>Freq</span><span class="slider-val" id="disp-freq">80 Hz</span></div>
                    <input type="range" id="input-freq" min="20" max="250" value="80">
                </div>
                <div class="slider-row" id="row-count" data-tooltip="<strong>CANTIDAD</strong><br>Número total de bafles por arreglo (Max 8).">
                    <div class="slider-label"><span>Bafles (N)</span><span class="slider-val" id="disp-count">2</span></div>
                    <input type="range" id="input-count" min="1" max="8" step="1" value="2">
                </div>
                <div style="font-size:9px; color:#555; margin-bottom:4px;">* Patrón Cardioide: (1 + cosθ)/2</div>

                <div class="slider-row" id="row-dist" data-tooltip="<strong>SEPARACIÓN FÍSICA</strong><br>Distancia entre centros acústicos. Arrastra los bafles para cambiar.">
                    <div class="slider-label"><span>Separación</span><span class="slider-val" id="disp-dist">1.07 m</span></div>
                    <input type="range" id="input-dist" min="0.2" max="4.0" step="0.01" value="1.07">
                    <div class="btn-row" style="margin-top:2px;">
                        <button class="small-btn" style="flex:1" onclick="app.setLambdaFraction(0.25)" data-tooltip="<strong>PRESET λ/4</strong><br>Suma perfecta frontal (+6dB).">λ/4 (Max)</button>
                        <button class="small-btn" style="flex:1" onclick="app.setLambdaFraction(0.5)" data-tooltip="<strong>PRESET λ/2</strong><br>Máxima cancelación lateral.">λ/2 (Dir)</button>
                    </div>
                </div>
            </div>

            <!-- Configuration -->
            <div class="control-group">
                <div class="group-title">CONFIGURACIÓN</div>
                <div class="btn-row">
                    <button id="btn-broad" class="active" style="flex:1" onclick="app.setMode('broadside')" data-tooltip="<strong>BROADSIDE</strong><br>Línea de fuentes. Cobertura ancha.">BROADSIDE</button>
                    <button id="btn-end" style="flex:1" onclick="app.setMode('endfire')" data-tooltip="<strong>END-FIRE</strong><br>Fuentes en línea de tiro. Rechazo trasero.">END-FIRE</button>
                </div>
                <button id="btn-lr" style="width:100%; margin-top:4px;" onclick="app.toggleLR()" data-tooltip="<strong>L/R STEREO</strong><br>Divide el arreglo en dos clusters (Izquierda/Derecha) espejados.">MODO: MONO CENTRAL</button>
                <div class="slider-row" style="margin-top:4px" data-tooltip="<strong>SEPARACIÓN L/R</strong><br>Distancia desde el centro (0m = Pegados).">
                    <div class="slider-label"><span>Margen L/R</span><span class="slider-val" id="disp-lat-margin">0.5 m</span></div>
                    <input type="range" id="input-lat-margin" min="0" max="5.0" step="0.1" value="0.5">
                </div>
            </div>

            <!-- Optimization -->
            <div class="control-group">
                <div class="group-title">MIC & OPTIMIZACIÓN</div>
                <div style="display:flex; gap:4px;">
                    <button class="magic" style="width:100%; padding:6px;" onclick="app.autoOptimize()" data-tooltip="<strong>AUTO-FOCUS</strong><br>Alinea tiempos y fases para el micrófono.">✨ FOCUS</button>
                </div>
                <div id="opt-status" style="display:none; text-align:center; color:#a3e635; font-size:9px; margin-top:2px; font-weight:bold;">OPTIMIZADO</div>
            </div>

            <!-- Baffle Control (Polarity & Direction) -->
            <div class="control-group">
                <div class="group-title">CONTROLES POR BAFLE (DELAY BIDIRECCIONAL)</div>
                <div id="baffle-control-list" class="baffle-list">
                    <!-- JS generated rows -->
                </div>
            </div>

            <!-- New Reset Section -->
            <div class="control-group">
                <div class="group-title">ACCIONES</div>
                <button id="btn-reset" class="red-magic" style="width:100%; padding:8px;">RESETEAR TODO</button>
                <button id="btn-fullscreen" class="magic" style="width:100%; padding:8px; margin-top: 4px;">FULLSCREEN</button>
            </div>
        </div>

    </div>

    <script>
        window.app = {
            togglePlay: () => {}, toggleGuide: () => {}, setMode: () => {}, 
            toggleLR: () => {}, togglePolarity: () => {}, toggleDirection: () => {},
            setLambdaFraction: () => {}, autoOptimize: () => {}, setDelay: () => {},
            resetSimulator: () => {}, toggleFullscreen: () => {}
        };
        window.idx = 0; // Estabilidad requerida

        window.onload = function() {
            
            const SPEED_OF_SOUND = 344;

            const state = {
                freq: 80, dist: 1.07, count: 2, angle: 90,
                mode: 'broadside', lrMode: false,     
                lateralMargin: 0.5,
                polarities: new Array(16).fill(false),
                directions: new Array(16).fill(false), // false = Up, true = Down
                delays: new Array(16).fill(0), // ms
                isOptimized: false, isCardioidMode: false,
                customPhases: [],   
                sourceDelays: [], 
                viewGain: 1.0, isGuideOpen: false, 
                isPlaying: false, 
                time: 0,
                view: { scale: 45, x: 0, y: -50, dragging: false, lastX: 0, lastY: 0, dragType: null, dragIndex: -1, lastPinchDist: 0 }, // Increased zoom, shifted up
                mic: { x: 0, y: -3 }, // Mic at 3 meters
                hasTooltipBeenShown: false, // New state property for global one-time tooltip
                doubleTapTimeout: null, // For mobile double-tap detection
                lastTapTime: 0,
                lastTapLocation: { clientX: 0, clientY: 0 }, // Store clientX/Y for robustness
            };

            const els = {
                canvas: document.getElementById('simCanvas'),
                controls: document.getElementById('controles'),
                hudPanel: document.getElementById('hud-panel'),
                tooltip: document.getElementById('tooltip'), // Tooltip element
                inputs: {
                    freq: document.getElementById('input-freq'), dist: document.getElementById('input-dist'),
                    count: document.getElementById('input-count'), angle: document.getElementById('input-angle'),
                    latMargin: document.getElementById('input-lat-margin'),
                },
                displays: {
                    freq: document.getElementById('disp-freq'), dist: document.getElementById('disp-dist'),
                    count: document.getElementById('disp-count'), angle: document.getElementById('disp-angle'),
                    latMargin: document.getElementById('disp-lat-margin'),
                },
                rows: { dist: document.getElementById('row-dist') },
                hud: {
                    lambda: document.getElementById('hud-lambda'), status: document.getElementById('hud-status'),
                    delay: document.getElementById('hud-delay'), delayRow: document.getElementById('row-delay')
                },
                btns: {
                    broad: document.getElementById('btn-broad'), end: document.getElementById('btn-end'),
                    lr: document.getElementById('btn-lr'), play: document.getElementById('btn-play'),
                },
                baffleList: document.getElementById('baffle-control-list'),
                optStatus: document.getElementById('opt-status'),
                modalGuide: document.getElementById('modal-guide'),
                freqGroupTitle: document.getElementById('freq-group-title'), // New element reference for dynamic title
                reset: document.getElementById('btn-reset'), // Reference to the new reset button
                fullscreen: document.getElementById('btn-fullscreen'), // Reference to the new fullscreen button
            };

            const ctx = els.canvas.getContext('2d', { alpha: false });
            ctx.imageSmoothingEnabled = true;

            let valueEnlargeTimeouts = {}; // Object to hold timeouts for each display element
            
            function animateValueEnlarge(displayElementId) {
                const displayEl = document.getElementById(displayElementId);
                if (!displayEl) return;

                // Clear any existing timeout for this element
                if (valueEnlargeTimeouts[displayElementId]) {
                    clearTimeout(valueEnlargeTimeouts[displayElementId]);
                }

                // Add enlarged class
                displayEl.classList.add('enlarged-value');

                // Set a timeout to remove the class after a short delay
                valueEnlargeTimeouts[displayElementId] = setTimeout(() => {
                    displayEl.classList.remove('enlarged-value');
                    delete valueEnlargeTimeouts[displayElementId]; // Clean up the timeout reference
                }, 500); // Enlarge for 0.5 seconds
            }

            // TOOLTIP LOGIC START (Revised)
            let activeTooltipTimeout = null;

            function showGlobalTooltip(element) {
                if (state.hasTooltipBeenShown) {
                    return; // Don't show if already shown globally
                }

                const tooltipContent = element.getAttribute('data-tooltip');
                if (!tooltipContent || !els.tooltip) return;

                // Clear any existing timeout before showing a new tooltip
                if (activeTooltipTimeout) {
                    clearTimeout(activeTooltipTimeout);
                }
                
                els.tooltip.innerHTML = tooltipContent;
                els.tooltip.classList.add('visible');
                
                state.hasTooltipBeenShown = true; // Mark as shown globally

                activeTooltipTimeout = setTimeout(() => {
                    els.tooltip.classList.remove('visible');
                    activeTooltipTimeout = null;
                }, 2000); // Disappear after 2 seconds
            }

            // Centralized click/tap handler for tooltips on the controls sidebar
            // This replaces mouseover/mouseout/mousemove for tooltip activation.
            els.controls.addEventListener('click', (e) => {
                let target = e.target;
                // Traverse up the DOM from the clicked element to the controls container
                while (target && target !== els.controls) {
                    if (target.hasAttribute('data-tooltip')) {
                        showGlobalTooltip(target);
                        return; // Found an element with tooltip, show it and stop
                    }
                    target = target.parentElement;
                }
            });

            // For mobile touch devices, touchend can also trigger interaction
            els.controls.addEventListener('touchend', (e) => {
                let target = e.target;
                while (target && target !== els.controls) {
                    if (target.hasAttribute('data-tooltip')) {
                        showGlobalTooltip(target);
                        return;
                    }
                    target = target.parentElement;
                }
            });
            // TOOLTIP LOGIC END (Revised)


            // Global Methods
            window.app.setMode = (m) => {
                state.mode = m; state.isOptimized = false; state.isCardioidMode = false; resetGain();
                els.optStatus.style.display = 'none';
                els.btns.broad.className = m === 'broadside' ? 'active' : '';
                els.btns.end.className = m === 'endfire' ? 'active' : '';
                updateUI(); 
            };
            window.app.toggleLR = () => {
                state.lrMode = !state.lrMode; state.isOptimized = false; state.isCardioidMode = false; resetGain();
                els.optStatus.style.display = 'none';
                els.btns.lr.innerText = state.lrMode ? "MODO: STEREO L/R" : "MODO: MONO CENTRAL";
                els.btns.lr.className = state.lrMode ? 'active' : '';
                updateUI(); 
            };
            window.app.togglePolarity = (i) => {
                state.polarities[i] = !state.polarities[i];
                renderBaffleGrid(); 
            };
            window.app.toggleDirection = (i) => {
                state.directions[i] = !state.directions[i];
                renderBaffleGrid();
            };
            window.app.setDelay = (i, val) => {
                state.delays[i] = parseFloat(val);
                state.isOptimized = false; 
                const labelId = 'val-delay-'+i;
                const label = document.getElementById(labelId);
                if(label) label.innerText = state.delays[i].toFixed(2) + ' ms';
                animateValueEnlarge(labelId); // Animate delay value
                updateUI(true); 
            };
            window.app.togglePlay = () => {
                state.isPlaying = !state.isPlaying;
                els.btns.play.innerHTML = state.isPlaying ? '❚❚' : '▶';
                els.btns.play.className = state.isPlaying ? 'vp-btn' : 'vp-btn paused';
            };
            window.app.toggleGuide = () => {
                state.isGuideOpen = !state.isGuideOpen;
                els.modalGuide.classList.toggle('open', state.isGuideOpen);
            };
            window.app.setLambdaFraction = (frac) => {
                const c = SPEED_OF_SOUND;
                let optimal = (c / state.freq) * frac;
                optimal = Math.min(4.0, Math.max(0.2, optimal));
                state.dist = optimal; els.inputs.dist.value = optimal;
                animateValueEnlarge('disp-dist'); // Animate distance value
                updateUI(); 
            };

            // FOCUS (AutoOptimize) - Lógica de Alineación al Micrófono
            window.app.autoOptimize = () => {
                const c = SPEED_OF_SOUND;
                
                // Generar fuentes actuales
                let sources = generateSourcesForLogic();
                // Calcular distancia de cada fuente al microfono
                const dists = sources.map(s => Math.hypot(state.mic.x - s.x, state.mic.y - s.y));
                const maxDist = Math.max(...dists);

                // Aplicar delay para alinear: delay = (maxDist - dist) / c
                for(let i=0; i<state.count; i++) {
                    if (dists[i] !== undefined) {
                        state.delays[i] = ((maxDist - dists[i]) / c) * 1000;
                        state.polarities[i] = false; 
                        state.directions[i] = false; 
                    }
                }

                state.isOptimized = true; state.isCardioidMode = false;
                els.optStatus.style.display = 'block';
                els.optStatus.innerHTML = 'OPTIMIZADO (FOCUS)';
                resetGain(); updateUI(); 
            };

            window.app.resetSimulator = () => {
                // Reset all state variables to their initial defaults
                state.freq = 80;
                state.dist = 1.07;
                state.count = 2;
                state.angle = 90; 
                state.mode = 'broadside';
                state.lrMode = false;
                state.lateralMargin = 0.5;
                state.polarities = new Array(16).fill(false); // Reset all polarities
                state.directions = new Array(16).fill(false); // Reset all directions
                state.delays = new Array(16).fill(0); // Reset all delays
                state.isOptimized = false;
                state.isCardioidMode = false; 
                state.viewGain = 1.0;
                state.isGuideOpen = false; // Ensure guide is closed
                state.isPlaying = false; // Stop playback
                state.time = 0; // Reset animation time
                state.view = { scale: 45, x: 0, y: -50, dragging: false, lastX: 0, lastY: 0, dragType: null, dragIndex: -1, lastPinchDist: 0 }; // Reset view
                state.mic = { x: 0, y: -3 }; // Reset mic position
                state.hasTooltipBeenShown = false; // Reset tooltip flag

                // Clear any active tooltip
                if (activeTooltipTimeout) { 
                    clearTimeout(activeTooltipTimeout);
                    els.tooltip.classList.remove('visible');
                    activeTooltipTimeout = null;
                }

                // Update UI input elements to reflect reset state
                els.inputs.freq.value = state.freq;
                els.inputs.dist.value = state.dist;
                els.inputs.count.value = state.count;
                els.inputs.latMargin.value = state.lateralMargin;

                // Update UI button states
                els.optStatus.style.display = 'none'; 
                els.btns.broad.className = 'active'; 
                els.btns.end.className = '';
                els.btns.lr.innerText = "MODO: MONO CENTRAL";
                els.btns.lr.className = '';
                els.btns.play.innerHTML = '▶'; 
                els.btns.play.className = 'vp-btn paused';

                // Ensure guide modal is closed visually
                if (els.modalGuide.classList.contains('open')) {
                    els.modalGuide.classList.remove('open');
                }

                // Call updateUI to refresh all display values and baffle grid
                updateUI(); 
            };

            // Fullscreen toggle
            window.app.toggleFullscreen = () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        console.error(`Error attempting to enable fullscreen: ${err.message} (${err.name})`);
                    });
                } else {
                    document.exitFullscreen();
                }
            };


            function resetGain() { state.viewGain = 1.0; }

            // No longer checking isMobile() to hide controls, they stay visible.
            // The isMobile() function is still useful for other mobile-specific logic (e.g., double-tap thresholds).
            function isMobile() {
                return window.innerWidth <= 768; // Matches CSS media query breakpoint
            }

            function getPointerPos(e) {
                const rect = els.canvas.getBoundingClientRect();
                let clientX, clientY;
                if (e.changedTouches && e.changedTouches.length > 0) {
                    clientX = e.changedTouches[0].clientX; 
                    clientY = e.changedTouches[0].clientY;
                } else {
                    clientX = e.clientX; 
                    clientY = e.clientY;
                }
                return { x: clientX - rect.left, y: clientY - rect.top, clientX: clientX, clientY: clientY };
            }

            function setControlsDimmed() { els.controls.classList.add('controls-dimmed'); }
            function removeControlsDimmed() { els.controls.classList.remove('controls-dimmed'); }

            Object.keys(els.inputs).forEach(key => {
                if(!els.inputs[key]) return;
                const input = els.inputs[key];
                input.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    if (key === 'latMargin') state.lateralMargin = val;
                    else state[key] = val;
                    
                    if (['freq', 'dist', 'latMargin', 'count', 'angle'].includes(key)) {
                         if(state.isOptimized) { 
                             state.isOptimized = false; els.optStatus.style.display = 'none'; resetGain(); 
                         }
                         if(key === 'count') resetGain();
                    }

                    // Animate value display for the current slider
                    if (key === 'freq') animateValueEnlarge('disp-freq');
                    else if (key === 'count') animateValueEnlarge('disp-count');
                    else if (key === 'dist') animateValueEnlarge('disp-dist');
                    else if (key === 'latMargin') animateValueEnlarge('disp-lat-margin');

                    // Update frequency group title on input as well
                    let groupTitleText = 'FUENTE';
                    if (state.freq >= 20 && state.freq <= 60) {
                        groupTitleText += ' (SUB GRAVES)';
                    } else if (state.freq > 60 && state.freq <= 250) {
                        groupTitleText += ' (GRAVES)';
                    }
                    els.freqGroupTitle.innerText = groupTitleText;

                    updateUI(); 
                });
            });

            // Helper function to calculate the horizontal center of the baffle array in world coordinates
            function calculateBaffleCenterWorldX() {
                let baffleCenterWorldX = 0; 
                const sources = generateSourcesForLogic(); // Get the current baffle positions

                if (sources.length > 0) {
                    if (state.lrMode) {
                        // In L/R stereo mode, the overall array center is at x=0 (midpoint between -lateralMargin and +lateralMargin)
                        baffleCenterWorldX = 0; 
                    } else if (state.mode === 'broadside') {
                        // For broadside, find the center of the first (and only) cluster
                        const firstBaffleX = sources[0].x;
                        const lastBaffleX = sources[state.count - 1].x; // Assuming sources array is ordered by x
                        baffleCenterWorldX = (firstBaffleX + lastBaffleX) / 2;
                    } else if (state.mode === 'endfire') {
                        // For endfire, all baffles in a single cluster have the same X-coordinate
                        baffleCenterWorldX = sources[0].x;
                    }
                }
                return baffleCenterWorldX;
            }

            // Handler for double-click/double-tap on microphone to center it between baffles
            const handleMicCenterBetweenBaffles = () => {
                const baffleCenterWorldX = calculateBaffleCenterWorldX();
                
                state.mic.x = baffleCenterWorldX; // ONLY move microphone horizontally to baffle array center
                // state.view.x = -state.mic.x * ppm; // REMOVED: Do not change camera view
                // state.view.y = -state.mic.y * ppm; // REMOVED: Do not change camera view

                updateUI(); // Redraw with new mic position
            };


            // Double-click handler for desktop
            els.canvas.addEventListener('dblclick', (e) => {
                const pos = getPointerPos(e);
                const cx = els.canvas.width / 2 + state.view.x;
                const cy = els.canvas.height / 2 + state.view.y;
                const ppm = state.view.scale;
                const mx_screen = cx + state.mic.x * ppm;
                const my_screen = cy + state.mic.y * ppm;
                
                // Check if the double-click was approximately on the microphone icon
                if (Math.hypot(pos.x - mx_screen, pos.y - my_screen) < 50) { 
                    handleMicCenterBetweenBaffles();
                }
            });

            function handleStart(e) {
                // Multi-touch check for pinch optimization
                if(e.touches && e.touches.length === 2) {
                    e.preventDefault();
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    state.view.lastPinchDist = Math.hypot(dx, dy);
                    return;
                }

                // Removed mobile controls visibility toggling here. Controls now remain visible.

                // Prevent Scrolling on mobile when touching canvas
                // Only prevent default if the touch/click is NOT on an input/button and NOT within the controls sidebar
                if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'BUTTON' && !els.controls.contains(e.target)) {
                     e.preventDefault();
                }
                
                const pos = getPointerPos(e);
                const cx = els.canvas.width / 2 + state.view.x;
                const cy = els.canvas.height / 2 + state.view.y;
                const ppm = state.view.scale;
                const mx_screen = cx + state.mic.x * ppm;
                const my_screen = cy + state.mic.y * ppm;
                
                if (Math.hypot(pos.x - mx_screen, pos.y - my_screen) < 50) {
                    state.view.dragType = 'mic'; state.view.dragging = true;
                    setControlsDimmed();
                    state.view.lastX = pos.clientX; state.view.lastY = pos.clientY;
                    return;
                }

                let sources = generateSourcesForLogic();
                let closest = -1;
                let minD = 50; 
                sources.forEach((s, i) => {
                    const sx = cx + s.x * ppm;
                    const sy = cy + s.y * ppm;
                    const d = Math.hypot(pos.x - sx, pos.y - sy);
                    if(d < minD) { minD = d; closest = i; }
                });

                if (closest !== -1) {
                    state.view.dragType = 'baffle'; 
                    state.view.dragging = true;
                    state.view.dragIndex = closest;
                    setControlsDimmed();
                } else {
                    state.view.dragType = 'view'; state.view.dragging = true;
                    setControlsDimmed();
                }
                state.view.lastX = pos.clientX; state.view.lastY = pos.clientY;
            }

            function handleMove(e) {
                // Pinch Zoom Logic
                if(e.touches && e.touches.length === 2) {
                    e.preventDefault();
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const dist = Math.hypot(dx, dy);
                    if (state.view.lastPinchDist > 0) {
                        const delta = dist - state.view.lastPinchDist;
                        const factor = 1 + (delta * 0.005);
                        state.view.scale = Math.max(5, Math.min(100, state.view.scale * factor));
                    }
                    state.view.lastPinchDist = dist;
                    return;
                }

                if(state.view.dragging) {
                    e.preventDefault(); 
                    const pos = getPointerPos(e);
                    const dxPix = pos.clientX - state.view.lastX;
                    const dyPix = pos.clientY - state.view.lastY;
                    
                    if (state.view.dragType === 'view') { 
                        state.view.x += dxPix; state.view.y += dyPix; 
                    } else if (state.view.dragType === 'mic') {
                        state.mic.x += dxPix / state.view.scale; state.mic.y += dyPix / state.view.scale;
                        if (state.isOptimized) {
                            // Manual re-optimization required currently
                        }
                    } else if (state.view.dragType === 'baffle') {
                        const dM = -dyPix / state.view.scale;
                        if (Math.abs(dM) > 0) {
                            let newDist = state.dist + (dM * 0.5); 
                            newDist = Math.max(0.2, Math.min(4.0, newDist));
                            state.dist = newDist;
                            els.inputs.dist.value = newDist;
                            if (state.isOptimized) {
                                state.isOptimized = false; els.optStatus.style.display = 'none';
                            }
                            updateUI();
                            animateValueEnlarge('disp-dist'); // Animate distance value during drag
                        }
                    }
                    state.view.lastX = pos.clientX; state.view.lastY = pos.clientY;
                }
            }

            // Global touchend handler for resetting drag state
            function handleEnd(e) {
                state.view.dragging = false; 
                state.view.dragType = null;
                state.view.lastPinchDist = 0;
                removeControlsDimmed(); 
            }

            const DOUBLE_TAP_DELAY = 300; // milliseconds
            const DOUBLE_TAP_RADIUS = 20; // pixels

            // Custom touchend listener for double-tap on canvas, particularly for mic centering
            els.canvas.addEventListener('touchend', (e) => {
                const now = Date.now();
                const lastTap = state.lastTapTime;
                const currentTapPos = getPointerPos(e); 

                // Check for double-tap
                if (now - lastTap < DOUBLE_TAP_DELAY) {
                    const dist = Math.hypot(currentTapPos.clientX - state.lastTapLocation.clientX, currentTapPos.clientY - state.lastTapLocation.clientY);
                    if (dist < DOUBLE_TAP_RADIUS) {
                        // It's a double-tap
                        const cx = els.canvas.width / 2 + state.view.x;
                        const cy = els.canvas.height / 2 + state.view.y;
                        const ppm = state.view.scale;
                        const mx_screen = cx + state.mic.x * ppm;
                        const my_screen = cy + state.mic.y * ppm;

                        if (Math.hypot(currentTapPos.x - mx_screen, currentTapPos.y - my_screen) < 50) { // Check if double-tapped on mic
                            handleMicCenterBetweenBaffles();
                        }
                        state.lastTapTime = 0; // Reset double-tap detection
                        state.lastTapLocation = { clientX: 0, clientY: 0 };
                        return; // Consume event if double-tap was processed
                    }
                }
                state.lastTapTime = now;
                state.lastTapLocation = { clientX: currentTapPos.clientX, clientY: currentTapPos.clientY };
            }, {passive: false});


            els.canvas.addEventListener('mousedown', handleStart);
            window.addEventListener('mousemove', handleMove);
            window.addEventListener('mouseup', handleEnd); // This handles global mouseup to stop drags
            els.canvas.addEventListener('touchstart', handleStart, {passive: false});
            window.addEventListener('touchmove', handleMove, {passive: false});
            window.addEventListener('touchend', handleEnd); // This also calls handleEnd for touchend on canvas to stop drags

            els.canvas.addEventListener('wheel', e => {
                e.preventDefault();
                const factor = e.deltaY > 0 ? 0.9 : 1.1;
                state.view.scale = Math.max(5, Math.min(100, state.view.scale * factor));
            });
            window.addEventListener('resize', () => {
                els.canvas.width = els.canvas.parentElement.clientWidth;
                els.canvas.height = els.canvas.parentElement.clientHeight;
                // No need to explicitly manage controls visibility on resize, as they are always visible on mobile now.
            });

            function updateUI(skipBaffleRebuild = false) {
                els.displays.freq.innerText = state.freq + ' Hz';
                els.displays.dist.innerText = state.dist.toFixed(2) + ' m';
                els.displays.count.innerText = state.count;
                // els.displays.angle.innerText = state.angle + '°'; // Disabled
                els.displays.latMargin.innerText = state.lateralMargin.toFixed(1) + ' m';
                
                if (state.count === 1) els.rows.dist.classList.add('disabled');
                else els.rows.dist.classList.remove('disabled');
                
                const c = SPEED_OF_SOUND;
                const lambda = c / state.freq;
                els.hud.lambda.innerText = lambda.toFixed(2) + ' m';
                
                const limit = (2/3) * lambda; const optimal = lambda / 4; 
                if (state.dist > limit && state.count > 1) {
                    els.hud.status.innerText = "ALIASING"; els.hud.status.className = "hud-value status-danger";
                } else if (Math.abs(state.dist - optimal) < optimal * 0.15 && state.count > 1) {
                    els.hud.status.innerText = "OPTIMO λ/4"; els.hud.status.className = "hud-value status-ok";
                } else {
                    els.hud.status.innerText = state.count === 1 ? "PUNTUAL" : "ESTANDAR";
                    els.hud.status.className = "hud-value";
                }
                
                if (state.mode === 'endfire' && state.count > 1) {
                    const delay = (state.dist / c) * 1000;
                    els.hud.delayRow.style.display = 'flex'; els.hud.delay.innerText = delay.toFixed(2) + ' ms';
                } else els.hud.delayRow.style.display = 'none';

                // Update frequency group title on UI refresh as well
                let groupTitleText = 'FUENTE';
                if (state.freq >= 20 && state.freq <= 60) {
                    groupTitleText += ' (SUB GRAVES)';
                } else if (state.freq > 60 && state.freq <= 250) {
                    groupTitleText += ' (GRAVES)';
                }
                els.freqGroupTitle.innerText = groupTitleText;

                renderBaffleGrid(skipBaffleRebuild);
            }

            function renderBaffleGrid(skipRebuild) {
                const container = els.baffleList;
                if (container.children.length !== state.count || !skipRebuild) { // rebuild if count changes or not skipping
                    container.innerHTML = '';
                    for(let i=0; i<state.count; i++) {
                        const row = document.createElement('div');
                        row.className = 'baffle-row';
                        row.id = 'baffle-row-' + i;
                        row.innerHTML = `
                            <div class="baffle-info"><div class="baffle-num">${i+1}</div></div>
                            <div class="baffle-controls">
                                <button id="btn-pol-${i}" class="baffle-btn" onclick="app.togglePolarity(${i})" data-tooltip="<strong>POLARIDAD</strong><br>Invierte la fase (180°) del bafle.">Ø</button>
                                <button id="btn-dir-${i}" class="baffle-btn" onclick="app.toggleDirection(${i})" data-tooltip="<strong>DIRECCIÓN</strong><br>Invierte la orientación del patrón cardioide (180°).">⟲</button>
                            </div>
                            <div class="delay-slider-container">
                                 <input id="slider-delay-${i}" type="range" min="0" max="50" step="0.01" value="0" oninput="app.setDelay(${i}, this.value)">
                                 <div id="val-delay-${i}" class="delay-val">0.00 ms</div>
                            </div>`;
                        container.appendChild(row);
                    }
                }

                for(let i=0; i<state.count; i++) {
                    const inv = state.polarities[i];
                    const dirDown = state.directions[i];
                    const delay = state.delays[i] || 0;
                    const btnPol = document.getElementById(`btn-pol-${i}`);
                    const btnDir = document.getElementById(`btn-dir-${i}`);
                    const slider = document.getElementById(`slider-delay-${i}`);
                    const label = document.getElementById(`val-delay-${i}`);
                    if(btnPol) btnPol.className = `baffle-btn ${inv ? 'active' : ''}`;
                    if(btnDir) btnDir.className = `baffle-btn ${dirDown ? 'dir-active' : ''}`;
                    if(label) label.innerText = delay.toFixed(2) + ' ms';
                    if (slider && document.activeElement !== slider) slider.value = delay.toFixed(2);
                }
            }

            function generateSourcesForLogic() {
                const srcY = 0; const sources = []; let xOffsets = [0];
                if (state.lrMode) xOffsets = [-state.lateralMargin, state.lateralMargin];
                xOffsets.forEach(xOff => {
                    if (state.mode === 'broadside') {
                        for(let i=0; i<state.count; i++) {
                            const totalW = (state.count - 1) * state.dist;
                            const xPos = xOff - totalW/2 + (i * state.dist);
                            sources.push({ x: xPos, y: srcY, inv: state.polarities[i], dirDown: state.directions[i], delay: state.delays[i] || 0 });
                        }
                    } else {
                        for(let i=0; i<state.count; i++) {
                            const yPos = srcY - (i * state.dist);
                            sources.push({ x: xOff, y: yPos, inv: state.polarities[i], dirDown: state.directions[i], delay: state.delays[i] || 0 });
                        }
                    }
                });
                return sources;
            }

            function fillHeatmapColor(db, data, idx) {
                let r=0, g=0, b=0, a=230;
                // Escala Estándar (Audio Pro): White > Yellow > Orange > Red > Blue > Black
                if (db > 0) { 
                    // +0dB: White/Yellow
                    r = 255; g = 255; b = Math.min(255, Math.floor(db * 40)); 
                } else if (db > -3) {
                    // 0 to -3dB: Yellow to Orange
                    r = 255; g = Math.floor(160 + ((db+3)/3)*95); b = 0;
                } else if (db > -6) {
                    // -3 to -6dB: Orange to Red
                    r = 255; g = Math.floor(((db+6)/3)*160); b = 0;
                } else if (db > -12) { 
                    // -12 to -24dB: Red to Dark Red
                    r = Math.floor(100 + ((db+12)/6)*155); g = 0; b = 0;
                } else if (db > -24) { 
                    // -12 to -24dB: Red to Blue
                    // This is a transition zone, usually goes black or blue. Let's go Blue.
                    const t = (db + 24) / 12;
                    r = Math.floor(t * 100); g = 0; b = Math.floor((1-t) * 200);
                } else if (db > -60) { 
                    // Deep Blue fading to black
                    const t = (db + 60) / 36; 
                    r = 0; g = 0; b = Math.floor(t * 200); a = Math.floor(t * 230); 
                } else { 
                    r=0; g=0; b=0; a=0; 
                }
                data[idx] = r; data[idx+1] = g; data[idx+2] = b; data[idx+3] = a;
            }

            function drawRulers(w, h, cx, cy, ppm) {
                const rulerColor = 'rgba(255,255,255,0.4)';
                const subTickColor = 'rgba(255,255,255,0.2)';
                const textColor = '#a1a1aa';
                
                ctx.save();
                ctx.fillStyle = textColor;
                ctx.font = '9px monospace';
                ctx.lineWidth = 1;

                // Rango visible en metros
                const minX_m = Math.floor((-cx) / ppm);
                const maxX_m = Math.ceil((w - cx) / ppm);
                const minY_m = Math.floor((-cy) / ppm);
                const maxY_m = Math.ceil((h - cy) / ppm);

                // Eje X (Abajo)
                const rulerY = h - 20;
                ctx.strokeStyle = rulerColor;
                ctx.beginPath(); ctx.moveTo(0, rulerY); ctx.lineTo(w, rulerY); ctx.stroke();

                for (let m = minX_m; m <= maxX_m; m++) {
                    const x = cx + m * ppm;
                    if (x < 0 || x > w) continue;
                    // Tick Metro
                    ctx.strokeStyle = rulerColor;
                    ctx.beginPath(); ctx.moveTo(x, rulerY); ctx.lineTo(x, rulerY + 8); ctx.stroke();
                    ctx.fillText(m + "m", x + 3, rulerY + 14);
                    
                    // Sub-ticks 10cm
                    ctx.strokeStyle = subTickColor;
                    for(let sm=1; sm<10; sm++) {
                        const sx = x + (sm * 0.1 * ppm);
                        if (sx > w) break;
                        ctx.beginPath(); ctx.moveTo(sx, rulerY); ctx.lineTo(sx, rulerY + 3); ctx.stroke();
                    }
                }

                // Eje Y (Izquierda)
                const rulerX = 30; // Margen para numeros
                ctx.strokeStyle = rulerColor;
                ctx.beginPath(); ctx.moveTo(rulerX, 0); ctx.lineTo(rulerX, h); ctx.stroke();

                for (let m = minY_m; m <= maxY_m; m++) {
                    const y = cy + m * ppm;
                    if (y < 0 || y > h) continue;
                    // Tick Metro
                    ctx.strokeStyle = rulerColor;
                    ctx.beginPath(); ctx.moveTo(rulerX - 8, y); ctx.lineTo(rulerX, y); ctx.stroke();
                    ctx.fillText((-m) + "m", 2, y + 3);
                    
                    // Sub-ticks 10cm
                    ctx.strokeStyle = subTickColor;
                    for(let sm=1; sm<10; sm++) {
                        const sy = y + (sm * 0.1 * ppm);
                        if (sy > h) break;
                        ctx.beginPath(); ctx.moveTo(rulerX - 3, sy); ctx.lineTo(rulerX, sy); ctx.stroke();
                    }
                }

                ctx.restore();
            }


            function draw() {
                const w = els.canvas.width; const h = els.canvas.height; if(w === 0 || h === 0) return;
                const cx = w/2 + state.view.x; const cy = h/2 + state.view.y; const ppm = state.view.scale;
                const c = SPEED_OF_SOUND; const k = (2 * Math.PI * state.freq) / c; const timePhase = state.time * 0.5;
                
                ctx.fillStyle = '#09090b'; ctx.fillRect(0,0,w,h);
                
                // Grid suave de fondo
                ctx.save(); ctx.beginPath(); ctx.strokeStyle = '#222'; ctx.lineWidth = 1;
                const startX = Math.floor((-cx)/ppm); const endX = Math.ceil((w-cx)/ppm);
                const startY = Math.floor((-cy)/ppm); const endY = Math.ceil((h-cy)/ppm);
                for(let gx=startX; gx<=endX; gx++) { const sx = cx + gx*ppm; ctx.moveTo(sx, 0); ctx.lineTo(sx, h); }
                for(let gy=startY; gy<=endY; gy++) { const sy = cy + gy*ppm; ctx.moveTo(0, sy); ctx.lineTo(0, sy); }
                ctx.stroke(); ctx.restore();

                let sources = generateSourcesForLogic();
                sources.forEach(s => { s.phase = -(2 * Math.PI * state.freq) * (s.delay / 1000); });
                
                const gain = state.viewGain;
                
                // Prepare virtual sources (no reflections)
                const simSources = sources.map(s => ({
                    sx: cx + s.x * ppm, sy: cy + s.y * ppm, phase: s.phase,
                    inv: s.inv, dirDown: s.dirDown, x: s.x, y: s.y, delay: s.delay, isRef: false
                }));

                const imgData = ctx.getImageData(0, 0, w, h); const data = imgData.data;

                if (state.isPlaying) {
                    // MODO ANIMADO (ONDA VIAJERA)
                    for(let y=0; y<h; y++) {
                        const rowOff = y * w * 4;
                        for(let x=0; x<w; x++) {
                            const idx = rowOff + (x * 4); let pSum = 0;
                            
                            for(let i=0; i<simSources.length; i++) {
                                const s = simSources[i]; 
                                const dx = x - s.sx; const dy = y - s.sy; 
                                const dist = Math.sqrt(dx*dx + dy*dy); 
                                const distMeters = dist / ppm; 
                                const dClamped = Math.max(0.1, distMeters);
                                
                                let ampD = (1.0 / dClamped);
                                
                                const cosTheta = dist > 0 ? (s.dirDown ? (dy / dist) : (-dy / dist)) : 1.0;
                                const directivity = (1.0 + cosTheta) / 2.0;
                                
                                if (s.isRef) ampD *= 0.6; // Should not happen now

                                pSum += ampD * directivity * Math.sin((k * distMeters) - timePhase - s.phase + (s.inv ? Math.PI : 0));
                            }
                            const db = 20 * Math.log10(Math.abs(pSum) * gain + 1e-7);
                            fillHeatmapColor(db, data, idx);
                        }
                    }
                } else {
                    // MODO PREDICCIÓN ESTÁTICA (SPL)
                    for(let y=0; y<h; y++) {
                        const rowOff = y * w * 4;
                        for(let x=0; x<w; x++) {
                            const idx = rowOff + (x * 4); 
                            let pSumReal = 0;
                            let pSumImag = 0;
                            
                            for(let i=0; i<simSources.length; i++) {
                                const s = simSources[i]; 
                                const dx = x - s.sx; const dy = y - s.sy; 
                                const dist = Math.sqrt(dx*dx + dy*dy);
                                const distMeters = dist / ppm; 
                                const dClamped = Math.max(0.1, distMeters);
                                
                                let ampD = (1.0 / dClamped);
                                
                                const cosTheta = dist > 0 ? (s.dirDown ? (dy / dist) : (-dy / dist)) : 1.0;
                                const directivity = (1.0 + cosTheta) / 2.0;

                                if (s.isRef) ampD *= 0.6;

                                const phase = (k * distMeters) - s.phase + (s.inv ? Math.PI : 0);
                                const amp = ampD * directivity;

                                pSumReal += amp * Math.cos(phase);
                                pSumImag += amp * Math.sin(phase);
                            }
                            const magnitude = Math.sqrt(pSumReal * pSumReal + pSumImag * pSumImag);
                            const db = 20 * Math.log10(magnitude * gain + 1e-7);
                            fillHeatmapColor(db, data, idx);
                        }
                    }
                }

                ctx.putImageData(imgData, 0, 0);

                // Dibujar Reglas Dinámicas con Precisión
                drawRulers(w, h, cx, cy, ppm);

                ctx.save(); ctx.translate(cx, cy); ctx.scale(ppm, ppm);
                
                // Dibujar Bafles (SOLO REALES, 'sources')
                sources.forEach(s => {
                    const size = 0.4; ctx.fillStyle = s.inv ? '#ef4444' : '#e4e4e7'; ctx.strokeStyle = s.dirDown ? '#3b82f6' : '#000'; ctx.lineWidth = 0.04;
                    ctx.beginPath(); ctx.arc(s.x, s.y, size/2, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                    ctx.save(); ctx.translate(s.x, s.y); if (s.dirDown) ctx.rotate(Math.PI);
                    ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.beginPath(); ctx.moveTo(-0.1, 0); ctx.lineTo(0.1, 0); ctx.lineTo(0, -0.25); ctx.fill();
                    ctx.restore();
                    ctx.save(); ctx.translate(s.x, s.y - 0.6); ctx.scale(0.04, 0.04);
                    ctx.fillStyle = "rgba(0,0,0,0.8)"; 
                    // Use roundRect if available, fallback to fillRect
                    if (ctx.roundRect) {
                        ctx.beginPath(); 
                        ctx.roundRect(-25, -10, 50, 20, 5); 
                        ctx.fill();
                    } else {
                        ctx.fillRect(-25,-10,50,20);
                    }
                    ctx.fillStyle = "#3b82f6"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.font = "bold 14px sans-serif";
                    ctx.fillText(s.delay.toFixed(2) + "ms", 0, 0); ctx.restore();
                });

                // Calculo Micrófono
                const mx = state.mic.x; const my = state.mic.y; 
                let closestDist = 999;
                sources.forEach(s => {
                    const d = Math.sqrt(Math.pow(mx - s.x, 2) + Math.pow(my - s.y, 2));
                    if(d < closestDist) closestDist = d;
                });

                // Micrófono en Mundo
                ctx.translate(mx, my);
                
                // Draw Mic
                ctx.strokeStyle = '#22c55e'; ctx.lineWidth = 0.05; ctx.beginPath(); ctx.arc(0, 0, 0.8, 0, Math.PI * 2); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(-0.6, 0); ctx.lineTo(0.6, 0); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, -0.6); ctx.lineTo(0, 0.6); ctx.stroke();
                
                // Floating Label Distancia
                ctx.save();
                ctx.fillStyle = "#fff"; ctx.font = 'bold 0.4px monospace'; ctx.textAlign = 'left';
                ctx.shadowColor="black"; ctx.shadowBlur=4;
                ctx.fillText(`Dist: ${closestDist.toFixed(2)}m`, 0.8, -0.5);
                ctx.restore();

                ctx.restore(); // Salir de coordenadas del mundo

                // OSCILOSCOPIO MÓVIL (Pegado al Mic)
                const micScreenX = cx + mx * ppm;
                const micScreenY = cy + my * ppm;
                const boxW = 120;
                const boxH = 60;
                const boxX = micScreenX - 140; // Izquierda del mic
                const boxY = micScreenY - 30; // Centrado vertical

                // Calcular Alineación de Fase (Focus Gold)
                let complexSumR = 0, complexSumI = 0;
                let magSum = 0;
                let maxSingleMag = 0; // Referencia de un solo bafle
                
                // Re-calculate complex sum for checking coherence using real physics
                simSources.forEach(s => {
                    const d = Math.sqrt(Math.pow(mx - s.x, 2) + Math.pow(my - s.y, 2));
                    const phase = (k*d) - s.phase + (s.inv ? Math.PI : 0);
                    
                    const vSMx = mx - s.x; const vSMy = my - s.y;
                    const distSM = Math.sqrt(vSMx*vSMx + vSMy*vSMy);
                    const cosTheta = distSM > 0 ? (s.dirDown ? (vSMy / distSM) : (-vSMy / distSM)) : 1.0;
                    const direct = (1.0 / Math.max(0.1, d)) * ((1.0 + cosTheta)/2.0); // Apply 1/r and directivity

                    let amp = direct; // Use direct for coherence calc, before 1/r for phase
                    
                    complexSumR += amp * Math.cos(phase);
                    complexSumI += amp * Math.sin(phase);
                    magSum += amp;
                    
                    if (!s.isRef && amp > maxSingleMag) maxSingleMag = amp;
                });
                
                const vectorSumMag = Math.sqrt(complexSumR*complexSumR + complexSumI*complexSumI);
                const coherence = magSum > 0 ? (vectorSumMag / magSum) : 0;
                
                // Determinar Estado del Osciloscopio
                let oscColor = "#00ff00"; // Default: Neon Green
                let oscText = "SUMA NORMAL"; // Default text
                let oscGuideText = ""; // Guidance text
                let shadowColor = "transparent";
                let shadowBlur = 0;

                const hardNoSoundThreshold = 0.05; // Relative low magnitude threshold for "NO SONIDO" compared to maxSingleMag
                
                // Prioridad 1: "NO SONIDO" (very low amplitude)
                if (vectorSumMag < maxSingleMag * hardNoSoundThreshold && maxSingleMag > 0.01) { 
                     oscColor = "#52525b"; // Dim grey
                     oscText = "NO SONIDO";
                     oscGuideText = "Puede ser por baja emisión o cancelación extrema.";
                     shadowColor = "transparent";
                     shadowBlur = 0;
                }
                // Prioridad 2: Cancelación
                else if (maxSingleMag > 0.01 && coherence < 0.15) { // Adjusted threshold for cancellation
                    oscColor = "#ef4444"; // Red
                    oscText = "CANCELACIÓN";
                    shadowColor = "#ef4444";
                    shadowBlur = 10;
                    // Add correction guidance
                    if (state.mode === 'broadside') {
                        oscGuideText = "Revisa polaridad (Ø) o espaciamiento (λ/4).";
                    } else if (state.mode === 'endfire') {
                        oscGuideText = "Ajusta delays (ms) o dirección (⟲).";
                    } else { // Generic advice for other scenarios (e.g., mono central with mixed settings)
                         oscGuideText = "Revisa polaridad, delays o espaciamiento.";
                    }
                } 
                // Prioridad 3: Suma Perfecta (Fase < 10 deg => Coherence > ~0.985)
                else if (coherence > 0.985) {
                    oscColor = "#ffd700"; // Dorado
                    oscText = "FASE 0° - SUMA MÁXIMA";
                    shadowColor = "#ffd700";
                    shadowBlur = 15;
                }

                ctx.save();
                // Fondo Negro Sólido
                ctx.fillStyle = "rgba(0,0,0,0.9)"; 
                ctx.fillRect(boxX, boxY, boxW, boxH);
                
                // Borde con Color Dinámico
                ctx.strokeStyle = oscColor;
                ctx.lineWidth = 2;
                ctx.shadowColor = shadowColor; 
                ctx.shadowBlur = shadowBlur;
                ctx.strokeRect(boxX, boxY, boxW, boxH);
                
                // Center Line
                ctx.shadowBlur = 0;
                ctx.strokeStyle = "rgba(255,255,255,0.2)"; ctx.lineWidth=1;
                ctx.beginPath(); ctx.moveTo(boxX, boxY + boxH/2); ctx.lineTo(boxX+boxW, boxY + boxH/2); ctx.stroke();

                // WAVEFORM (Suma Total)
                ctx.beginPath();
                ctx.strokeStyle = oscColor; 
                ctx.lineWidth = 2;
                for(let i=0; i<boxW; i++) {
                    const tOffset = i * 0.2;
                    const totalPhase = Math.atan2(complexSumI, complexSumR);
                    // The amplitude for the waveform should reflect the magnitude, and it should be scaled for visual clarity.
                    // This uses a fixed visual scale `15` and the `viewGain`.
                    const val = vectorSumMag * Math.sin(timePhase + tOffset - totalPhase);
                    
                    const y = boxY + boxH/2 - (val * 15 * gain);
                    if(i===0) ctx.moveTo(boxX+i, y); else ctx.lineTo(boxX+i, y);
                }
                ctx.stroke();
                
                // TEXTO DE FEEDBACK (Main Status)
                if (oscText) {
                    ctx.fillStyle = oscColor; 
                    ctx.font = "bold 9px sans-serif";
                    ctx.textAlign = "center";
                    ctx.shadowColor = "black"; ctx.shadowBlur = 2;
                    ctx.fillText(oscText, boxX + boxW/2, boxY + 12);
                }

                // TEXTO DE COHERENCIA NUMÉRICA
                if (maxSingleMag > 0.01) { // Solo mostrar si hay una señal sonora significativa
                    const coherencePercentage = (coherence * 100).toFixed(1);
                    ctx.fillStyle = "#ccc"; // Gris claro para el valor numérico
                    ctx.font = "8px monospace"; // Monoespaciado para números
                    ctx.textAlign = "center";
                    ctx.shadowColor = "black"; ctx.shadowBlur = 2;
                    ctx.fillText(`Coh: ${coherencePercentage}%`, boxX + boxW/2, boxY + 22);
                }


                // TEXTO DE GUÍA (Optional Guidance)
                if (oscGuideText) {
                    ctx.fillStyle = "#a1a1aa"; // Dimmer color for guidance
                    ctx.font = "8px sans-serif"; // Smaller font
                    ctx.textAlign = "center";
                    ctx.shadowColor = "black"; ctx.shadowBlur = 2;
                    // Posicionado más abajo para dejar espacio a la coherencia
                    ctx.fillText(oscGuideText, boxX + boxW/2, boxY + 32); 
                }

                ctx.restore();
            }

            function animate() { if(state.isPlaying) state.time += 0.2; draw(); requestAnimationFrame(animate); }
            els.canvas.width = els.canvas.parentElement.clientWidth; els.canvas.height = els.canvas.parentElement.clientHeight;
            
            updateUI(); animate(); 
            
            // Attach event listener for the reset button after all elements are loaded
            els.reset.addEventListener('click', window.app.resetSimulator);
            els.fullscreen.addEventListener('click', window.app.toggleFullscreen);
        };
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>