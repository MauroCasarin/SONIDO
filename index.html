<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Arreglos Acústicos - MC Audio</title>
    <style>
        :root {
            --bg-dark: #09090b; /* Zinc 950 */
            --bg-panel: #18181b; /* Zinc 900 */
            --border: #27272a;   /* Zinc 800 */
            --accent: #3b82f6;   /* Blue 500 */
            --accent-glow: rgba(59, 130, 246, 0.2);
            --text-main: #e4e4e7;
            --text-dim: #a1a1aa;
            --danger: #ef4444;
            --success: #22c55e;
            --warning: #f59e0b;
        }

        body {
            background-color: var(--bg-dark);
            color: var(--text-main);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            user-select: none;
        }

        /* HEADER */
        header {
            height: 60px; /* Un poco más alto para el logo */
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            background: #000;
        }

        .brand-area {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .logo-img {
            height: 45px;
            width: auto;
            transition: transform 0.2s;
            cursor: pointer;
        }
        
        .logo-img:hover {
            transform: scale(1.05);
            filter: brightness(1.2);
        }

        h1 {
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 0;
            color: #fff;
            display: flex;
            flex-direction: column;
        }

        h1 span {
            font-size: 10px;
            color: var(--accent);
            letter-spacing: 2px;
        }

        /* LAYOUT */
        #main-layout {
            display: flex;
            flex: 1;
            height: calc(100vh - 60px);
        }

        /* SIDEBAR (CONTROLES) */
        #controles {
            width: 320px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 24px;
            overflow-y: auto;
            flex-shrink: 0;
        }

        /* CANVAS AREA */
        #viewport {
            flex: 1;
            position: relative;
            background: #000;
            overflow: hidden;
            cursor: crosshair;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            display: block;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }

        /* UI ELEMENTS */
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
            background: rgba(255,255,255,0.03);
            padding: 15px;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.05);
        }

        .group-title {
            font-size: 10px;
            font-weight: bold;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .slider-row {
            margin-bottom: 8px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: var(--text-dim);
            margin-bottom: 4px;
        }

        .slider-val {
            color: var(--accent);
            font-family: monospace;
            font-weight: bold;
        }

        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        
        input[type=range]:focus { outline: none; }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 14px;
            width: 14px;
            border-radius: 50%;
            background: #e4e4e7;
            cursor: pointer;
            margin-top: -5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #3f3f46;
            border-radius: 2px;
        }

        /* BOTONES */
        .btn-row { display: flex; gap: 8px; }
        .btn-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; }

        button {
            background: #27272a;
            border: 1px solid #3f3f46;
            color: var(--text-dim);
            padding: 8px 12px;
            font-size: 10px;
            font-weight: bold;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        button:hover {
            background: #3f3f46;
            color: #fff;
        }

        button.active {
            background: var(--accent);
            color: #fff;
            border-color: var(--accent);
            box-shadow: 0 0 10px var(--accent-glow);
        }

        button.danger {
            color: var(--danger);
            border-color: rgba(239, 68, 68, 0.3);
            background: rgba(239, 68, 68, 0.05);
        }
        button.danger:hover {
            background: var(--danger);
            color: white;
        }

        /* POLARIDAD */
        .polarity-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
        }

        .pol-btn {
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
        }

        .pol-btn span:first-child { font-size: 12px; margin-bottom: 2px; }
        
        .pol-btn.normal { background: #27272a; color: #71717a; border: 1px solid #3f3f46; }
        .pol-btn.inverted { background: rgba(239, 68, 68, 0.1); color: var(--danger); border: 1px solid var(--danger); }

        /* OVERLAYS */
        .hud-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(9, 9, 11, 0.9);
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 8px;
            width: 210px;
            pointer-events: none;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .hud-row {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            margin-bottom: 6px;
            font-family: monospace;
        }

        .hud-label { color: #71717a; }
        .hud-value { color: #fff; font-weight: bold; }
        
        .status-ok { color: var(--success); }
        .status-warn { color: var(--warning); }
        .status-danger { color: var(--danger); }

        .legend-gradient {
            height: 6px;
            background: linear-gradient(90deg, #000 0%, #0000ff 25%, #00ffff 50%, #ffffff 75%, #ff0000 100%);
            border-radius: 3px;
            margin-top: 10px;
        }
        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 9px;
            color: #52525b;
            margin-top: 4px;
        }

        /* FOOTER */
        footer {
            height: 24px;
            background: #000;
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #3f3f46;
        }

    </style>
<link rel="stylesheet" href="/index.css">
</head>
<body>

    <header>
        <div class="brand-area">
            <a href="https://www.instagram.com/3d_mc_3d/" target="_blank" title="Visitar Instagram de MC">
                <img src="https://raw.githubusercontent.com/MauroCasarin/SONIDO/refs/heads/main/MC%2048%20N.png" alt="MC Logo" class="logo-img">
            </a>
            <h1>
                SIMULADOR DE ARREGLOS
                <span>SISTEMAS ACÚSTICOS</span>
            </h1>
        </div>
        <div style="font-size:10px; color:#555; font-weight:bold;">MOTOR: VANILLA JS</div>
    </header>

    <div id="main-layout">
        
        <!-- CONTROLES SIDEBAR -->
        <div id="controles">
            
            <!-- Global Params -->
            <div class="control-group">
                <div class="group-title">PARÁMETROS DE FUENTE</div>
                
                <div class="slider-row">
                    <div class="slider-label">
                        <span>Frecuencia</span>
                        <span class="slider-val" id="disp-freq">60 Hz</span>
                    </div>
                    <input type="range" id="input-freq" min="20" max="200" value="60">
                </div>

                <div class="slider-row">
                    <div class="slider-label">
                        <span>Separación</span>
                        <span class="slider-val" id="disp-dist">1.00 m</span>
                    </div>
                    <input type="range" id="input-dist" min="0.2" max="4.0" step="0.01" value="1.00">
                </div>

                <div class="slider-row">
                    <div class="slider-label">
                        <span>Cant. Bafles (N)</span>
                        <span class="slider-val" id="disp-count">4</span>
                    </div>
                    <input type="range" id="input-count" min="2" max="16" step="1" value="4">
                </div>

                <div class="slider-row">
                    <div class="slider-label">
                        <span>Temperatura</span>
                        <span class="slider-val" id="disp-temp" style="color:var(--warning)">20 °C</span>
                    </div>
                    <input type="range" id="input-temp" min="-10" max="45" value="20">
                </div>
            </div>

            <!-- Configuration -->
            <div class="control-group">
                <div class="group-title">CONFIGURACIÓN DE ARREGLO</div>
                
                <div class="btn-row">
                    <button id="btn-broad" class="active" style="flex:1" onclick="app.setMode('broadside')">BROADSIDE</button>
                    <button id="btn-end" style="flex:1" onclick="app.setMode('endfire')">END-FIRE</button>
                </div>

                <div style="margin-top:12px; margin-bottom:6px; font-size:9px; font-weight:bold; color:#52525b;">PRESETS AUTOMÁTICOS (λ/4)</div>
                <div class="btn-grid">
                    <button onclick="app.applyPreset(40)">40Hz</button>
                    <button onclick="app.applyPreset(50)">50Hz</button>
                    <button onclick="app.applyPreset(63)">63Hz</button>
                    <button onclick="app.applyPreset(80)">80Hz</button>
                </div>

                <div class="btn-row" style="margin-top:12px;">
                    <button class="danger" style="flex:1" onclick="app.setupCardioid()">CARDIOIDE CSA</button>
                    <button style="flex:1; border-color:var(--accent); color:var(--accent);" onclick="app.optimizeSpacing()">AUTO ESPACIO</button>
                </div>
            </div>

            <!-- Audience Zones -->
            <div class="control-group">
                <div class="group-title">ZONAS DE PÚBLICO</div>
                <div style="font-size:10px; color:#555; margin-bottom:8px;">
                    Dibuja zonas para calcular cobertura (±3dB).
                </div>
                <div class="btn-row">
                    <button onclick="app.addZone()" style="flex:2; color:var(--success); border-color:rgba(34,197,94,0.3);">+ AÑADIR ZONA</button>
                    <button onclick="app.clearZones()" class="danger" style="flex:1;">BORRAR</button>
                </div>
            </div>

            <!-- Polarity -->
            <div class="control-group">
                <div class="group-title">MATRIZ DE POLARIDAD</div>
                <div id="polarity-container" class="polarity-grid">
                    <!-- Generated by JS -->
                </div>
            </div>

            <div style="font-size:10px; color:#555; text-align:center;">
                <strong>Micrófono Virtual:</strong> Arrastra el círculo para medir.<br>
                Rueda: Zoom • Arrastrar fondo: Panorámica
            </div>
        </div>

        <!-- VISUALIZER AREA -->
        <div id="viewport">
            <canvas id="simCanvas" width="800" height="600"></canvas>
            
            <!-- HUD OVERLAY -->
            <div class="hud-panel">
                <div class="hud-row">
                    <span class="hud-label">Velocidad Sonido:</span>
                    <span class="hud-value" id="hud-speed">--</span>
                </div>
                <div class="hud-row">
                    <span class="hud-label">Longitud de Onda (λ):</span>
                    <span class="hud-value" id="hud-lambda">--</span>
                </div>
                <div style="height:1px; background:#333; margin:8px 0;"></div>
                <div class="hud-row">
                    <span class="hud-label">Alineación de Fase:</span>
                    <span class="hud-value" id="hud-status">CALCULANDO...</span>
                </div>
                <div class="hud-row" id="row-delay">
                    <span class="hud-label">Retardo E.F.:</span>
                    <span class="hud-value" id="hud-delay" style="color:var(--warning)">0.00 ms</span>
                </div>
                
                <div style="height:1px; background:#333; margin:8px 0;"></div>
                <div class="hud-row">
                    <span class="hud-label">Cobertura Público:</span>
                    <span class="hud-value" id="hud-coverage">--</span>
                </div>
                <div style="font-size:9px; color:#555; text-align:right;">(±3dB del Máx)</div>

                <div class="legend-gradient"></div>
                <div class="legend-labels">
                    <span>-INF</span>
                    <span>0dB</span>
                    <span>CLIP</span>
                </div>
            </div>
        </div>

    </div>

    <footer>
        SIN LIBRERÍAS EXTERNAS • 100% VANILLA JS/HTML5
    </footer>

    <script>
        /**
         * SINGLE FILE APPLICATION LOGIC
         * Encapsulated in a window.onload function as requested.
         */
        
        window.onload = function() {
            
            // --- STATE MANAGEMENT ---
            const state = {
                freq: 60,
                dist: 1.0,
                count: 4,
                temp: 20,
                mode: 'broadside', // 'broadside' | 'endfire'
                polarities: new Array(16).fill(false),
                view: {
                    scale: 30, // Pixels per meter
                    x: 0,      // Offset X
                    y: 0,      // Offset Y
                    dragging: false,
                    lastX: 0,
                    lastY: 0,
                    dragType: null, // 'view', 'mic', 'zone', 'zone-resize'
                    dragIndex: -1
                },
                mic: {
                    x: 0, // World X (meters)
                    y: 2, // World Y (meters)
                },
                zones: [], // Array of {x, y, w, h} in meters
                coverageStats: 0
            };

            // --- DOM CACHE ---
            const els = {
                canvas: document.getElementById('simCanvas'),
                inputs: {
                    freq: document.getElementById('input-freq'),
                    dist: document.getElementById('input-dist'),
                    count: document.getElementById('input-count'),
                    temp: document.getElementById('input-temp')
                },
                displays: {
                    freq: document.getElementById('disp-freq'),
                    dist: document.getElementById('disp-dist'),
                    count: document.getElementById('disp-count'),
                    temp: document.getElementById('disp-temp')
                },
                hud: {
                    speed: document.getElementById('hud-speed'),
                    lambda: document.getElementById('hud-lambda'),
                    status: document.getElementById('hud-status'),
                    delay: document.getElementById('hud-delay'),
                    delayRow: document.getElementById('row-delay'),
                    coverage: document.getElementById('hud-coverage')
                },
                btns: {
                    broad: document.getElementById('btn-broad'),
                    end: document.getElementById('btn-end')
                },
                polContainer: document.getElementById('polarity-container')
            };

            const ctx = els.canvas.getContext('2d', { alpha: false });

            // --- APP API (Global exposure for HTML onclicks) ---
            window.app = {
                setMode: (m) => {
                    state.mode = m;
                    els.btns.broad.className = m === 'broadside' ? 'active' : '';
                    els.btns.end.className = m === 'endfire' ? 'active' : '';
                    updateUI();
                    requestAnimationFrame(draw);
                },
                togglePolarity: (i) => {
                    state.polarities[i] = !state.polarities[i];
                    renderPolarityGrid();
                    requestAnimationFrame(draw);
                },
                applyPreset: (hz) => {
                    state.freq = hz;
                    els.inputs.freq.value = hz;
                    // Auto λ/4 spacing
                    const v = 331.3 * Math.sqrt(1 + state.temp / 273.15);
                    let optimal = (v / hz) / 4;
                    // Clamp
                    optimal = Math.min(4.0, Math.max(0.2, optimal));
                    state.dist = optimal;
                    els.inputs.dist.value = optimal;
                    
                    updateUI();
                    requestAnimationFrame(draw);
                },
                setupCardioid: () => {
                    // CSA Preset: 2 Elements, End-Fire, Rear Inv, Spaced λ/4
                    state.count = 2;
                    els.inputs.count.value = 2;
                    window.app.setMode('endfire');
                    state.polarities.fill(false);
                    state.polarities[0] = true;
                    window.app.applyPreset(state.freq);
                },
                optimizeSpacing: () => {
                     const v = 331.3 * Math.sqrt(1 + state.temp / 273.15);
                     let optimal = (v / state.freq) / 4;
                     optimal = Math.min(4.0, Math.max(0.2, optimal));
                     state.dist = optimal;
                     els.inputs.dist.value = optimal;
                     updateUI();
                     requestAnimationFrame(draw);
                },
                addZone: () => {
                    // Add a default zone near center
                    state.zones.push({
                        x: -2, 
                        y: 3, 
                        w: 4, 
                        h: 3
                    });
                    requestAnimationFrame(draw);
                },
                clearZones: () => {
                    state.zones = [];
                    requestAnimationFrame(draw);
                }
            };

            // --- EVENT LISTENERS ---
            
            // Inputs
            Object.keys(els.inputs).forEach(key => {
                els.inputs[key].addEventListener('input', (e) => {
                    state[key] = parseFloat(e.target.value);
                    updateUI();
                    requestAnimationFrame(draw);
                });
            });

            // Canvas Interaction Logic
            els.canvas.addEventListener('mousedown', e => {
                const rect = els.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const cx = els.canvas.width / 2 + state.view.x;
                const cy = els.canvas.height / 2 + state.view.y;
                const ppm = state.view.scale;

                // 1. Check Mic Hit
                const micScreenX = cx + state.mic.x * ppm;
                const micScreenY = cy + state.mic.y * ppm;
                const distToMic = Math.sqrt(Math.pow(mouseX - micScreenX, 2) + Math.pow(mouseY - micScreenY, 2));

                if (distToMic < 15) {
                    state.view.dragType = 'mic';
                } else {
                    // 2. Check Zones Hit
                    let hitZone = false;
                    for(let i=state.zones.length-1; i>=0; i--) {
                        const z = state.zones[i];
                        const zx = cx + z.x * ppm;
                        const zy = cy + z.y * ppm;
                        const zw = z.w * ppm;
                        const zh = z.h * ppm;

                        // Resize handle (bottom right)
                        const handleSize = 15;
                        if (mouseX > zx + zw - handleSize && mouseX < zx + zw + handleSize &&
                            mouseY > zy + zh - handleSize && mouseY < zy + zh + handleSize) {
                            state.view.dragType = 'zone-resize';
                            state.view.dragIndex = i;
                            hitZone = true;
                            break;
                        }

                        // Body
                        if (mouseX >= zx && mouseX <= zx + zw && mouseY >= zy && mouseY <= zy + zh) {
                            state.view.dragType = 'zone';
                            state.view.dragIndex = i;
                            hitZone = true;
                            break;
                        }
                    }

                    if (!hitZone) {
                        state.view.dragType = 'view';
                    }
                }

                state.view.dragging = true;
                state.view.lastX = e.clientX;
                state.view.lastY = e.clientY;
            });

            window.addEventListener('mouseup', () => {
                state.view.dragging = false;
                state.view.dragType = null;
                state.view.dragIndex = -1;
            });

            window.addEventListener('mousemove', e => {
                if(state.view.dragging) {
                    const dxPix = e.clientX - state.view.lastX;
                    const dyPix = e.clientY - state.view.lastY;
                    const dxM = dxPix / state.view.scale;
                    const dyM = dyPix / state.view.scale;

                    if (state.view.dragType === 'view') {
                        state.view.x += dxPix;
                        state.view.y += dyPix;
                    } 
                    else if (state.view.dragType === 'mic') {
                        state.mic.x += dxM;
                        state.mic.y += dyM;
                    }
                    else if (state.view.dragType === 'zone') {
                        const z = state.zones[state.view.dragIndex];
                        z.x += dxM;
                        z.y += dyM;
                    }
                    else if (state.view.dragType === 'zone-resize') {
                        const z = state.zones[state.view.dragIndex];
                        z.w = Math.max(0.5, z.w + dxM);
                        z.h = Math.max(0.5, z.h + dyM);
                    }

                    state.view.lastX = e.clientX;
                    state.view.lastY = e.clientY;
                    requestAnimationFrame(draw);
                }
            });

            els.canvas.addEventListener('wheel', e => {
                e.preventDefault();
                const factor = e.deltaY > 0 ? 0.9 : 1.1;
                state.view.scale *= factor;
                // Clamp zoom
                state.view.scale = Math.max(5, Math.min(100, state.view.scale));
                requestAnimationFrame(draw);
            });

            // Resize
            window.addEventListener('resize', handleResize);

            // --- CORE FUNCTIONS ---

            function handleResize() {
                const parent = els.canvas.parentElement;
                els.canvas.width = parent.clientWidth;
                els.canvas.height = parent.clientHeight;
                requestAnimationFrame(draw);
            }

            function updateUI() {
                // Texts
                els.displays.freq.innerText = state.freq + ' Hz';
                els.displays.dist.innerText = state.dist.toFixed(2) + ' m';
                els.displays.count.innerText = state.count;
                els.displays.temp.innerText = state.temp + ' °C';

                // Physics Calcs for HUD
                const c = 331.3 * Math.sqrt(1 + state.temp / 273.15);
                const lambda = c / state.freq;
                const delay = (state.dist / c) * 1000;

                els.hud.speed.innerText = c.toFixed(1) + ' m/s';
                els.hud.lambda.innerText = lambda.toFixed(2) + ' m';
                
                // Status Check
                const limit = (2/3) * lambda; // Aliasing
                const optimal = lambda / 4;   // Coupling

                if (state.dist > limit) {
                    els.hud.status.innerText = "ALERTA: ALIASING";
                    els.hud.status.className = "hud-value status-danger";
                } else if (Math.abs(state.dist - optimal) < optimal * 0.15) {
                    els.hud.status.innerText = "ÓPTIMO (λ/4)";
                    els.hud.status.className = "hud-value status-ok";
                } else {
                    els.hud.status.innerText = "ESTÁNDAR";
                    els.hud.status.className = "hud-value";
                }

                if (state.mode === 'endfire') {
                    els.hud.delayRow.style.display = 'flex';
                    els.hud.delay.innerText = delay.toFixed(2) + ' ms / caja';
                } else {
                    els.hud.delayRow.style.display = 'none';
                }

                // Coverage Update
                if (state.zones.length > 0) {
                     els.hud.coverage.innerText = state.coverageStats.toFixed(1) + '%';
                     if (state.coverageStats > 80) els.hud.coverage.className = "hud-value status-ok";
                     else if (state.coverageStats > 50) els.hud.coverage.className = "hud-value status-warn";
                     else els.hud.coverage.className = "hud-value status-danger";
                } else {
                    els.hud.coverage.innerText = "N/A";
                    els.hud.coverage.className = "hud-value";
                }

                renderPolarityGrid();
            }

            function renderPolarityGrid() {
                els.polContainer.innerHTML = '';
                for(let i=0; i<state.count; i++) {
                    const btn = document.createElement('div');
                    const inv = state.polarities[i];
                    btn.className = inv ? 'pol-btn inverted' : 'pol-btn normal';
                    btn.innerHTML = `<span>${i+1}</span><span>${inv ? 'INV' : 'NOR'}</span>`;
                    btn.onclick = () => window.app.togglePolarity(i);
                    els.polContainer.appendChild(btn);
                }
            }

            function draw() {
                const w = els.canvas.width;
                const h = els.canvas.height;
                const cx = w/2 + state.view.x;
                const cy = h/2 + state.view.y;
                
                // Physics
                const c = 331.3 * Math.sqrt(1 + state.temp / 273.15);
                const k = (2 * Math.PI * state.freq) / c;

                // Sources setup
                const sources = [];
                const ppm = state.view.scale; 

                if (state.mode === 'broadside') {
                    const totalW = (state.count - 1) * state.dist;
                    const startX = -totalW / 2;
                    for(let i=0; i<state.count; i++) {
                        sources.push({
                            x: startX + (i * state.dist),
                            y: 0,
                            phase: 0,
                            inv: state.polarities[i]
                        });
                    }
                } else {
                    const totalH = (state.count - 1) * state.dist;
                    const startY = totalH / 2; 
                    for(let i=0; i<state.count; i++) {
                        const yPos = startY - (i * state.dist);
                        const delayMeters = i * state.dist;
                        sources.push({
                            x: 0,
                            y: yPos,
                            phase: k * delayMeters,
                            inv: state.polarities[i]
                        });
                    }
                }

                // --- HEATMAP & COVERAGE LOGIC ---
                // We perform coverage calculation IN the pixel loop for performance
                // Pre-calc zone boundaries in pixels
                const activeZones = state.zones.map(z => ({
                    left: cx + z.x * ppm,
                    right: cx + (z.x + z.w) * ppm,
                    top: cy + z.y * ppm,
                    bottom: cy + (z.y + z.h) * ppm,
                    areaPoints: 0,
                    goodPoints: 0
                }));

                // Track global max magnitude found during render for normalization context
                // Although physically max is roughly 1.0 with our normalization, let's track it
                // To avoid two passes, we assume Max is 1.0 (Constructive Sum of all elements normalized)
                // -3dB is approx 0.707 linear magnitude.
                const threshold = 0.707;

                ctx.fillStyle = '#000';
                ctx.fillRect(0,0,w,h);

                const imgData = ctx.getImageData(0, 0, w, h);
                const data = imgData.data;

                const screenSources = sources.map(s => ({
                    sx: s.x * ppm,
                    sy: s.y * ppm,
                    ph: s.phase,
                    inv: s.inv
                }));

                const gain = 1.0 / (state.count * 0.85); 

                for(let y=0; y<h; y+=2) { 
                    const wy = y - cy;
                    const rowOff = y * w * 4;

                    for(let x=0; x<w; x++) {
                        const wx = x - cx;

                        let rSum = 0;
                        let iSum = 0;

                        for(let i=0; i<screenSources.length; i++) {
                            const s = screenSources[i];
                            const dx = wx - s.sx;
                            const dy = wy - s.sy;
                            
                            const distPix = Math.sqrt(dx*dx + dy*dy);
                            const distMeters = distPix / ppm;

                            const amp = 1.0 / (1.0 + distMeters); 
                            const phi = (k * distMeters) - s.ph + (s.inv ? Math.PI : 0);

                            rSum += Math.cos(phi) * amp;
                            iSum += Math.sin(phi) * amp;
                        }

                        const mag = Math.sqrt(rSum*rSum + iSum*iSum) * gain;
                        
                        // Coverage Check
                        for (let z of activeZones) {
                            if (x >= z.left && x <= z.right && y >= z.top && y <= z.bottom) {
                                z.areaPoints++;
                                if (mag >= threshold) z.goodPoints++;
                            }
                        }

                        // Color Mapping
                        let r=0, g=0, b=0;
                        
                        if (mag < 0.25) { b = (mag / 0.25) * 128; } 
                        else if (mag < 0.5) {
                            const t = (mag - 0.25) / 0.25;
                            g = t * 255;
                            b = 128 + (t * 127);
                        } else if (mag < 0.75) {
                            const t = (mag - 0.5) / 0.25;
                            r = t * 255;
                            g = 255;
                            b = 255;
                        } else {
                            const t = Math.min(1, (mag - 0.75) / 0.25);
                            r = 255;
                            g = 255 * (1 - t);
                            b = 255 * (1 - t);
                        }

                        // Grid
                        const gridX = Math.abs(wx / ppm);
                        const gridY = Math.abs(wy / ppm);
                        if (Math.abs(gridX - Math.round(gridX)) < 0.02 || Math.abs(gridY - Math.round(gridY)) < 0.02) {
                            r += 30; g += 30; b += 30;
                        }

                        const idx = rowOff + (x * 4);
                        data[idx] = r;
                        data[idx+1] = g;
                        data[idx+2] = b;
                        data[idx+3] = 255;
                    }
                }
                
                ctx.putImageData(imgData, 0, 0);

                // Update Stats
                let totalPoints = 0;
                let totalGood = 0;
                activeZones.forEach(z => {
                    totalPoints += z.areaPoints;
                    totalGood += z.goodPoints;
                });
                
                const newStats = totalPoints > 0 ? (totalGood / totalPoints) * 100 : 0;
                if (Math.abs(newStats - state.coverageStats) > 0.1) {
                    state.coverageStats = newStats;
                    updateUI(); // Only update DOM if changed significantly
                }

                // --- VIRTUAL MIC CALCULATION ---
                let micR = 0, micI = 0;
                let minTime = Infinity, maxTime = -Infinity;

                sources.forEach(s => {
                    const dx = state.mic.x - s.x;
                    const dy = state.mic.y - s.y;
                    const d = Math.sqrt(dx*dx + dy*dy);
                    const amp = 1.0 / (1.0 + d);
                    const phi = (k * d) - s.phase + (s.inv ? Math.PI : 0);
                    
                    micR += Math.cos(phi) * amp;
                    micI += Math.sin(phi) * amp;

                    // Time of Arrival
                    const t = (d / c) * 1000; // ms
                    if(t < minTime) minTime = t;
                    if(t > maxTime) maxTime = t;
                });

                const micMag = Math.sqrt(micR*micR + micI*micI) * gain;
                const micPhase = Math.atan2(micI, micR) * (180/Math.PI);
                const deltaT = maxTime - minTime;
                
                // --- VECTOR OVERLAYS ---
                ctx.save();
                ctx.translate(cx, cy);
                ctx.scale(ppm, ppm); // Draw in meters

                // 1. Draw Audience Zones
                state.zones.forEach((z, i) => {
                    ctx.fillStyle = 'rgba(34, 197, 94, 0.2)'; // Semi-transparent green
                    ctx.strokeStyle = '#22c55e';
                    ctx.lineWidth = 0.03;
                    
                    // Body
                    ctx.fillRect(z.x, z.y, z.w, z.h);
                    ctx.strokeRect(z.x, z.y, z.w, z.h);

                    // Resize Handle
                    const hSize = 0.3; // meters
                    ctx.fillStyle = 'rgba(34, 197, 94, 0.8)';
                    ctx.fillRect(z.x + z.w - hSize, z.y + z.h - hSize, hSize, hSize);
                    
                    // Label
                    ctx.fillStyle = '#fff';
                    ctx.font = '0.3px sans-serif'; // Scaled font
                    ctx.fillText(`Zona ${i+1}`, z.x + 0.1, z.y - 0.1);
                });

                // 2. Trajectory Lines
                ctx.globalAlpha = 0.3;
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 0.02;
                sources.forEach(s => {
                    ctx.beginPath();
                    ctx.moveTo(s.x, s.y);
                    ctx.lineTo(state.mic.x, state.mic.y);
                    ctx.stroke();
                });
                ctx.globalAlpha = 1.0;

                // 3. Sources
                sources.forEach((s, i) => {
                    const size = 0.4; // box size meters
                    ctx.fillStyle = s.inv ? '#450a0a' : '#18181b';
                    ctx.strokeStyle = s.inv ? '#ef4444' : '#a1a1aa';
                    ctx.lineWidth = 0.05;
                    
                    ctx.fillRect(s.x - size/2, s.y - size/2, size, size);
                    ctx.strokeRect(s.x - size/2, s.y - size/2, size, size);
                });

                // 4. Virtual Microphone
                ctx.translate(state.mic.x, state.mic.y);
                const micColor = micMag > 0.5 ? '#22c55e' : (micMag < 0.2 ? '#ef4444' : '#fbbf24');
                ctx.strokeStyle = micColor;
                ctx.lineWidth = 0.05;
                ctx.beginPath();
                ctx.arc(0, 0, 0.2, 0, Math.PI * 2);
                ctx.stroke();
                // Crosshair
                ctx.beginPath(); ctx.moveTo(-0.15, 0); ctx.lineTo(0.15, 0); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, -0.15); ctx.lineTo(0, 0.15); ctx.stroke();

                ctx.restore();
                
                // --- HUD & LABELS (Screen Space) ---
                ctx.save();
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Source Labels
                ctx.fillStyle = '#fff';
                sources.forEach((s, i) => {
                    const sx = cx + s.x * ppm;
                    const sy = cy + s.y * ppm;
                    ctx.fillText(s.inv ? 'Ø' : (i+1), sx, sy);
                });

                // Mic Info Bubble
                const mx = cx + state.mic.x * ppm;
                const my = cy + state.mic.y * ppm;
                
                // Bubble Background
                const boxW = 110, boxH = 50;
                const bx = mx + 20, by = my - 25;
                
                ctx.fillStyle = 'rgba(0,0,0,0.85)';
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.roundRect(bx, by, boxW, boxH, 6);
                ctx.fill();
                ctx.stroke();

                // Bubble Text
                ctx.textAlign = 'left';
                ctx.fillStyle = '#a1a1aa';
                ctx.fillText(`Presión: ${(micMag*100).toFixed(0)}%`, bx + 10, by + 15);
                ctx.fillStyle = deltaT < 1.0 ? '#22c55e' : '#f59e0b';
                ctx.fillText(`Δt: ${deltaT.toFixed(2)} ms`, bx + 10, by + 28);
                ctx.fillStyle = '#e4e4e7';
                ctx.fillText(`Fase: ${micPhase.toFixed(0)}°`, bx + 10, by + 41);

                ctx.restore();
            }

            // Init
            handleResize();
            updateUI();
        };
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>