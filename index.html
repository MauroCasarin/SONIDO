<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Simulador Educativo sonidos graves - MC Audio</title>
    <style>
        :root {
            --bg-dark: #09090b; /* Zinc 950 */
            --bg-panel: rgba(10, 10, 12, 0.95);
            --border: rgba(255, 255, 255, 0.1);
            --accent: #3b82f6;   /* Blue 500 */
            --accent-glow: rgba(59, 130, 246, 0.3);
            --text-main: #e4e4e7;
            --text-dim: #a1a1aa;
            --danger: #ef4444;
            --success: #22c55e;
            --warning: #f59e0b;
        }

        body {
            background-color: var(--bg-dark);
            color: var(--text-main);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior: none;
        }

        /* HEADER */
        header {
            height: 40px; 
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
            background: rgba(5,5,5,0.95);
            backdrop-filter: blur(5px);
            flex-shrink: 0;
            z-index: 50;
        }

        .brand-area {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .brand-link {
            text-decoration: none;
            display: flex;
            align-items: center;
        }

        .logo-img {
            height: 28px;
            width: auto;
            transition: transform 0.2s;
            cursor: pointer;
        }
        
        h1 {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 0;
            color: #fff;
            display: flex;
            flex-direction: column;
            line-height: 1;
        }

        h1 span {
            font-size: 8px;
            color: var(--accent);
            letter-spacing: 1px;
        }

        /* LAYOUT */
        #main-layout {
            display: flex;
            flex: 1;
            height: calc(100vh - 40px - 25px); 
            overflow: hidden;
            position: relative;
        }

        /* SIDEBAR (CONTROLES) */
        #controles {
            width: 280px;
            background: var(--bg-panel);
            backdrop-filter: blur(12px);
            border-right: 1px solid var(--border);
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow-y: auto;
            flex-shrink: 0;
            z-index: 20;
            overscroll-behavior: contain;
            transition: opacity 0.3s ease;
        }

        /* Top Controls Bar */
        .controls-top-bar {
            display: flex;
            gap: 5px;
            margin-bottom: 5px;
        }
        
        .controls-top-bar button {
            flex: 1;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        /* CLASE PARA AUTO-OCULTAR (70% TRANSPARENCIA) */
        .controls-hidden {
            opacity: 0.3 !important;
        }

        /* CANVAS AREA */
        #viewport {
            flex: 1;
            position: relative;
            background: #000;
            overflow: hidden;
            cursor: crosshair;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        canvas {
            display: block;
            touch-action: none;
            /* SUAVIZADO VISUAL */
            filter: blur(0.5px) contrast(1.1); 
            image-rendering: optimizeQuality;
        }

        .btn-help-main {
            border-radius: 4px;
            font-weight: bold;
            font-size: 14px;
        }

        /* CUSTOM TOOLTIP (ANIMATED & DELAYED) */
        .custom-tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 11px;
            pointer-events: none;
            z-index: 1000;
            max-width: 220px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.6);
            text-align: left;
            line-height: 1.4;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.4s ease, transform 0.4s ease;
        }
        
        .custom-tooltip.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .custom-tooltip strong {
            display: block;
            color: var(--accent);
            margin-bottom: 3px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* UI ELEMENTS */
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            background: rgba(255,255,255,0.03);
            padding: 8px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.05);
        }

        .group-title {
            font-size: 8px;
            font-weight: 700;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 2px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .slider-row { margin-bottom: 2px; }
        .slider-row.disabled { opacity: 0.3; pointer-events: none; }
        .slider-label {
            display: flex; justify-content: space-between; font-size: 9px;
            color: var(--text-dim); margin-bottom: 1px;
        }
        .slider-val { color: var(--accent); font-family: monospace; font-weight: bold; }

        input[type=range] {
            -webkit-appearance: none; width: 100%; background: transparent; padding: 4px 0; margin: 0;
        }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 14px; width: 14px;
            border-radius: 50%; background: #e4e4e7; cursor: pointer;
            margin-top: -6px; box-shadow: 0 1px 3px rgba(0,0,0,0.8); border: 1px solid #000;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 2px; cursor: pointer;
            background: rgba(255, 255, 255, 0.2); border-radius: 1px;
        }

        .btn-row { display: flex; gap: 4px; }
        
        button {
            background: rgba(30, 30, 35, 0.9);
            border: 1px solid rgba(80, 80, 90, 0.5);
            color: var(--text-dim);
            padding: 6px; font-size: 9px; font-weight: 600;
            border-radius: 3px; cursor: pointer; transition: all 0.2s; text-transform: uppercase;
        }
        button:hover { background: rgba(60, 60, 70, 0.9); color: #fff; }
        button.active { background: var(--accent); color: #fff; border-color: var(--accent); box-shadow: 0 0 8px var(--accent-glow); }
        button.danger { color: var(--danger); border-color: rgba(239, 68, 68, 0.3); background: rgba(239, 68, 68, 0.05); }
        button.magic { background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%); color: white; border: none; box-shadow: 0 0 8px rgba(124, 58, 237, 0.3); }
        button.small-btn { padding: 4px; font-size: 8px; }

        /* POLARIDAD */
        .polarity-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 3px; }
        .pol-btn {
            aspect-ratio: 1.3; display: flex; flex-direction: column; align-items: center; justify-content: center;
            border-radius: 2px; font-size: 8px; font-weight: bold; cursor: pointer;
        }
        .pol-btn span:first-child { font-size: 9px; margin-bottom: 0px; }
        .pol-btn.normal { background: rgba(40, 40, 45, 0.7); color: #71717a; border: 1px solid rgba(80, 80, 90, 0.3); }
        .pol-btn.inverted { background: rgba(239, 68, 68, 0.2); color: var(--danger); border: 1px solid var(--danger); }

        /* HUD & OVERLAYS */
        .hud-panel {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0, 0, 0, 0.6); border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(3px); padding: 8px; border-radius: 4px;
            width: 140px; pointer-events: none; z-index: 15; transition: opacity 0.3s;
        }
        .hud-row { display: flex; justify-content: space-between; font-size: 9px; margin-bottom: 3px; font-family: monospace; }
        .hud-label { color: #a1a1aa; }
        .hud-value { color: #fff; font-weight: bold; }
        
        /* MODAL GU√çA */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); backdrop-filter: blur(5px);
            z-index: 200; display: flex; align-items: center; justify-content: center;
            opacity: 0; pointer-events: none; transition: opacity 0.3s ease;
        }
        .modal-overlay.open { opacity: 1; pointer-events: auto; }
        .modal-content {
            background: #18181b; border: 1px solid #3f3f46; border-radius: 8px;
            padding: 20px; width: 85%; max-width: 320px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.8); transform: translateY(15px); transition: transform 0.3s ease;
        }
        .modal-overlay.open .modal-content { transform: translateY(0); }
        .modal-title {
            color: #fff; font-size: 13px; margin: 0 0 15px 0; padding-bottom: 8px;
            border-bottom: 1px solid #27272a; text-align: center; text-transform: uppercase;
        }
        .guide-item { display: flex; gap: 10px; margin-bottom: 12px; color: #e4e4e7; }
        .guide-icon { font-size: 16px; width: 20px; text-align: center; flex-shrink: 0; }
        .guide-item strong { color: var(--accent); display: block; margin-bottom: 2px; font-size: 11px; }
        .guide-item p { margin: 0; font-size: 10px; color: #a1a1aa; line-height: 1.3; }
        .modal-close-btn {
            width: 100%; padding: 8px; background: var(--accent); color: white;
            border: none; border-radius: 4px; font-weight: bold; cursor: pointer;
            margin-top: 5px; font-size: 10px; text-transform: uppercase;
        }

        /* FOOTER */
        footer {
            height: 25px; background: #000; border-top: 1px solid var(--border);
            display: flex; align-items: center; justify-content: center;
            font-size: 9px; color: #52525b; font-weight: 500; letter-spacing: 0.5px;
            flex-shrink: 0; z-index: 60; padding: 0;
        }
        .footer-link { display: flex; align-items: center; justify-content: center; gap: 6px; color: #52525b; text-decoration: none; width: 100%; height: 100%; }
        .footer-link:hover { color: var(--accent); }
        .footer-icon { width: 10px; height: 10px; fill: currentColor; }

        /* MOBILE RESPONSIVE */
        @media (max-width: 768px) {
            header { height: 40px; padding: 0 8px; }
            h1 { font-size: 11px; }
            #main-layout { display: block; position: relative; height: calc(100vh - 40px - 25px); }
            #viewport { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
            #controles {
                position: absolute; bottom: 0; left: 0; width: 100%; height: 45%; max-height: 350px;
                box-sizing: border-box; border-right: none; border-top: 1px solid var(--border);
                z-index: 20; background: rgba(8, 8, 10, 0.85); padding-bottom: 20px;
            }
            .hud-panel { top: 5px; left: 5px; width: 110px; padding: 6px; }
        }
    </style>
<link rel="stylesheet" href="/index.css">
</head>
<body>

    <header>
        <div class="brand-area">
            <a href="https://www.instagram.com/3d_mc_3d/" target="_blank" title="Visitar Instagram de MC" class="brand-link">
                <img src="https://raw.githubusercontent.com/MauroCasarin/SONIDO/refs/heads/main/MC%2048%20N.png" alt="MC Logo" class="logo-img">
            </a>
            <h1>
                SIMULADOR
                <span>SONIDOS GRAVES</span>
            </h1>
        </div>
    </header>

    <div id="tooltip" class="custom-tooltip"></div>

    <div id="modal-guide" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-title">Gu√≠a T√©cnica</h3>
            <div class="guide-item">
                <span class="guide-icon">‚ö°</span>
                <div><strong>Suma Total (+6dB)</strong><p>Separa a <strong>Œª/4</strong> (ej: 1.07m @ 80Hz). Suma frontal.</p></div>
            </div>
            <div class="guide-item">
                <span class="guide-icon">üéØ</span>
                <div><strong>Directividad</strong><p>Separa a <strong>Œª/2</strong> (ej: 2.14m @ 80Hz). Rechazo lateral.</p></div>
            </div>
            <div class="guide-item">
                <span class="guide-icon">üåä</span>
                <div><strong>Fase</strong><p>Alinea las ondas (Cian/Magenta) usando Auto-Focus para sumar en el micro.</p></div>
            </div>
            <button class="modal-close-btn" onclick="app.toggleGuide()">Cerrar</button>
        </div>
    </div>

    <div id="main-layout">
        
        <div id="viewport">
            <canvas id="simCanvas" width="800" height="600" data-tooltip="Visor de Predicci√≥n: Colores c√°lidos = mayor presi√≥n sonora. Arrastra el micr√≥fono para medir."></canvas>
            
            <div id="hud-panel" class="hud-panel">
                <div class="hud-row"><span class="hud-label">Longitud Onda:</span><span class="hud-value" id="hud-lambda">--</span></div>
                <div class="hud-row"><span class="hud-label">Estado:</span><span class="hud-value" id="hud-status">--</span></div>
                <div class="hud-row" id="row-delay"><span class="hud-label">Delay E.F.:</span><span class="hud-value" id="hud-delay" style="color:var(--warning)">--</span></div>
            </div>
        </div>

        <div id="controles">
            <!-- Top Controls -->
            <div class="controls-top-bar">
                <button id="btn-play" class="vp-btn paused" onclick="app.togglePlay()" title="Play/Pausa">‚ñ∂</button>
                <button class="btn-help-main" onclick="app.toggleGuide()" title="Gu√≠a T√©cnica">?</button>
            </div>

            <!-- Global Params -->
            <div class="control-group">
                <div class="group-title">FUENTE (UPWARD)</div>
                <div class="slider-row" data-tooltip="<strong>FRECUENCIA</strong><br>Define la longitud de onda. 80Hz es ideal para subgraves est√°ndar.">
                    <div class="slider-label"><span>Freq</span><span class="slider-val" id="disp-freq">80 Hz</span></div>
                    <input type="range" id="input-freq" min="20" max="200" value="80">
                </div>
                <div class="slider-row" id="row-count" data-tooltip="<strong>CANTIDAD</strong><br>N√∫mero total de bafles por arreglo (Max 8).">
                    <div class="slider-label"><span>Bafles (N)</span><span class="slider-val" id="disp-count">2</span></div>
                    <input type="range" id="input-count" min="1" max="8" step="1" value="2">
                </div>
                <!-- DISPERSION CONTROL -->
                <div class="slider-row" data-tooltip="<strong>COBERTURA</strong><br>√Ångulo de dispersi√≥n (10¬∞ a 180¬∞). Controla el haz hacia arriba.">
                    <div class="slider-label"><span>Cobertura</span><span class="slider-val" id="disp-angle">90¬∞</span></div>
                    <input type="range" id="input-angle" min="10" max="180" value="90">
                </div>

                <div class="slider-row" id="row-dist" data-tooltip="<strong>SEPARACI√ìN</strong><br>Distancia entre centros ac√∫sticos. Afecta directamente la interacci√≥n de fase.">
                    <div class="slider-label"><span>Separaci√≥n</span><span class="slider-val" id="disp-dist">1.07 m</span></div>
                    <input type="range" id="input-dist" min="0.2" max="4.0" step="0.01" value="1.07">
                    <div class="btn-row" style="margin-top:2px;">
                        <button class="small-btn" style="flex:1" onclick="app.setLambdaFraction(0.25)" data-tooltip="<strong>PRESET Œª/4</strong><br>Suma perfecta frontal (+6dB). Poca directividad.">Œª/4 (Max)</button>
                        <button class="small-btn" style="flex:1" onclick="app.setLambdaFraction(0.5)" data-tooltip="<strong>PRESET Œª/2</strong><br>M√°xima cancelaci√≥n lateral. Arreglo m√°s directivo.">Œª/2 (Dir)</button>
                    </div>
                </div>
            </div>

            <!-- Configuration -->
            <div class="control-group">
                <div class="group-title">CONFIGURACI√ìN</div>
                <div class="btn-row">
                    <button id="btn-broad" class="active" style="flex:1" onclick="app.setMode('broadside')" data-tooltip="<strong>BROADSIDE</strong><br>L√≠nea de fuentes. Cobertura ancha.">BROADSIDE</button>
                    <button id="btn-end" style="flex:1" onclick="app.setMode('endfire')" data-tooltip="<strong>END-FIRE</strong><br>Fuentes en l√≠nea de tiro. M√°xima direccionalidad y rechazo trasero.">END-FIRE</button>
                </div>
                <button id="btn-lr" style="width:100%; margin-top:4px;" onclick="app.toggleLR()" data-tooltip="<strong>L/R STEREO</strong><br>Divide el arreglo en dos clusters separados (Izquierda/Derecha).">MODO: MONO CENTRAL</button>
                <div class="slider-row" style="margin-top:4px" data-tooltip="<strong>SEPARACI√ìN L/R</strong><br>Distancia desde el centro del escenario a cada cluster.">
                    <div class="slider-label"><span>Margen L/R</span><span class="slider-val" id="disp-lat-margin">0.5 m</span></div>
                    <input type="range" id="input-lat-margin" min="0" max="5.0" step="0.1" value="0.5">
                </div>
                <div class="btn-row" style="margin-top:4px;">
                    <button class="danger" style="flex:1" onclick="app.setupCardioid()" data-tooltip="<strong>CARDIOIDE CSA</strong><br>Configuraci√≥n de 3 cajas (2 frente, 1 invertida atr√°s) para cancelar sonido trasero.">CARDIOIDE CSA</button>
                </div>
            </div>

            <!-- Optimization -->
            <div class="control-group">
                <div class="group-title">MIC & OPTIMIZACI√ìN</div>
                <button class="magic" style="width:100%; padding:6px;" onclick="app.autoOptimize()" data-tooltip="<strong>AUTO-FOCUS</strong><br>Calcula delays electr√≥nicos para alinear la llegada de se√±al al micr√≥fono.">‚ú® AUTO-FOCUS (FASE)</button>
                <div id="opt-status" style="display:none; text-align:center; color:#a3e635; font-size:9px; margin-top:2px; font-weight:bold;">OPTIMIZADO</div>
            </div>

            <!-- Stage Control -->
            <div class="control-group">
                <div class="group-title">ESCENARIO (REFLECTOR -18dB)</div>
                <!-- Removed Stage Width -->
                <div class="slider-row" data-tooltip="<strong>GAP</strong><br>Distancia entre bafles y pared trasera.">
                    <div class="slider-label"><span>Distancia Pared</span><span class="slider-val" id="disp-stg-gap" style="color:var(--warning)">--</span></div>
                    <input type="range" id="input-stg-gap" min="0" max="10" step="0.1" value="1.0">
                </div>
            </div>

            <!-- Polarity -->
            <div class="control-group">
                <div class="group-title">POLARIDAD (INVERTIR)</div>
                <div id="polarity-container" class="polarity-grid" data-tooltip="<strong>POLARIDAD</strong><br>Toca un n√∫mero para invertir la polaridad (180¬∞) de esa caja espec√≠fica. Rojo = Invertido."></div>
            </div>
        </div>

    </div>

    <footer>
        <a href="https://www.instagram.com/3d_mc_3d/" target="_blank" class="footer-link">
            <svg class="footer-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/></svg>
            <span>Creado por Mauro Casarin</span>
        </a>
    </footer>

    <script>
        // Define app globally immediately to avoid reference errors in HTML
        window.app = {
            togglePlay: () => {}, toggleGuide: () => {}, setMode: () => {}, 
            toggleLR: () => {}, togglePolarity: () => {}, setLambdaFraction: () => {},
            setupCardioid: () => {}, autoOptimize: () => {}, addZone: () => {}, clearZones: () => {}
        };

        window.onload = function() {
            
            const SPEED_OF_SOUND = 343;

            const state = {
                freq: 80, dist: 1.07, count: 2, angle: 90,
                mode: 'broadside', lrMode: false,     
                stageGap: 1.0, lateralMargin: 0.5, 
                polarities: new Array(16).fill(false),
                isOptimized: false, 
                customPhases: [],   
                sourceDelays: [], // Stores delay in MS for visualization
                viewGain: 1.0, isFullscreen: false, isGuideOpen: false, 
                isPlaying: false, 
                time: 0,
                // View: Sources at y=0 (Center of Physics World).
                // Canvas Center is (cx, cy).
                // Offset y=150 moves the logical (0,0) down by 150px, putting sources at the bottom.
                // We want sources in MIDDLE of vertical screen.
                view: { scale: 30, x: 0, y: 0, dragging: false, lastX: 0, lastY: 0, dragType: null, dragIndex: -1 },
                mic: { x: 0, y: -4 }, // 4 meters UP
                // Physics geometry: Upward propagation (-Y).
                // Wall is at Bottom (+Y) relative to sources.
                stage: { w: 10, h: 4, x: 0, y: 4 }
            };

            const els = {
                canvas: document.getElementById('simCanvas'),
                controls: document.getElementById('controles'),
                hudPanel: document.getElementById('hud-panel'),
                tooltip: document.getElementById('tooltip'),
                inputs: {
                    freq: document.getElementById('input-freq'), dist: document.getElementById('input-dist'),
                    count: document.getElementById('input-count'), angle: document.getElementById('input-angle'),
                    // stgW: document.getElementById('input-stg-w'),
                    stgGap: document.getElementById('input-stg-gap'), latMargin: document.getElementById('input-lat-margin')
                },
                displays: {
                    freq: document.getElementById('disp-freq'), dist: document.getElementById('disp-dist'),
                    count: document.getElementById('disp-count'), angle: document.getElementById('disp-angle'),
                    // stgW: document.getElementById('disp-stg-w'),
                    stgGap: document.getElementById('disp-stg-gap'), latMargin: document.getElementById('disp-lat-margin')
                },
                rows: { dist: document.getElementById('row-dist') },
                hud: {
                    lambda: document.getElementById('hud-lambda'), status: document.getElementById('hud-status'),
                    delay: document.getElementById('hud-delay'), delayRow: document.getElementById('row-delay')
                },
                btns: {
                    broad: document.getElementById('btn-broad'), end: document.getElementById('btn-end'),
                    lr: document.getElementById('btn-lr'), play: document.getElementById('btn-play')
                },
                polContainer: document.getElementById('polarity-container'),
                optStatus: document.getElementById('opt-status'),
                modalGuide: document.getElementById('modal-guide')
            };

            const ctx = els.canvas.getContext('2d', { alpha: false });
            ctx.imageSmoothingEnabled = true;

            // Implement Global App Methods
            window.app.setMode = (m) => {
                state.mode = m; state.isOptimized = false; resetGain();
                els.optStatus.style.display = 'none';
                els.btns.broad.className = m === 'broadside' ? 'active' : '';
                els.btns.end.className = m === 'endfire' ? 'active' : '';
                updateUI(); 
            };
            window.app.toggleLR = () => {
                state.lrMode = !state.lrMode; state.isOptimized = false; resetGain();
                els.optStatus.style.display = 'none';
                els.btns.lr.innerText = state.lrMode ? "MODO: STEREO L/R" : "MODO: MONO CENTRAL";
                els.btns.lr.className = state.lrMode ? 'active' : '';
                updateUI(); 
            };
            window.app.togglePolarity = (i) => {
                state.polarities[i] = !state.polarities[i];
                renderPolarityGrid(); 
            };
            window.app.togglePlay = () => {
                state.isPlaying = !state.isPlaying;
                els.btns.play.innerHTML = state.isPlaying ? '‚ùö‚ùö' : '‚ñ∂';
                els.btns.play.className = state.isPlaying ? 'vp-btn' : 'vp-btn paused';
            };
            window.app.toggleGuide = () => {
                state.isGuideOpen = !state.isGuideOpen;
                els.modalGuide.classList.toggle('open', state.isGuideOpen);
            };
            window.app.setLambdaFraction = (frac) => {
                const c = SPEED_OF_SOUND;
                let optimal = (c / state.freq) * frac;
                optimal = Math.min(4.0, Math.max(0.2, optimal));
                state.dist = optimal; els.inputs.dist.value = optimal;
                state.isOptimized = false; els.optStatus.style.display = 'none';
                updateUI(); 
            };
            window.app.applyPreset = (hz) => {
                state.freq = hz; state.isOptimized = false; resetGain();
                els.optStatus.style.display = 'none'; els.inputs.freq.value = hz;
                const v = SPEED_OF_SOUND;
                let optimal = (v / hz) / 4;
                optimal = Math.min(4.0, Math.max(0.2, optimal));
                state.dist = optimal; els.inputs.dist.value = optimal;
                updateUI(); 
            };
            window.app.setupCardioid = () => {
                state.count = 2; els.inputs.count.value = 2;
                window.app.setMode('endfire'); state.polarities.fill(false);
                state.polarities[0] = true; window.app.applyPreset(state.freq);
            };
            window.app.autoOptimize = () => {
                const c = SPEED_OF_SOUND;
                const k = (2 * Math.PI * state.freq) / c; 
                const tempSources = generateSourcesForLogic();
                
                // Calculate physical distance from each source to mic
                const dists = tempSources.map(s => Math.hypot(state.mic.x - s.x, state.mic.y - s.y));
                
                // Find the source that is furthest away. All others must be delayed to match it.
                // In standard audio alignment, we delay the closest sources to wait for the furthest one.
                const maxDist = Math.max(...dists);
                
                state.sourceDelays = dists.map(d => {
                    const diffMeters = maxDist - d;
                    return (diffMeters / c) * 1000; // ms
                });
                
                // Apply phase shift based on calculated time delay
                state.customPhases = state.sourceDelays.map(ms => {
                    const seconds = ms / 1000;
                    return -k * (seconds * c); // phase shift
                });
                
                state.isOptimized = true; 
                els.optStatus.style.display = 'block';
                resetGain(); updateUI(); 
            };
            window.app.addZone = () => {};
            window.app.clearZones = () => {};

            function resetGain() { state.viewGain = 1.0; }

            function getPointerPos(e) {
                const rect = els.canvas.getBoundingClientRect();
                let clientX, clientY;
                if (e.changedTouches && e.changedTouches.length > 0) {
                    clientX = e.changedTouches[0].clientX;
                    clientY = e.changedTouches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                return { x: clientX - rect.left, y: clientY - rect.top, clientX, clientY };
            }

            // --- SMART TOOLTIPS ---
            let tooltipTimer = null;
            const TOOLTIP_DELAY = 2000; 

            function showTooltip(target) {
                const text = target.getAttribute('data-tooltip');
                if (!text) return;
                els.tooltip.innerHTML = text;
                const rect = target.getBoundingClientRect();
                let top = rect.top - 40; let left = rect.left + 10;
                if (left + 200 > window.innerWidth) left = window.innerWidth - 210;
                if (top < 10) top = rect.bottom + 10;
                els.tooltip.style.left = left + 'px'; els.tooltip.style.top = top + 'px';
                els.tooltip.style.display = 'block';
                requestAnimationFrame(() => els.tooltip.classList.add('visible'));
            }

            function hideTooltip() {
                els.tooltip.classList.remove('visible');
                setTimeout(() => {
                    if (!els.tooltip.classList.contains('visible')) els.tooltip.style.display = 'none';
                }, 400);
            }

            function forceHideTooltip() {
                clearTimeout(tooltipTimer);
                hideTooltip();
            }
            window.addEventListener('mousedown', forceHideTooltip);
            window.addEventListener('touchstart', forceHideTooltip, {passive: true});
            window.addEventListener('input', forceHideTooltip); 
            window.addEventListener('scroll', forceHideTooltip); 

            document.addEventListener('mouseover', e => {
                const target = e.target.closest('[data-tooltip]');
                if (target) {
                    clearTimeout(tooltipTimer);
                    tooltipTimer = setTimeout(() => showTooltip(target), TOOLTIP_DELAY);
                }
            });
            document.addEventListener('mouseout', e => {
                const target = e.target.closest('[data-tooltip]');
                if (target) { clearTimeout(tooltipTimer); hideTooltip(); }
            });
            document.addEventListener('touchstart', e => {
                const target = e.target.closest('[data-tooltip]');
                if (target) {
                    clearTimeout(tooltipTimer);
                    tooltipTimer = setTimeout(() => {
                        const text = target.getAttribute('data-tooltip');
                        if(text) {
                            els.tooltip.innerHTML = text; els.tooltip.style.display = 'block';
                            els.tooltip.style.left = '50%'; els.tooltip.style.top = '20%';
                            els.tooltip.style.transform = 'translate(-50%, 0)';
                            requestAnimationFrame(() => els.tooltip.classList.add('visible'));
                        }
                    }, TOOLTIP_DELAY);
                }
            }, {passive: true});
            

            // --- INPUT HANDLERS ---
            function setControlsTransparent() { els.controls.classList.add('controls-hidden'); }
            function removeControlsTransparent() { els.controls.classList.remove('controls-hidden'); }

            const interactiveElements = els.controls.querySelectorAll('input, button');
            interactiveElements.forEach(el => {
                el.addEventListener('mousedown', setControlsTransparent);
                el.addEventListener('touchstart', setControlsTransparent, {passive: true});
                el.addEventListener('mouseup', removeControlsTransparent);
                el.addEventListener('touchend', removeControlsTransparent);
                el.addEventListener('mouseleave', removeControlsTransparent);
            });

            Object.keys(els.inputs).forEach(key => {
                if(!els.inputs[key]) return;
                const input = els.inputs[key];
                input.addEventListener('change', removeControlsTransparent);
                input.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    if (key === 'stgW') state.stage.w = val;
                    else if (key === 'stgGap') state.stageGap = val;
                    else if (key === 'latMargin') state.lateralMargin = val;
                    else state[key] = val;
                    
                    if (['freq', 'dist', 'stgGap', 'latMargin', 'count', 'angle'].includes(key)) {
                         if(state.isOptimized) { state.isOptimized = false; els.optStatus.style.display = 'none'; resetGain(); }
                         if(key === 'count') resetGain();
                    }
                    updateUI(); 
                });
            });

            function handleStart(e) {
                if(e.type === 'touchstart') e.preventDefault();
                setControlsTransparent(); els.hudPanel.style.opacity = '0.2';
                forceHideTooltip(); 
                
                const pos = getPointerPos(e);
                const cx = els.canvas.width / 2 + state.view.x;
                const cy = els.canvas.height / 2 + state.view.y;
                const ppm = state.view.scale;
                const toScreen = (mx, my) => ({ x: cx + mx * ppm, y: cy + my * ppm });
                const ms = toScreen(state.mic.x, state.mic.y);
                
                if (Math.hypot(pos.x - ms.x, pos.y - ms.y) < 50) {
                    state.view.dragType = 'mic'; state.view.dragging = true;
                    state.view.lastX = pos.clientX; state.view.lastY = pos.clientY;
                    return;
                }
                
                state.view.dragType = 'view';
                state.view.dragging = true; state.view.lastX = pos.clientX; state.view.lastY = pos.clientY;
            }

            function handleMove(e) {
                if(state.view.dragging) {
                    e.preventDefault(); 
                    const pos = getPointerPos(e);
                    const dxPix = pos.clientX - state.view.lastX;
                    const dyPix = pos.clientY - state.view.lastY;
                    const dxM = dxPix / state.view.scale;
                    const dyM = dyPix / state.view.scale;

                    if (state.view.dragType === 'view') { state.view.x += dxPix; state.view.y += dyPix; } 
                    else if (state.view.dragType === 'mic') {
                        state.mic.x += dxM; state.mic.y += dyM;
                    }
                    state.view.lastX = pos.clientX; state.view.lastY = pos.clientY;
                }
            }

            function handleEnd(e) {
                state.view.dragging = false; state.view.dragType = null;
                removeControlsTransparent(); els.hudPanel.style.opacity = '1';
            }

            els.canvas.addEventListener('mousedown', handleStart);
            window.addEventListener('mousemove', handleMove);
            window.addEventListener('mouseup', handleEnd);
            els.canvas.addEventListener('touchstart', handleStart, {passive: false});
            window.addEventListener('touchmove', handleMove, {passive: false});
            window.addEventListener('touchend', handleEnd);
            els.canvas.addEventListener('wheel', e => {
                e.preventDefault();
                const factor = e.deltaY > 0 ? 0.9 : 1.1;
                state.view.scale *= factor; state.view.scale = Math.max(5, Math.min(100, state.view.scale));
            });
            window.addEventListener('resize', handleResize);

            function handleResize() {
                const parent = els.canvas.parentElement;
                if(parent.clientWidth > 0 && parent.clientHeight > 0) {
                    els.canvas.width = parent.clientWidth;
                    els.canvas.height = parent.clientHeight;
                }
            }

            function updateUI() {
                els.displays.freq.innerText = state.freq + ' Hz';
                els.displays.dist.innerText = state.dist.toFixed(2) + ' m';
                els.displays.count.innerText = state.count;
                els.displays.angle.innerText = state.angle + '¬∞';
                // els.displays.stgW.innerText = state.stage.w.toFixed(1) + ' m';
                els.displays.stgGap.innerText = state.stageGap.toFixed(2) + ' m';
                els.displays.latMargin.innerText = state.lateralMargin.toFixed(1) + ' m';
                if (state.count === 1) els.rows.dist.classList.add('disabled');
                else els.rows.dist.classList.remove('disabled');
                const c = SPEED_OF_SOUND;
                const lambda = c / state.freq;
                const delay = (state.dist / c) * 1000;
                els.hud.lambda.innerText = lambda.toFixed(2) + ' m';
                const limit = (2/3) * lambda; const optimal = lambda / 4; 
                if (state.dist > limit && state.count > 1) {
                    els.hud.status.innerText = "ALIASING"; els.hud.status.className = "hud-value status-danger";
                } else if (Math.abs(state.dist - optimal) < optimal * 0.15 && state.count > 1) {
                    els.hud.status.innerText = "OPTIMO Œª/4"; els.hud.status.className = "hud-value status-ok";
                } else {
                    els.hud.status.innerText = state.count === 1 ? "PUNTUAL" : "ESTANDAR";
                    els.hud.status.className = "hud-value";
                }
                if (state.mode === 'endfire' && state.count > 1) {
                    els.hud.delayRow.style.display = 'flex'; els.hud.delay.innerText = delay.toFixed(2) + ' ms';
                } else els.hud.delayRow.style.display = 'none';
                renderPolarityGrid();
            }

            function renderPolarityGrid() {
                els.polContainer.innerHTML = '';
                for(let i=0; i<state.count; i++) {
                    const btn = document.createElement('div');
                    const inv = state.polarities[i];
                    btn.className = inv ? 'pol-btn inverted' : 'pol-btn normal';
                    btn.innerHTML = `<span>${i+1}</span><span>${inv ? 'INV' : 'NOR'}</span>`;
                    btn.onclick = () => window.app.togglePolarity(i);
                    els.polContainer.appendChild(btn);
                }
            }

            function generateSourcesForLogic() {
                // PHYSICS COORDINATE SYSTEM: 
                // Wall is at Y = state.stage.y (e.g. 4m down from center).
                // Sound goes UP (-Y).
                // Sources are in front of wall.
                // The logical "Wall Y" is determined by stage gap.
                // Let's assume sources are at y=0 for logic, and Wall is at +gap.
                // NOTE: Visualization logic centers view at (0,0).
                
                const srcY = 0; 
                
                const c = SPEED_OF_SOUND;
                const k = (2 * Math.PI * state.freq) / c;
                const sources = [];
                let xOffsets = [state.stage.x];
                if (state.lrMode) {
                    const halfW = state.stage.w / 2;
                    const offset = halfW + state.lateralMargin;
                    xOffsets = [state.stage.x - offset, state.stage.x + offset];
                }
                xOffsets.forEach(xOff => {
                    if (state.mode === 'broadside') {
                        const totalW = (state.count - 1) * state.dist; const startX = xOff - totalW / 2;
                        const arrLeft = startX + state.dist / 2; 
                        for(let i=0; i<state.count; i++) {
                            sources.push({ x: startX + (i * state.dist), y: srcY, phase: 0, inv: state.polarities[i] });
                        }
                    } else {
                        // Endfire: Stacked vertically.
                        // For Upward propagation (-Y), we usually delay the FRONT source (Top, negative Y) 
                        // to wait for the BACK source (Bottom, positive Y).
                        // Let's standard: i=0 is Back (lowest).
                        for(let i=0; i<state.count; i++) {
                            const yPos = srcY - (i * state.dist); // -Y is Up.
                            // If simple endfire, phase calc is done by dist.
                            // Here we just position them. 
                            sources.push({ x: xOff, y: yPos, phase: 0, inv: state.polarities[i] });
                        }
                    }
                });
                return sources;
            }

            function fillHeatmapColor(db, data, idx) {
                let r=0, g=0, b=0, a=230;
                if (db > 0) {
                     r = 255; g = 255; b = Math.min(255, Math.floor(db * 20)); 
                } else if (db > -6) {
                    const t = (db + 6) / 6; r = 255; g = Math.floor(200 + t * 55); b = 0;
                } else if (db > -12) {
                    const t = (db + 12) / 6; r = 255; g = Math.floor(t * 200); b = 0;
                } else if (db > -24) {
                    const t = (db + 24) / 12; r = Math.floor(t * 255); g = 0; b = Math.floor((1-t) * 255);
                } else if (db > -60) {
                    const t = (db + 60) / 36; r = 0; g = 0; b = Math.floor(t * 255); a = Math.floor(t * 230);
                } else {
                    r=0; g=0; b=0; a=0;
                }
                data[idx] = r; data[idx+1] = g; data[idx+2] = b; data[idx+3] = a;
            }

            function draw() {
                const w = els.canvas.width; const h = els.canvas.height;
                if(w === 0 || h === 0) return; 

                const cx = w/2 + state.view.x; const cy = h/2 + state.view.y;
                const ppm = state.view.scale;
                const c = SPEED_OF_SOUND; 
                const k = (2 * Math.PI * state.freq) / c;
                const timePhase = state.time * 0.5; 
                
                // Angle logic
                const angleRad = state.angle * (Math.PI / 180);
                const halfAngle = angleRad / 2;
                const cosHalfAngle = Math.cos(halfAngle);

                ctx.fillStyle = '#09090b'; ctx.fillRect(0,0,w,h);
                
                // --- GRID ---
                ctx.save(); ctx.beginPath(); ctx.strokeStyle = '#222'; ctx.lineWidth = 1;
                const startX = Math.floor((-cx) / ppm); const endX = Math.ceil((w - cx) / ppm);
                const startY = Math.floor((-cy) / ppm); const endY = Math.ceil((h - cy) / ppm);
                for(let gx=startX; gx<=endX; gx++) { const sx = cx + gx * ppm; ctx.moveTo(sx, 0); ctx.lineTo(sx, h); }
                for(let gy=startY; gy<=endY; gy++) { const sy = cy + gy * ppm; ctx.moveTo(0, sy); ctx.lineTo(w, sy); }
                ctx.stroke(); ctx.restore();

                let sources = generateSourcesForLogic();
                // Apply computed phases for optimization if active
                if (state.isOptimized && state.customPhases.length === sources.length) {
                    sources.forEach((s, i) => { s.phase = state.customPhases[i]; });
                } else if (state.mode === 'endfire') {
                    // Standard Endfire processing if not auto-focused
                     sources.forEach((s, i) => { 
                         // Delay front sources to match back?
                         // In standard endfire, we delay the front sources.
                         // Here sources[0] is bottom (Back).
                         const delayMeters = i * state.dist;
                         s.phase = k * delayMeters;
                     });
                }

                // Stage Wall Logic
                // Wall is at Y = gap (below sources)
                const wallYVal = state.stageGap; 
                const wallPx = cy + wallYVal * ppm;
                
                const gain = state.viewGain; 

                const screenSources = [];
                const virtualSources = [];

                sources.forEach(s => {
                    const sx = cx + s.x * ppm;
                    const sy = cy + s.y * ppm;
                    screenSources.push({ sx, sy, ph: s.phase, inv: s.inv });
                    
                    // Reflection
                    // Wall is at +gap. Source at 0 (approx).
                    // Virtual Source is mirrored below wall.
                    const vY_meters = 2 * wallYVal - s.y;
                    const vSy = cy + vY_meters * ppm; 
                    virtualSources.push({ sx: sx, sy: vSy, ph: s.phase, inv: s.inv });
                });

                const imgData = ctx.getImageData(0, 0, w, h);
                const data = imgData.data;

                // --- PHYSICS ENGINE ---
                // Outer loop Y
                for(let y=0; y<h; y++) { 
                    const rowOff = y * w * 4;
                    
                    // Mask Stage Floor (Everything below wallPx)
                    if (y > wallPx) {
                        for(let x=0; x<w; x++) {
                            const i = rowOff + x*4;
                            data[i] = 10; data[i+1] = 10; data[i+2] = 12; data[i+3] = 255;
                        }
                        continue;
                    }

                    // Physics loop
                    for(let x=0; x<w; x++) {
                        const idx = rowOff + (x * 4);

                        let pSum = 0; 
                        
                        // Direct Sound (Strictly Upward)
                        // dy < 0 means pixel is above source.
                        for(let i=0; i<screenSources.length; i++) {
                            const s = screenSources[i];
                            const dx = x - s.sx; const dy = y - s.sy;
                            
                            // ZERO MIRROR: No sound below source
                            if (dy > 0) continue;

                            const dist = Math.sqrt(dx*dx + dy*dy);
                            const distMeters = dist / ppm;
                            const dClamped = Math.max(0.1, distMeters);
                            
                            // CosTheta = (-dy) / dist
                            const cosTheta = -dy / dist;
                            
                            let dirFactor = 0;
                            if (cosTheta >= cosHalfAngle) {
                                dirFactor = 1.0;
                            } else {
                                const diff = cosHalfAngle - cosTheta;
                                if (diff < 0.1) dirFactor = 1.0 - (diff * 10);
                            }

                            if (dirFactor > 0) {
                                const amp = (1.0 / dClamped) * dirFactor; 
                                const totalPhase = (k * distMeters) - timePhase - s.ph + (s.inv ? Math.PI : 0);
                                pSum += amp * Math.sin(totalPhase);
                            }
                        }

                        // Reflected Sound (Virtual Sources)
                        // Virtual sources emit UP (-Y).
                        // Realistically, subwoofers are omni at 80Hz. 
                        // The "Directivity" control visualizes the forward throw, 
                        // but we simulate leakage/reflection from the "omni" nature hitting the wall.
                        // Or we can say the reflection follows the same beam width?
                        // If we strictly follow beam width and box is aiming up, reflection is 0.
                        // But user wants "Real Reflections". We assume leakage.
                        const leakage = 0.4; 
                        
                        for(let i=0; i<virtualSources.length; i++) {
                            const vs = virtualSources[i];
                            const dx = x - vs.sx; const dy = y - vs.sy;
                            
                            // Virtual emits up
                            if (dy >= 0) continue;

                            const dist = Math.sqrt(dx*dx + dy*dy);
                            const distMeters = dist / ppm;
                            const dClamped = Math.max(0.1, distMeters);
                            
                            const amp = (1.0 / dClamped) * leakage; 
                            const totalPhase = (k * distMeters) - timePhase - vs.ph + (vs.inv ? Math.PI : 0);
                            pSum += amp * Math.sin(totalPhase);
                        }
                        
                        const absPressure = Math.abs(pSum) * gain;
                        const db = 20 * Math.log10(absPressure + 0.0000001);
                        fillHeatmapColor(db, data, idx);
                    }
                }
                ctx.putImageData(imgData, 0, 0);

                ctx.save(); ctx.translate(cx, cy); ctx.scale(ppm, ppm);
                
                // Draw Stage Wall
                ctx.strokeStyle = '#52525b'; ctx.lineWidth = 0.05;
                ctx.fillStyle = '#18181b';
                // Infinite floor block
                ctx.fillRect(-200, wallYVal, 400, 20); 
                ctx.beginPath(); ctx.moveTo(-200, wallYVal); ctx.lineTo(200, wallYVal); ctx.stroke();
                
                // Label
                ctx.fillStyle = '#fff'; ctx.font = 'bold 0.5px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
                ctx.fillText("ESCENARIO", 0, wallYVal + 0.5);
                
                // Sources
                sources.forEach((s, i) => {
                    const size = 0.4;
                    ctx.fillStyle = s.inv ? '#ef4444' : '#e4e4e7'; ctx.strokeStyle = '#000';
                    ctx.lineWidth = 0.02; 
                    ctx.beginPath(); ctx.arc(s.x, s.y, size/2, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                    
                    // Draw Beam Indicator
                    ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth = 0.02;
                    ctx.beginPath();
                    ctx.moveTo(s.x, s.y);
                    ctx.lineTo(s.x - Math.sin(halfAngle)*2, s.y - Math.cos(halfAngle)*2);
                    ctx.moveTo(s.x, s.y);
                    ctx.lineTo(s.x + Math.sin(halfAngle)*2, s.y - Math.cos(halfAngle)*2);
                    ctx.stroke();

                    // Delay Labels (Floating Tags)
                    if (state.isOptimized && state.sourceDelays[i] !== undefined) {
                        ctx.save();
                        ctx.translate(s.x, s.y - 0.6); // Above the speaker
                        ctx.scale(0.04, 0.04);
                        ctx.fillStyle = "rgba(0,0,0,0.8)";
                        ctx.beginPath(); ctx.roundRect(-25, -10, 50, 20, 5); ctx.fill();
                        ctx.fillStyle = "#3b82f6"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                        ctx.font = "bold 14px sans-serif";
                        ctx.fillText(state.sourceDelays[i].toFixed(2) + "ms", 0, 0);
                        ctx.restore();
                    }
                });

                // Mic Logic
                let micComplexR = 0; let micComplexI = 0;
                 sources.forEach(s => {
                    // Direct
                    const dx = state.mic.x - s.x; const dy = state.mic.y - s.y;
                    const d = Math.sqrt(dx*dx + dy*dy);
                    
                    const cosTheta = -dy / d;
                    let dirFactor = 0;
                    if (dy < 0 && cosTheta >= cosHalfAngle) dirFactor = 1.0;
                    else if (dy < 0) {
                        const diff = cosHalfAngle - cosTheta;
                        if (diff < 0.1) dirFactor = 1.0 - (diff * 10);
                    }
                    
                    const amp = (1.0/Math.max(0.1, d)) * dirFactor;
                    const phi = (k*d) - s.phase + (s.inv?Math.PI:0);
                    micComplexR += Math.cos(phi)*amp; micComplexI += Math.sin(phi)*amp;

                    // Reflection
                    const vY_meters = 2 * wallYVal - s.y;
                    const rdx = state.mic.x - s.x; const rdy = state.mic.y - vY_meters;
                    const rd = Math.sqrt(rdx*rdx + rdy*rdy);
                    const rAmp = (1.0/Math.max(0.1, rd)) * 0.4; 
                    const rPhi = (k*rd) - s.phase + (s.inv?Math.PI:0);
                    micComplexR += Math.cos(rPhi)*rAmp; micComplexI += Math.sin(rPhi)*rAmp;
                });
                
                const micDistances = sources.map((s,i) => {
                    const d = Math.hypot(state.mic.x - s.x, state.mic.y - s.y);
                    return { id: i+1, d };
                });

                const micMag = Math.sqrt(micComplexR*micComplexR + micComplexI*micComplexI) * gain; 
                const micDB = 20 * Math.log10(micMag + 0.000001);
                
                ctx.translate(state.mic.x, state.mic.y);
                const micColor = micDB > -6 ? '#22c55e' : (micDB < -12 ? '#ef4444' : '#fbbf24');
                ctx.strokeStyle = micColor; ctx.lineWidth = 0.05; ctx.beginPath();
                // Bigger Mic
                ctx.arc(0, 0, 0.8, 0, Math.PI * 2); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(-0.6, 0); ctx.lineTo(0.6, 0); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, -0.6); ctx.lineTo(0, 0.6); ctx.stroke();
                
                ctx.restore();

                const mx = cx + state.mic.x * ppm; const my = cy + state.mic.y * ppm;
                
                // --- PHASE ANALYZER (Anchored to Mic) ---
                if (sources.length > 0) {
                    const analyzerW = 100; const analyzerH = 60;
                    const ax = mx + 50; const ay = my - 30; // Offset relative to mic
                    
                    ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.translate(ax, ay);
                    ctx.fillStyle = 'rgba(10, 10, 12, 0.85)'; ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                    ctx.lineWidth = 1; ctx.beginPath(); ctx.roundRect(0, 0, analyzerW, analyzerH, 4); ctx.fill(); ctx.stroke();
                    
                    const s1 = sources[0]; const s2 = sources.length > 1 ? sources[1] : null;
                    const plotW = analyzerW - 6; const plotH = analyzerH - 6;
                    const plotX = 3; const plotY = 3; const midY = plotY + plotH/2;
                    
                    const getMicSignal = (s) => {
                        const dx = state.mic.x - s.x; const dy = state.mic.y - s.y;
                        const d = Math.sqrt(dx*dx + dy*dy);
                        const cosTheta = -dy/d; 
                        let dir = 0;
                        if (dy < 0 && cosTheta >= cosHalfAngle) dir = 1.0;
                        else if (dy < 0) { const diff = cosHalfAngle - cosTheta; if(diff<0.1) dir=1.0-diff*10; }
                        
                        const amp = (1.0/Math.max(0.1,d)) * dir;
                        const ph = (k * d) - s.phase + (s.inv ? Math.PI : 0);
                        return { amp, ph };
                    };

                    const d1 = getMicSignal(s1); const d2 = s2 ? getMicSignal(s2) : { amp: 0, ph: 0 };
                    const maxAmp = Math.max(d1.amp, d2.amp, 0.001) * 2.5; const scaleY = (plotH / 2) / maxAmp;
                    
                    ctx.beginPath(); ctx.strokeStyle = '#333'; ctx.moveTo(plotX, midY); ctx.lineTo(plotX + plotW, midY); ctx.stroke();
                    
                    ctx.beginPath(); ctx.strokeStyle = '#06b6d4'; ctx.lineWidth = 1.5;
                    for(let i=0; i<=plotW; i++) { 
                        const t = (i / plotW) * 2 * Math.PI; 
                        const y = d1.amp * Math.sin(t - d1.ph - timePhase); 
                        ctx.lineTo(plotX + i, midY - y * scaleY); 
                    } 
                    ctx.stroke();

                    if (s2) {
                        ctx.beginPath(); ctx.strokeStyle = '#d946ef'; ctx.lineWidth = 1.5;
                        for(let i=0; i<=plotW; i++) { 
                            const t = (i / plotW) * 2 * Math.PI; 
                            const y = d2.amp * Math.sin(t - d2.ph - timePhase); 
                            ctx.lineTo(plotX + i, midY - y * scaleY); 
                        } 
                        ctx.stroke();
                        
                        ctx.beginPath(); ctx.strokeStyle = 'rgba(255,255,255,0.8)'; ctx.setLineDash([2, 2]); ctx.lineWidth = 1;
                        for(let i=0; i<=plotW; i++) { 
                            const t = (i / plotW) * 2 * Math.PI; 
                            const y1 = d1.amp * Math.sin(t - d1.ph - timePhase); 
                            const y2 = d2.amp * Math.sin(t - d2.ph - timePhase); 
                            ctx.lineTo(plotX + i, midY - (y1 + y2) * scaleY); 
                        } 
                        ctx.stroke(); ctx.setLineDash([]);
                    }
                    ctx.restore();
                }

                // --- DISTANCE LABELS ---
                ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.font = 'bold 10px monospace'; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
                ctx.shadowColor = "black"; ctx.shadowBlur = 4;
                
                let distText = "";
                if(micDistances.length > 0) distText += `D1:${micDistances[0].d.toFixed(2)}m`;
                if(micDistances.length > 1) distText += ` D2:${micDistances[1].d.toFixed(2)}m`;
                
                ctx.fillStyle = '#fff';
                ctx.fillText(distText, mx, my + 40); 
                
                ctx.restore();
            }

            function animate() {
                if(state.isPlaying) {
                    state.time += 0.2;
                }
                draw(); 
                requestAnimationFrame(animate);
            }

            resetGain(); handleResize(); updateUI();
            animate(); 
        };
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>