<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Simulador Educativo sonidos graves - MC Audio</title>
    <style>
        :root {
            --bg-dark: #09090b; /* Zinc 950 */
            --bg-panel: rgba(10, 10, 12, 1.0); /* 100% Opaque initially */
            --border: rgba(255, 255, 255, 0.1);
            --accent: #3b82f6;   /* Blue 500 */
            --accent-glow: rgba(59, 130, 246, 0.3);
            --text-main: #e4e4e7;
            --text-dim: #a1a1aa;
            --danger: #ef4444;
            --success: #22c55e;
            --warning: #f59e0b;
        }

        body {
            background-color: var(--bg-dark);
            color: var(--text-main);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior: none;
        }

        /* HEADER */
        header {
            height: 40px; 
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
            background: rgba(5,5,5,0.95);
            backdrop-filter: blur(5px);
            flex-shrink: 0;
            z-index: 50;
        }

        .brand-area {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .brand-link {
            text-decoration: none;
            display: flex;
            align-items: center;
        }

        .logo-img {
            height: 28px;
            width: auto;
            transition: transform 0.2s;
            cursor: pointer;
        }
        
        h1 {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 0;
            color: #fff;
            display: flex;
            flex-direction: column;
            line-height: 1;
        }

        h1 span {
            font-size: 8px;
            color: var(--accent);
            letter-spacing: 1px;
        }

        /* LAYOUT */
        #main-layout {
            display: flex;
            flex: 1;
            height: calc(100vh - 40px - 25px); 
            overflow: hidden;
            position: relative;
        }

        /* SIDEBAR (CONTROLES) */
        #controles {
            width: 280px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow-y: auto;
            flex-shrink: 0;
            z-index: 20;
            overscroll-behavior: contain;
            transition: opacity 0.2s ease;
        }

        /* Top Controls Bar */
        .controls-top-bar {
            display: flex;
            gap: 5px;
            margin-bottom: 5px;
        }
        
        .controls-top-bar button {
            flex: 1;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        /* Animation for Play Button when Paused */
        @keyframes pulse-glow {
            0% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.0); transform: scale(1); border-color: rgba(80, 80, 90, 0.5); }
            50% { box-shadow: 0 0 12px 2px rgba(59, 130, 246, 0.4); transform: scale(1.02); border-color: var(--accent); color: #fff; text-shadow: 0 0 8px var(--accent); }
            100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.0); transform: scale(1); border-color: rgba(80, 80, 90, 0.5); }
        }

        .vp-btn.paused {
            animation: pulse-glow 2.5s infinite;
        }

        /* CLASE PARA AUTO-OCULTAR (70% OPACIDAD) */
        .controls-dimmed {
            opacity: 0.7 !important;
            pointer-events: none; /* Prevent interaction while dragging canvas */
        }

        /* CANVAS AREA */
        #viewport {
            flex: 1;
            position: relative;
            background: #000;
            overflow: hidden;
            cursor: crosshair;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        canvas {
            display: block;
            touch-action: none;
            /* SUAVIZADO VISUAL */
            filter: blur(0.5px) contrast(1.1); 
            image-rendering: optimizeQuality;
        }

        .btn-help-main {
            border-radius: 4px;
            font-weight: bold;
            font-size: 14px;
        }

        /* CUSTOM TOOLTIP (ANIMATED & DELAYED) */
        .custom-tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 11px;
            pointer-events: none;
            z-index: 1000;
            max-width: 220px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.6);
            text-align: left;
            line-height: 1.4;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.4s ease, transform 0.4s ease;
        }
        
        .custom-tooltip.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .custom-tooltip strong {
            display: block;
            color: var(--accent);
            margin-bottom: 3px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* UI ELEMENTS */
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            background: rgba(255,255,255,0.03);
            padding: 8px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.05);
        }

        .group-title {
            font-size: 8px;
            font-weight: 700;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 2px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .slider-row { margin-bottom: 2px; }
        .slider-row.disabled { opacity: 0.3; pointer-events: none; }
        .slider-label {
            display: flex; justify-content: space-between; font-size: 9px;
            color: var(--text-dim); margin-bottom: 1px;
        }
        .slider-val { color: var(--accent); font-family: monospace; font-weight: bold; }

        input[type=range] {
            -webkit-appearance: none; width: 100%; background: transparent; padding: 4px 0; margin: 0;
        }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 14px; width: 14px;
            border-radius: 50%; background: #e4e4e7; cursor: pointer;
            margin-top: -6px; box-shadow: 0 1px 3px rgba(0,0,0,0.8); border: 1px solid #000;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 2px; cursor: pointer;
            background: rgba(255, 255, 255, 0.2); border-radius: 1px;
        }

        .btn-row { display: flex; gap: 4px; }
        
        button {
            background: rgba(30, 30, 35, 0.9);
            border: 1px solid rgba(80, 80, 90, 0.5);
            color: var(--text-dim);
            padding: 6px; font-size: 9px; font-weight: 600;
            border-radius: 3px; cursor: pointer; transition: all 0.2s; text-transform: uppercase;
        }
        button:hover { background: rgba(60, 60, 70, 0.9); color: #fff; }
        button.active { background: var(--accent); color: #fff; border-color: var(--accent); box-shadow: 0 0 8px var(--accent-glow); }
        button.danger { color: var(--danger); border-color: rgba(239, 68, 68, 0.3); background: rgba(239, 68, 68, 0.05); }
        button.magic { background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%); color: white; border: none; box-shadow: 0 0 8px rgba(124, 58, 237, 0.3); }
        button.red-magic { background: linear-gradient(135deg, #ef4444 0%, #b91c1c 100%); color: white; border: none; box-shadow: 0 0 8px rgba(239, 68, 68, 0.3); }
        button.small-btn { padding: 4px; font-size: 8px; }

        /* BAFFLE CONTROL GRID */
        .baffle-list {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .baffle-row {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(0,0,0,0.2);
            padding: 4px 6px;
            border-radius: 3px;
            justify-content: space-between;
        }
        .baffle-info {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .baffle-controls {
            display: flex;
            align-items: center;
            gap: 4px;
            flex: 1;
        }
        .baffle-num {
            font-size: 9px;
            color: #a1a1aa;
            width: 12px;
            font-weight: bold;
        }
        .baffle-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 20px;
            font-size: 9px;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 2px;
            cursor: pointer;
            background: rgba(255,255,255,0.05);
            color: #71717a;
            padding: 0 4px;
        }
        .baffle-btn.active {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border-color: #ef4444;
            font-weight: bold;
        }
        .baffle-btn.dir-active {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
            border-color: #3b82f6;
            font-weight: bold;
        }
        /* Delay Slider in Baffle Row */
        .delay-slider-container {
            flex: 1.5;
            display: flex;
            flex-direction: column;
            margin-left: 2px;
        }
        .delay-slider-container input {
            height: 2px;
            margin: 2px 0;
        }
        .delay-val {
            font-size: 8px;
            color: var(--warning);
            text-align: right;
            font-family: monospace;
            line-height: 1;
        }

        /* HUD & OVERLAYS */
        .hud-panel {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0, 0, 0, 0.6); border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(3px); padding: 8px; border-radius: 4px;
            width: 140px; pointer-events: none; z-index: 15; transition: opacity 0.3s;
        }
        .hud-row { display: flex; justify-content: space-between; font-size: 9px; margin-bottom: 3px; font-family: monospace; }
        .hud-label { color: #a1a1aa; }
        .hud-value { color: #fff; font-weight: bold; }
        
        /* MODAL GU√çA */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); backdrop-filter: blur(5px);
            z-index: 200; display: flex; align-items: center; justify-content: center;
            opacity: 0; pointer-events: none; transition: opacity 0.3s ease;
        }
        .modal-overlay.open { opacity: 1; pointer-events: auto; }
        .modal-content {
            background: #18181b; border: 1px solid #3f3f46; border-radius: 8px;
            padding: 20px; width: 85%; max-width: 320px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.8); transform: translateY(15px); transition: transform 0.3s ease;
        }
        .modal-overlay.open .modal-content { transform: translateY(0); }
        .modal-title {
            color: #fff; font-size: 13px; margin: 0 0 15px 0; padding-bottom: 8px;
            border-bottom: 1px solid #27272a; text-align: center; text-transform: uppercase;
        }
        .guide-item { display: flex; gap: 10px; margin-bottom: 12px; color: #e4e4e7; }
        .guide-icon { font-size: 16px; width: 20px; text-align: center; flex-shrink: 0; }
        .guide-item strong { color: var(--accent); display: block; margin-bottom: 2px; font-size: 11px; }
        .guide-item p { margin: 0; font-size: 10px; color: #a1a1aa; line-height: 1.3; }
        
        /* Visual Wave Examples */
        .wave-example {
            height: 35px; width: 100%; background: #000; border: 1px solid #333;
            margin-top: 4px; border-radius: 4px; position: relative; overflow: hidden;
            display: flex; align-items: center; justify-content: center;
        }
        .wave-svg { width: 100%; height: 100%; display: block; }
        
        .modal-close-btn {
            width: 100%; padding: 8px; background: var(--accent); color: white;
            border: none; border-radius: 4px; font-weight: bold; cursor: pointer;
            margin-top: 5px; font-size: 10px; text-transform: uppercase;
        }

        /* FOOTER */
        footer {
            height: 25px; background: #000; border-top: 1px solid var(--border);
            display: flex; align-items: center; justify-content: center;
            font-size: 9px; color: #52525b; font-weight: 500; letter-spacing: 0.5px;
            flex-shrink: 0; z-index: 60; padding: 0;
        }
        .footer-link { display: flex; align-items: center; justify-content: center; gap: 6px; color: #52525b; text-decoration: none; width: 100%; height: 100%; }
        .footer-link:hover { color: var(--accent); }
        .footer-icon { width: 10px; height: 10px; fill: currentColor; }

        /* MOBILE RESPONSIVE */
        @media (max-width: 768px) {
            header { height: 40px; padding: 0 8px; }
            h1 { font-size: 11px; }
            #main-layout { display: block; position: relative; height: calc(100vh - 40px - 25px); }
            #viewport { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
            #controles {
                position: absolute; bottom: 0; left: 0; width: 100%; height: 45%; max-height: 350px;
                box-sizing: border-box; border-right: none; border-top: 1px solid var(--border);
                z-index: 20; background: rgba(8, 8, 10, 0.95); padding-bottom: 20px;
            }
            .hud-panel { top: 5px; left: 5px; width: 110px; padding: 6px; }
        }
    </style>
<link rel="stylesheet" href="/index.css">
</head>
<body>

    <header>
        <div class="brand-area">
            <a href="https://www.instagram.com/3d_mc_3d/" target="_blank" title="Visitar Instagram de MC" class="brand-link">
                <img src="https://raw.githubusercontent.com/MauroCasarin/SONIDO/refs/heads/main/MC%2048%20N.png" alt="MC Logo" class="logo-img">
            </a>
            <h1>
                SIMULADOR
                <span>SONIDOS GRAVES</span>
            </h1>
        </div>
    </header>

    <div id="tooltip" class="custom-tooltip"></div>

    <div id="modal-guide" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-title">Gu√≠a T√©cnica</h3>
            
            <div class="guide-item">
                <span class="guide-icon">üñ±Ô∏è</span>
                <div>
                    <strong>Navegaci√≥n</strong>
                    <p>Haz <b>doble clic</b> en el micr√≥fono para centrarlo horizontalmente. <br>Arrastra los bafles verticalmente para cambiar la separaci√≥n y el delay din√°mico.</p>
                </div>
            </div>

            <div class="guide-item">
                <span class="guide-icon">‚ù§Ô∏è</span>
                <div>
                    <strong>Auto-Cardioid & Delay Din√°mico</strong>
                    <p>Activa CARDIOID para vincular distancia y delay. <br>Al mover los bafles, el sistema recalcula: <b>Delay = Distancia / 344</b> para cancelar el sonido trasero.</p>
                </div>
            </div>

            <div class="guide-item">
                <span class="guide-icon">üìà</span>
                <div>
                    <strong>Interpretaci√≥n de Ondas</strong>
                    <p>Observa el analizador junto al micr√≥fono:</p>
                    <div style="margin-top:5px;">
                        <span style="font-size:9px; color:#22c55e;">Suma Total (Onda Limpia):</span>
                        <div class="wave-example">
                             <svg class="wave-svg" viewBox="0 0 100 30" preserveAspectRatio="none">
                                 <path d="M0 15 Q 12.5 0 25 15 T 50 15 T 75 15 T 100 15" fill="none" stroke="#22c55e" stroke-width="2"/>
                                 <path d="M0 15 H100" stroke="#333" stroke-width="0.5" stroke-dasharray="2"/>
                             </svg>
                        </div>
                    </div>
                    <div style="margin-top:5px;">
                        <span style="font-size:9px; color:#ef4444;">Cancelaci√≥n/Desfase (Plana/Ruido):</span>
                        <div class="wave-example">
                            <svg class="wave-svg" viewBox="0 0 100 30" preserveAspectRatio="none">
                                <path d="M0 15 L 100 15" fill="none" stroke="#ef4444" stroke-width="2" stroke-dasharray="4"/>
                            </svg>
                        </div>
                    </div>
                </div>
            </div>

            <button class="modal-close-btn" onclick="app.toggleGuide()">Cerrar</button>
        </div>
    </div>

    <div id="main-layout">
        
        <div id="viewport">
            <canvas id="simCanvas" width="800" height="600" data-tooltip="Visor de Predicci√≥n: Colores c√°lidos = mayor presi√≥n sonora. Arrastra bafles para ajustar distancia/delay."></canvas>
            
            <div id="hud-panel" class="hud-panel">
                <div class="hud-row"><span class="hud-label">Longitud Onda:</span><span class="hud-value" id="hud-lambda">--</span></div>
                <div class="hud-row"><span class="hud-label">Estado:</span><span class="hud-value" id="hud-status">--</span></div>
                <div class="hud-row" id="row-delay"><span class="hud-label">Delay E.F.:</span><span class="hud-value" id="hud-delay" style="color:var(--warning)">--</span></div>
            </div>
        </div>

        <div id="controles">
            <!-- Top Controls -->
            <div class="controls-top-bar">
                <button id="btn-play" class="vp-btn paused" onclick="app.togglePlay()" title="Play/Pausa">‚ñ∂</button>
                <button class="btn-help-main" onclick="app.toggleGuide()" title="Gu√≠a T√©cnica">?</button>
            </div>

            <!-- Global Params -->
            <div class="control-group">
                <div class="group-title">FUENTE (SUBGRAVES)</div>
                <div class="slider-row" data-tooltip="<strong>FRECUENCIA</strong><br>Define la longitud de onda. 80Hz es ideal para subgraves est√°ndar.">
                    <div class="slider-label"><span>Freq</span><span class="slider-val" id="disp-freq">80 Hz</span></div>
                    <input type="range" id="input-freq" min="20" max="200" value="80">
                </div>
                <div class="slider-row" id="row-count" data-tooltip="<strong>CANTIDAD</strong><br>N√∫mero total de bafles por arreglo (Max 8).">
                    <div class="slider-label"><span>Bafles (N)</span><span class="slider-val" id="disp-count">2</span></div>
                    <input type="range" id="input-count" min="1" max="8" step="1" value="2">
                </div>
                <!-- DISPERSION CONTROL -->
                <div class="slider-row" data-tooltip="<strong>COBERTURA</strong><br>√Ångulo de dispersi√≥n (10¬∞ a 180¬∞). Controla el haz principal.">
                    <div class="slider-label"><span>Cobertura</span><span class="slider-val" id="disp-angle">90¬∞</span></div>
                    <input type="range" id="input-angle" min="10" max="180" value="90">
                </div>

                <div class="slider-row" id="row-dist" data-tooltip="<strong>SEPARACI√ìN F√çSICA</strong><br>Distancia entre centros ac√∫sticos. Arrastra los bafles para cambiar.">
                    <div class="slider-label"><span>Separaci√≥n</span><span class="slider-val" id="disp-dist">1.07 m</span></div>
                    <input type="range" id="input-dist" min="0.2" max="4.0" step="0.01" value="1.07">
                    <div class="btn-row" style="margin-top:2px;">
                        <button class="small-btn" style="flex:1" onclick="app.setLambdaFraction(0.25)" data-tooltip="<strong>PRESET Œª/4</strong><br>Suma perfecta frontal (+6dB).">Œª/4 (Max)</button>
                        <button class="small-btn" style="flex:1" onclick="app.setLambdaFraction(0.5)" data-tooltip="<strong>PRESET Œª/2</strong><br>M√°xima cancelaci√≥n lateral.">Œª/2 (Dir)</button>
                    </div>
                </div>
            </div>

            <!-- Configuration -->
            <div class="control-group">
                <div class="group-title">CONFIGURACI√ìN</div>
                <div class="btn-row">
                    <button id="btn-broad" class="active" style="flex:1" onclick="app.setMode('broadside')" data-tooltip="<strong>BROADSIDE</strong><br>L√≠nea de fuentes. Cobertura ancha.">BROADSIDE</button>
                    <button id="btn-end" style="flex:1" onclick="app.setMode('endfire')" data-tooltip="<strong>END-FIRE</strong><br>Fuentes en l√≠nea de tiro. Rechazo trasero.">END-FIRE</button>
                </div>
                <button id="btn-lr" style="width:100%; margin-top:4px;" onclick="app.toggleLR()" data-tooltip="<strong>L/R STEREO</strong><br>Divide el arreglo en dos clusters (Izquierda/Derecha) espejados.">MODO: MONO CENTRAL</button>
                <div class="slider-row" style="margin-top:4px" data-tooltip="<strong>SEPARACI√ìN L/R</strong><br>Distancia desde el centro (0m = Pegados).">
                    <div class="slider-label"><span>Margen L/R</span><span class="slider-val" id="disp-lat-margin">0.5 m</span></div>
                    <input type="range" id="input-lat-margin" min="0" max="5.0" step="0.1" value="0.5">
                </div>
            </div>

            <!-- Optimization -->
            <div class="control-group">
                <div class="group-title">MIC & OPTIMIZACI√ìN</div>
                <div style="display:flex; gap:4px;">
                    <button class="magic" style="flex:1; padding:6px;" onclick="app.autoOptimize()" data-tooltip="<strong>AUTO-FOCUS</strong><br>Alinea tiempos y fases para el micr√≥fono.">‚ú® FOCUS</button>
                    <button class="red-magic" style="flex:1; padding:6px;" onclick="app.autoCardioid()" data-tooltip="<strong>C√ÅLCULO R√ÅPIDO CARDIOIDE</strong><br>V√≠nculo Din√°mico: Ajusta Delay autom√°ticamente al mover bafles.">‚ù§Ô∏è CARDIOID</button>
                </div>
                <div id="opt-status" style="display:none; text-align:center; color:#a3e635; font-size:9px; margin-top:2px; font-weight:bold;">OPTIMIZADO</div>
            </div>

            <!-- Stage Control -->
            <div class="control-group">
                <div class="group-title">ESCENARIO (REFLECTOR -18dB)</div>
                <div class="slider-row" data-tooltip="<strong>DISTANCIA PARED</strong><br>Profundidad del escenario (4m). Distancia entre bafles y pared trasera.">
                    <div class="slider-label"><span>Dist. Bafles-Escenario</span><span class="slider-val" id="disp-stg-gap" style="color:var(--warning)">--</span></div>
                    <input type="range" id="input-stg-gap" min="0" max="10" step="0.1" value="1.0">
                </div>
            </div>

            <!-- Baffle Control (Polarity & Direction) -->
            <div class="control-group">
                <div class="group-title">CONTROLES POR BAFLE (DELAY BIDIRECCIONAL)</div>
                <div id="baffle-control-list" class="baffle-list" data-tooltip="<strong>CONTROLES INDIVIDUALES</strong><br>√ò: Polaridad. ‚ü≤: Direcci√≥n.<br>Slider: Delay electr√≥nico (ms).">
                    <!-- JS generated rows -->
                </div>
            </div>
        </div>

    </div>

    <footer>
        <a href="https://www.instagram.com/3d_mc_3d/" target="_blank" class="footer-link">
            <svg class="footer-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/></svg>
            <span>Creado por Mauro Casarin</span>
        </a>
    </footer>

    <script>
        window.app = {
            togglePlay: () => {}, toggleGuide: () => {}, setMode: () => {}, 
            toggleLR: () => {}, togglePolarity: () => {}, toggleDirection: () => {},
            setLambdaFraction: () => {}, setupCardioid: () => {}, autoOptimize: () => {}, 
            autoCardioid: () => {}, setDelay: () => {}
        };

        window.onload = function() {
            
            const SPEED_OF_SOUND = 343;

            const state = {
                freq: 80, dist: 1.07, count: 2, angle: 90,
                mode: 'broadside', lrMode: false,     
                stageGap: 1.0, lateralMargin: 0.5, 
                polarities: new Array(16).fill(false),
                directions: new Array(16).fill(false), // false = Up, true = Down
                delays: new Array(16).fill(0), // ms
                isOptimized: false, isCardioidMode: false,
                customPhases: [],   
                sourceDelays: [], // This is now derived from state.delays for rendering
                viewGain: 1.0, isGuideOpen: false, 
                isPlaying: false, 
                time: 0,
                view: { scale: 30, x: 0, y: 0, dragging: false, lastX: 0, lastY: 0, dragType: null, dragIndex: -1 },
                mic: { x: 0, y: -4 },
                stage: { w: 10, h: 4, x: 0, y: 4 }
            };

            const els = {
                canvas: document.getElementById('simCanvas'),
                controls: document.getElementById('controles'),
                hudPanel: document.getElementById('hud-panel'),
                tooltip: document.getElementById('tooltip'),
                inputs: {
                    freq: document.getElementById('input-freq'), dist: document.getElementById('input-dist'),
                    count: document.getElementById('input-count'), angle: document.getElementById('input-angle'),
                    stgGap: document.getElementById('input-stg-gap'), latMargin: document.getElementById('input-lat-margin')
                },
                displays: {
                    freq: document.getElementById('disp-freq'), dist: document.getElementById('disp-dist'),
                    count: document.getElementById('disp-count'), angle: document.getElementById('disp-angle'),
                    stgGap: document.getElementById('disp-stg-gap'), latMargin: document.getElementById('disp-lat-margin')
                },
                rows: { dist: document.getElementById('row-dist') },
                hud: {
                    lambda: document.getElementById('hud-lambda'), status: document.getElementById('hud-status'),
                    delay: document.getElementById('hud-delay'), delayRow: document.getElementById('row-delay')
                },
                btns: {
                    broad: document.getElementById('btn-broad'), end: document.getElementById('btn-end'),
                    lr: document.getElementById('btn-lr'), play: document.getElementById('btn-play')
                },
                baffleList: document.getElementById('baffle-control-list'),
                optStatus: document.getElementById('opt-status'),
                modalGuide: document.getElementById('modal-guide')
            };

            const ctx = els.canvas.getContext('2d', { alpha: false });
            ctx.imageSmoothingEnabled = true;

            // Global Methods
            window.app.setMode = (m) => {
                state.mode = m; state.isOptimized = false; state.isCardioidMode = false; resetGain();
                els.optStatus.style.display = 'none';
                els.btns.broad.className = m === 'broadside' ? 'active' : '';
                els.btns.end.className = m === 'endfire' ? 'active' : '';
                updateUI(); 
            };
            window.app.toggleLR = () => {
                state.lrMode = !state.lrMode; state.isOptimized = false; state.isCardioidMode = false; resetGain();
                els.optStatus.style.display = 'none';
                els.btns.lr.innerText = state.lrMode ? "MODO: STEREO L/R" : "MODO: MONO CENTRAL";
                els.btns.lr.className = state.lrMode ? 'active' : '';
                updateUI(); 
            };
            window.app.togglePolarity = (i) => {
                state.polarities[i] = !state.polarities[i];
                renderBaffleGrid(); 
            };
            window.app.toggleDirection = (i) => {
                state.directions[i] = !state.directions[i];
                renderBaffleGrid();
            };
            window.app.setDelay = (i, val) => {
                state.delays[i] = parseFloat(val);
                state.isOptimized = false; // Manual override disables auto-opt
                // If Cardioid mode active, maybe disable it or keep it?
                // For now, let user override.
                updateUI();
            };
            window.app.togglePlay = () => {
                state.isPlaying = !state.isPlaying;
                els.btns.play.innerHTML = state.isPlaying ? '‚ùö‚ùö' : '‚ñ∂';
                els.btns.play.className = state.isPlaying ? 'vp-btn' : 'vp-btn paused';
            };
            window.app.toggleGuide = () => {
                state.isGuideOpen = !state.isGuideOpen;
                els.modalGuide.classList.toggle('open', state.isGuideOpen);
            };
            window.app.setLambdaFraction = (frac) => {
                const c = SPEED_OF_SOUND;
                let optimal = (c / state.freq) * frac;
                optimal = Math.min(4.0, Math.max(0.2, optimal));
                state.dist = optimal; els.inputs.dist.value = optimal;
                if(state.isCardioidMode) updateCardioidDelay();
                updateUI(); 
            };
            window.app.setupCardioid = () => {
                // Manual setup helper (Preset)
                state.count = 2; els.inputs.count.value = 2;
                window.app.setMode('endfire'); 
                state.polarities.fill(false); state.directions.fill(false);
                state.delays.fill(0);
                state.polarities[0] = true; // Invert Rear
                // No auto logic here, just preset
                window.app.applyPreset(state.freq);
            };
            window.app.applyPreset = (hz) => {
                state.freq = hz; state.isOptimized = false; resetGain();
                els.optStatus.style.display = 'none'; els.inputs.freq.value = hz;
                const v = SPEED_OF_SOUND;
                let optimal = (v / hz) / 4;
                optimal = Math.min(4.0, Math.max(0.2, optimal));
                state.dist = optimal; els.inputs.dist.value = optimal;
                if(state.isCardioidMode) updateCardioidDelay();
                updateUI(); 
            };
            window.app.autoOptimize = () => {
                const c = SPEED_OF_SOUND;
                let optimalDist = (c / state.freq) / 4;
                optimalDist = Math.min(4.0, Math.max(0.2, optimalDist));
                state.dist = optimalDist; els.inputs.dist.value = optimalDist;
                
                // Focus Logic
                const k = (2 * Math.PI * state.freq) / c; 
                const tempSources = generateSourcesForLogic();
                const dists = tempSources.map(s => Math.hypot(state.mic.x - s.x, state.mic.y - s.y));
                const maxDist = Math.max(...dists);
                
                const calcDelays = dists.map(d => ((maxDist - d) / c) * 1000);
                // Apply to sliders
                for(let i=0; i<state.count; i++) state.delays[i] = calcDelays[i] || 0;

                state.isOptimized = true; state.isCardioidMode = false;
                els.optStatus.style.display = 'block';
                els.optStatus.innerHTML = 'OPTIMIZADO (FOCUS)';
                resetGain(); updateUI(); 
            };
            
            function updateCardioidDelay() {
                const c = SPEED_OF_SOUND;
                // Rule: Delay = Distance / C.
                const delaySec = state.dist / c;
                const delayMs = delaySec * 1000;
                // Rear (0) is Ref. Front (1) is delayed.
                state.delays[0] = 0;
                state.delays[1] = delayMs;
                // Update others if any (ignore for now, usually count=2)
            }

            window.app.autoCardioid = () => {
                // Cardioid Recipe: Rear Inverted + Front Delayed based on Dist.
                state.count = 2; els.inputs.count.value = 2;
                window.app.setMode('endfire');
                
                state.polarities.fill(false);
                state.directions.fill(false);
                state.delays.fill(0);
                
                state.polarities[0] = true; // Rear Inverted
                
                state.isCardioidMode = true; 
                state.isOptimized = true;
                
                updateCardioidDelay();

                els.optStatus.style.display = 'block';
                els.optStatus.innerHTML = 'OPTIMIZADO (CARDIOID DIN√ÅMICO)';
                resetGain(); updateUI();
            };

            function resetGain() { state.viewGain = 1.0; }

            function getPointerPos(e) {
                const rect = els.canvas.getBoundingClientRect();
                let cx, cy;
                if (e.changedTouches && e.changedTouches.length > 0) {
                    cx = e.changedTouches[0].clientX; cy = e.changedTouches[0].clientY;
                } else {
                    cx = e.clientX; cy = e.clientY;
                }
                return { x: cx - rect.left, y: cy - rect.top, clientX: cx, clientY: cy };
            }

            // --- SMART TOOLTIPS & INPUTS ---
            function setControlsDimmed() { els.controls.classList.add('controls-dimmed'); }
            function removeControlsDimmed() { els.controls.classList.remove('controls-dimmed'); }

            Object.keys(els.inputs).forEach(key => {
                if(!els.inputs[key]) return;
                const input = els.inputs[key];
                input.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    if (key === 'stgGap') state.stageGap = val;
                    else if (key === 'latMargin') state.lateralMargin = val;
                    else state[key] = val;
                    
                    if(key === 'dist' && state.isCardioidMode) {
                        updateCardioidDelay();
                    }

                    if (['freq', 'dist', 'stgGap', 'latMargin', 'count', 'angle'].includes(key)) {
                         if(state.isOptimized && !state.isCardioidMode) { 
                             state.isOptimized = false; els.optStatus.style.display = 'none'; resetGain(); 
                         }
                         if(key === 'count') resetGain();
                    }
                    updateUI(); 
                });
            });

            els.canvas.addEventListener('dblclick', (e) => {
                const pos = getPointerPos(e);
                const cx = els.canvas.width / 2 + state.view.x;
                const cy = els.canvas.height / 2 + state.view.y;
                const ppm = state.view.scale;
                const mx = cx + state.mic.x * ppm;
                const my = cy + state.mic.y * ppm;
                if(Math.hypot(pos.x - mx, pos.y - my) < 50) state.mic.x = 0;
            });

            function handleStart(e) {
                if(e.type === 'touchstart') e.preventDefault();
                const pos = getPointerPos(e);
                const cx = els.canvas.width / 2 + state.view.x;
                const cy = els.canvas.height / 2 + state.view.y;
                const ppm = state.view.scale;
                const mx = cx + state.mic.x * ppm;
                const my = cy + state.mic.y * ppm;
                
                // Mic Hit Test
                if (Math.hypot(pos.x - mx, pos.y - my) < 50) {
                    state.view.dragType = 'mic'; state.view.dragging = true;
                    setControlsDimmed();
                    state.view.lastX = pos.clientX; state.view.lastY = pos.clientY;
                    return;
                }

                // Baffle Hit Test
                // Just check proximity to generated sources
                let sources = generateSourcesForLogic();
                let closest = -1;
                let minD = 50; 
                sources.forEach((s, i) => {
                    const sx = cx + s.x * ppm;
                    const sy = cy + s.y * ppm;
                    const d = Math.hypot(pos.x - sx, pos.y - sy);
                    if(d < minD) { minD = d; closest = i; }
                });

                if (closest !== -1) {
                    state.view.dragType = 'baffle'; 
                    state.view.dragging = true;
                    state.view.dragIndex = closest; // Note: Dragging one affects global dist usually
                    setControlsDimmed();
                } else {
                    state.view.dragType = 'view'; state.view.dragging = true;
                    setControlsDimmed();
                }
                state.view.lastX = pos.clientX; state.view.lastY = pos.clientY;
            }

            function handleMove(e) {
                if(state.view.dragging) {
                    e.preventDefault(); 
                    const pos = getPointerPos(e);
                    const dxPix = pos.clientX - state.view.lastX;
                    const dyPix = pos.clientY - state.view.lastY;
                    
                    if (state.view.dragType === 'view') { 
                        state.view.x += dxPix; state.view.y += dyPix; 
                    } else if (state.view.dragType === 'mic') {
                        state.mic.x += dxPix / state.view.scale; state.mic.y += dyPix / state.view.scale;
                    } else if (state.view.dragType === 'baffle') {
                        // Dragging a baffle adjusts separation (dist)
                        // This assumes symmetrical expansion for Broadside or Endfire depth.
                        // Simplified: Vertical movement adjusts dist if Endfire, Horizontal if Broadside?
                        // Let's make Vertical movement adjust dist generally since user asked "Arrastrar bafle verticalmente".
                        const dM = -dyPix / state.view.scale; // Up is -Y
                        // Sensitivity adjustment
                        if (Math.abs(dM) > 0) {
                            let newDist = state.dist + (dM * 0.5); 
                            newDist = Math.max(0.2, Math.min(4.0, newDist));
                            state.dist = newDist;
                            els.inputs.dist.value = newDist;
                            
                            if (state.isCardioidMode) {
                                updateCardioidDelay();
                            } else if (state.isOptimized) {
                                // Break optimization if moved manually
                                state.isOptimized = false; els.optStatus.style.display = 'none';
                            }
                            updateUI();
                        }
                    }
                    state.view.lastX = pos.clientX; state.view.lastY = pos.clientY;
                }
            }

            function handleEnd(e) {
                state.view.dragging = false; state.view.dragType = null;
                removeControlsDimmed(); 
            }

            els.canvas.addEventListener('mousedown', handleStart);
            window.addEventListener('mousemove', handleMove);
            window.addEventListener('mouseup', handleEnd);
            els.canvas.addEventListener('touchstart', handleStart, {passive: false});
            window.addEventListener('touchmove', handleMove, {passive: false});
            window.addEventListener('touchend', handleEnd);
            els.canvas.addEventListener('wheel', e => {
                e.preventDefault();
                const factor = e.deltaY > 0 ? 0.9 : 1.1;
                state.view.scale = Math.max(5, Math.min(100, state.view.scale * factor));
            });
            window.addEventListener('resize', () => {
                els.canvas.width = els.canvas.parentElement.clientWidth;
                els.canvas.height = els.canvas.parentElement.clientHeight;
            });

            function updateUI() {
                els.displays.freq.innerText = state.freq + ' Hz';
                els.displays.dist.innerText = state.dist.toFixed(2) + ' m';
                els.displays.count.innerText = state.count;
                els.displays.angle.innerText = state.angle + '¬∞';
                els.displays.stgGap.innerText = state.stageGap.toFixed(2) + ' m';
                els.displays.latMargin.innerText = state.lateralMargin.toFixed(1) + ' m';
                if (state.count === 1) els.rows.dist.classList.add('disabled');
                else els.rows.dist.classList.remove('disabled');
                
                const c = SPEED_OF_SOUND;
                const lambda = c / state.freq;
                const delay = (state.dist / c) * 1000;
                els.hud.lambda.innerText = lambda.toFixed(2) + ' m';
                
                const limit = (2/3) * lambda; const optimal = lambda / 4; 
                if (state.dist > limit && state.count > 1) {
                    els.hud.status.innerText = "ALIASING"; els.hud.status.className = "hud-value status-danger";
                } else if (Math.abs(state.dist - optimal) < optimal * 0.15 && state.count > 1) {
                    els.hud.status.innerText = "OPTIMO Œª/4"; els.hud.status.className = "hud-value status-ok";
                } else {
                    els.hud.status.innerText = state.count === 1 ? "PUNTUAL" : "ESTANDAR";
                    els.hud.status.className = "hud-value";
                }
                
                if (state.mode === 'endfire' && state.count > 1) {
                    els.hud.delayRow.style.display = 'flex'; els.hud.delay.innerText = delay.toFixed(2) + ' ms';
                } else els.hud.delayRow.style.display = 'none';
                
                renderBaffleGrid();
            }

            function renderBaffleGrid() {
                els.baffleList.innerHTML = '';
                for(let i=0; i<state.count; i++) {
                    const row = document.createElement('div');
                    row.className = 'baffle-row';
                    const inv = state.polarities[i];
                    const dirDown = state.directions[i]; // true = down
                    const delay = state.delays[i] || 0;
                    
                    row.innerHTML = `
                        <div class="baffle-info">
                            <div class="baffle-num">${i+1}</div>
                        </div>
                        <div class="baffle-controls">
                            <button class="baffle-btn ${inv ? 'active' : ''}" onclick="app.togglePolarity(${i})">
                                √ò
                            </button>
                            <button class="baffle-btn ${dirDown ? 'dir-active' : ''}" onclick="app.toggleDirection(${i})">
                                ‚ü≤
                            </button>
                        </div>
                        <div class="delay-slider-container">
                             <input type="range" min="0" max="20" step="0.01" value="${delay.toFixed(2)}" oninput="app.setDelay(${i}, this.value)">
                             <div class="delay-val">${delay.toFixed(2)} ms</div>
                        </div>
                    `;
                    els.baffleList.appendChild(row);
                }
            }

            function generateSourcesForLogic() {
                const srcY = 0; 
                const sources = [];
                let xOffsets = [0];
                
                if (state.lrMode) {
                    // Left Cluster centered at -margin, Right at +margin
                    xOffsets = [-state.lateralMargin, state.lateralMargin];
                }

                xOffsets.forEach((xOff, clusterIdx) => {
                    const isLeft = (xOff < 0);
                    const isRight = (xOff > 0);
                    
                    if (state.mode === 'broadside') {
                        for(let i=0; i<state.count; i++) {
                            let xPos;
                            if (isLeft) {
                                xPos = xOff - (i * state.dist);
                            } else if (isRight) {
                                xPos = xOff + (i * state.dist);
                            } else {
                                const totalW = (state.count - 1) * state.dist;
                                xPos = xOff - totalW/2 + (i * state.dist);
                            }
                            
                            sources.push({ 
                                x: xPos, y: srcY, phase: 0, 
                                inv: state.polarities[i], 
                                dirDown: state.directions[i],
                                delay: state.delays[i] || 0
                            });
                        }
                    } else {
                        // Endfire: Line along Y (Depth).
                        // Standard: i=0 is Back (lowest).
                        for(let i=0; i<state.count; i++) {
                            const yPos = srcY - (i * state.dist); // -Y is Up.
                            sources.push({ 
                                x: xOff, y: yPos, phase: 0, 
                                inv: state.polarities[i], 
                                dirDown: state.directions[i],
                                delay: state.delays[i] || 0
                            });
                        }
                    }
                });
                return sources;
            }

            function fillHeatmapColor(db, data, idx) {
                let r=0, g=0, b=0, a=230;
                if (db > 0) {
                     r = 255; g = 255; b = Math.min(255, Math.floor(db * 20)); 
                } else if (db > -6) {
                    const t = (db + 6) / 6; r = 255; g = Math.floor(200 + t * 55); b = 0;
                } else if (db > -12) {
                    const t = (db + 12) / 6; r = 255; g = Math.floor(t * 200); b = 0;
                } else if (db > -24) {
                    const t = (db + 24) / 12; r = Math.floor(t * 255); g = 0; b = Math.floor((1-t) * 255);
                } else if (db > -60) {
                    const t = (db + 60) / 36; r = 0; g = 0; b = Math.floor(t * 255); a = Math.floor(t * 230);
                } else {
                    r=0; g=0; b=0; a=0;
                }
                data[idx] = r; data[idx+1] = g; data[idx+2] = b; data[idx+3] = a;
            }

            function draw() {
                const w = els.canvas.width; const h = els.canvas.height;
                if(w === 0 || h === 0) return; 

                const cx = w/2 + state.view.x; const cy = h/2 + state.view.y;
                const ppm = state.view.scale;
                const c = SPEED_OF_SOUND; 
                const k = (2 * Math.PI * state.freq) / c;
                // Harmonic k for educational visualization
                const k2 = (2 * Math.PI * (state.freq * 2)) / c;
                const timePhase = state.time * 0.5; 
                
                const angleRad = state.angle * (Math.PI / 180);
                const halfAngle = angleRad / 2;
                const cosHalfAngle = Math.cos(halfAngle);

                ctx.fillStyle = '#09090b'; ctx.fillRect(0,0,w,h);
                
                // Grid
                ctx.save(); ctx.beginPath(); ctx.strokeStyle = '#222'; ctx.lineWidth = 1;
                const startX = Math.floor((-cx)/ppm); const endX = Math.ceil((w-cx)/ppm);
                const startY = Math.floor((-cy)/ppm); const endY = Math.ceil((h-cy)/ppm);
                for(let gx=startX; gx<=endX; gx++) { const sx = cx + gx*ppm; ctx.moveTo(sx, 0); ctx.lineTo(sx, h); }
                for(let gy=startY; gy<=endY; gy++) { const sy = cy + gy*ppm; ctx.moveTo(0, sy); ctx.lineTo(w, sy); }
                ctx.stroke(); ctx.restore();

                let sources = generateSourcesForLogic();
                // Apply Delays as Phase Shifts
                sources.forEach((s, i) => { 
                    // Phase = -omega * delay. 
                    // delay is in ms. time = delay/1000. omega = 2*PI*freq.
                    // phase = -(2*PI*freq) * (delay/1000).
                    // This is broadband correct phase shift.
                    // PLUS any "Optimized" phase? 
                    // We consolidated logic: state.delays holds the electronic delay.
                    // We calculate phase from it.
                    s.phase = -(2 * Math.PI * state.freq) * (s.delay / 1000);
                });

                const wallYVal = state.stageGap; 
                const wallPx = cy + wallYVal * ppm;
                const gain = state.viewGain; 

                // Pre-calc source props for shader-like loop
                const simSources = sources.map(s => {
                    const sx = cx + s.x * ppm;
                    const sy = cy + s.y * ppm;
                    const vY_meters = 2 * wallYVal - s.y;
                    const vSy = cy + vY_meters * ppm; 
                    
                    const leakage = 0.5; 
                    let directAmp = 1.0; 
                    let reflectedAmp = leakage;

                    if (s.dirDown) {
                        directAmp = leakage;
                        reflectedAmp = 1.0;
                    }

                    return {
                        sx, sy, vSy,
                        phase: s.phase,
                        inv: s.inv,
                        dirDown: s.dirDown,
                        directAmp,
                        reflectedAmp,
                        x: s.x, y: s.y,
                        delay: s.delay
                    };
                });

                const imgData = ctx.getImageData(0, 0, w, h);
                const data = imgData.data;

                // Physics Loop
                for(let y=0; y<h; y++) { 
                    if (y > wallPx) { // Mask Stage
                        for(let x=0; x<w; x++) {
                            const i = (y*w + x)*4;
                            data[i]=10; data[i+1]=10; data[i+2]=12; data[i+3]=255;
                        }
                        continue;
                    }
                    const rowOff = y * w * 4;

                    for(let x=0; x<w; x++) {
                        const idx = rowOff + (x * 4);
                        let pSum = 0; 

                        for(let i=0; i<simSources.length; i++) {
                            const s = simSources[i];
                            const dx = x - s.sx; const dy = y - s.sy;
                            
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            const distMeters = dist / ppm;
                            const dClamped = Math.max(0.1, distMeters);
                            
                            let ampD = 0;
                            // 1. Direct Path
                            if (!s.dirDown) {
                                const cosTheta = -dy / dist;
                                let beamFactor = 1.0;
                                if (cosTheta < cosHalfAngle) {
                                    const diff = cosHalfAngle - cosTheta;
                                    beamFactor = Math.max(s.reflectedAmp, 1.0 - (diff * 5)); 
                                }
                                ampD = (1.0 / dClamped) * beamFactor; 
                            } else {
                                const cosTheta = dy / dist; 
                                let beamFactor = 1.0;
                                if (cosTheta < cosHalfAngle) {
                                    const diff = cosHalfAngle - cosTheta;
                                    beamFactor = Math.max(s.directAmp, 1.0 - (diff * 5)); 
                                }
                                ampD = (1.0 / dClamped) * beamFactor;
                            }

                            const phD = (k * distMeters) - timePhase - s.phase + (s.inv ? Math.PI : 0);
                            pSum += ampD * Math.sin(phD);

                            // 2. Reflected Path
                            const vDy = y - s.vSy;
                            const vDist = Math.sqrt(dx*dx + vDy*vDy);
                            const vDistM = vDist / ppm;
                            const vDClamped = Math.max(0.1, vDistM);
                            
                            const wallAbsorption = 0.6;
                            let ampR = (1.0 / vDClamped) * ampD * wallAbsorption; 
                            
                            const phR = (k * vDistM) - timePhase - s.phase + (s.inv ? Math.PI : 0);
                            pSum += ampR * Math.sin(phR);
                        }
                        
                        const absPressure = Math.abs(pSum) * gain;
                        const db = 20 * Math.log10(absPressure + 0.0000001);
                        fillHeatmapColor(db, data, idx);
                    }
                }
                ctx.putImageData(imgData, 0, 0);

                // Overlay
                ctx.save(); ctx.translate(cx, cy); ctx.scale(ppm, ppm);
                
                // Stage
                ctx.strokeStyle = '#52525b'; ctx.lineWidth = 0.05; ctx.fillStyle = '#18181b';
                ctx.fillRect(-200, wallYVal, 400, 20); 
                ctx.beginPath(); ctx.moveTo(-200, wallYVal); ctx.lineTo(200, wallYVal); ctx.stroke();
                ctx.fillStyle = '#fff'; ctx.font = 'bold 0.5px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
                ctx.fillText("ESCENARIO", 0, wallYVal + 0.5);
                
                // Sources
                simSources.forEach((s, i) => {
                    const size = 0.4;
                    ctx.fillStyle = s.inv ? '#ef4444' : '#e4e4e7'; 
                    ctx.strokeStyle = s.dirDown ? '#3b82f6' : '#000';
                    ctx.lineWidth = 0.04; 
                    
                    ctx.beginPath(); ctx.arc(s.x, s.y, size/2, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                    
                    // Arrow
                    ctx.save(); ctx.translate(s.x, s.y);
                    if (s.dirDown) ctx.rotate(Math.PI);
                    ctx.fillStyle = "rgba(0,0,0,0.5)";
                    ctx.beginPath(); ctx.moveTo(-0.1, 0); ctx.lineTo(0.1, 0); ctx.lineTo(0, -0.25); ctx.fill();
                    
                    // Beam lines
                    ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 0.01;
                    ctx.beginPath();
                    ctx.moveTo(0, 0); ctx.lineTo(-Math.sin(halfAngle)*2, -Math.cos(halfAngle)*2);
                    ctx.moveTo(0, 0); ctx.lineTo(Math.sin(halfAngle)*2, -Math.cos(halfAngle)*2);
                    ctx.stroke();
                    ctx.restore();

                    // Delay Labels
                    ctx.save(); ctx.translate(s.x, s.y - 0.6); ctx.scale(0.04, 0.04);
                    ctx.fillStyle = "rgba(0,0,0,0.8)";
                    ctx.beginPath(); ctx.roundRect(-25, -10, 50, 20, 5); ctx.fill();
                    ctx.fillStyle = "#3b82f6"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                    ctx.font = "bold 14px sans-serif";
                    ctx.fillText(s.delay.toFixed(2) + "ms", 0, 0);
                    ctx.restore();
                });

                // --- PHASE ANALYZER (Educational) ---
                const mx = state.mic.x; const my = state.mic.y;
                let sumR = 0, sumI = 0;
                let sumR2 = 0, sumI2 = 0;
                
                simSources.forEach(s => {
                    const dx = mx - s.x; const dy = my - s.y;
                    const d = Math.sqrt(dx*dx + dy*dy);
                    const dClamped = Math.max(0.1, d);
                    
                    const amp = 1.0 / dClamped; 
                    const phi = (k*d) - s.phase + (s.inv?Math.PI:0);
                    sumR += amp * Math.cos(phi); sumI += amp * Math.sin(phi);

                    // Harmonic
                    const phi2 = (k2*d) - (s.phase*2) + (s.inv?Math.PI:0); 
                    const ampH = amp * 0.4; 
                    sumR2 += ampH * Math.cos(phi2); sumI2 += ampH * Math.sin(phi2);
                });
                
                // Mic Viz
                ctx.translate(mx, my);
                const mag = Math.sqrt(sumR*sumR + sumI*sumI) * gain;
                const db = 20 * Math.log10(mag + 1e-6);
                const micColor = db > -6 ? '#22c55e' : (db < -12 ? '#ef4444' : '#fbbf24');

                ctx.strokeStyle = micColor; ctx.lineWidth = 0.05; ctx.beginPath();
                ctx.arc(0, 0, 0.8, 0, Math.PI * 2); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(-0.6, 0); ctx.lineTo(0.6, 0); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, -0.6); ctx.lineTo(0, 0.6); ctx.stroke();

                // Draw Analyzer Box
                const azW = 3.5; const azH = 2.0;
                const azX = 1.2; const azY = -1.0;
                ctx.translate(azX, azY);
                
                ctx.fillStyle = "rgba(10,12,14, 0.9)";
                ctx.fillRect(0, 0, azW, azH);
                ctx.lineWidth = 0.01; ctx.strokeStyle = "rgba(255,255,255,0.2)";
                ctx.beginPath();
                for(let i=1; i<4; i++) { ctx.moveTo(i*(azW/4), 0); ctx.lineTo(i*(azW/4), azH); }
                for(let i=1; i<4; i++) { ctx.moveTo(0, i*(azH/4)); ctx.lineTo(azW, i*(azH/4)); }
                ctx.stroke();
                ctx.strokeStyle = "rgba(255,255,255,0.4)"; ctx.beginPath(); ctx.moveTo(0, azH/2); ctx.lineTo(azW, azH/2); ctx.stroke();
                ctx.strokeRect(0, 0, azW, azH);

                // Waveform
                ctx.beginPath(); ctx.lineWidth = 0.04; ctx.strokeStyle = micColor;
                const midY = azH/2;
                const pts = 40;
                for(let i=0; i<=pts; i++) {
                    const tNorm = i/pts;
                    const tVal = tNorm * Math.PI * 4; 
                    const val1 = (sumR*Math.sin(tVal - timePhase) + sumI*Math.cos(tVal - timePhase));
                    const val2 = (sumR2*Math.sin(2*tVal - timePhase) + sumI2*Math.cos(2*tVal - timePhase));
                    const val = val1 + val2; 
                    const yPos = midY - (val * 0.25); 
                    const xPos = tNorm * azW;
                    if(i===0) ctx.moveTo(xPos, yPos); else ctx.lineTo(xPos, yPos);
                }
                ctx.stroke();

                ctx.restore();
                ctx.restore();
            }

            function animate() {
                if(state.isPlaying) state.time += 0.2;
                draw(); 
                requestAnimationFrame(animate);
            }

            els.canvas.width = els.canvas.parentElement.clientWidth;
            els.canvas.height = els.canvas.parentElement.clientHeight;
            updateUI();
            animate(); 
        };
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>