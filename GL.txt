<!DOCTYPE html>
<html>
<head>
    <title>Calculador distancia de graves según Hz.</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1e1e1e;
            color: #ffffff;
            text-align: center;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        h1 {
            color: #4CAF50;
            padding-top: 5px;
            font-size: 1.4em;
            margin-bottom: 5px;
        }
        
        #info-panel {
            flex-shrink: 0;
            font-size: 0.95em;
            padding: 8px;
            background-color: #2c2c2c;
            width: 95vw;
            max-width: 800px;
            margin: 10px auto 5px auto;
            border-radius: 8px;
            text-align: left;
        }
        
        #container {
            flex-grow: 1;
            width: 95vw;
            max-width: 800px;
            margin: 5px auto 10px auto;
            min-height: 250px;
            position: relative; 
        }
        #container canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
            border: 2px solid #555;
            border-radius: 8px;
        }

        /* Estilos de las etiquetas de texto superpuestas */
        .scene-label {
            position: absolute;
            background-color: rgba(30, 30, 30, 0.8);
            color: white;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 12px;
            white-space: nowrap;
            transform: translate(-50%, -50%); 
            pointer-events: none;
            border: 1px solid #444;
        }
        #label-freq {
            font-size: 14px;
            font-weight: bold;
            color: #4CAF50;
        }
        #label-distancia {
            font-size: 12px;
            color: #f0ad4e;
        }
        
        .control-group { margin-bottom: 2px; }
        .slider-container { width: 95%; margin: 0 auto 8px 0; position: relative; }
        .slider-label { display: block; font-size: 0.85em; margin-bottom: 1px; font-weight: bold; color: #1e90ff; }
        input[type=range] { width: 100%; height: 5px; background: #555; -webkit-appearance: none; border-radius: 5px; cursor: pointer; }
        
        #rango-description {
            font-weight: bold;
            color: #f0ad4e;
            margin-top: 5px;
            padding: 4px;
            border-top: 1px solid #444;
            font-size: 0.8em;
        }
        
        /* Contenedor y estilo para la imagen de referencia */
        #imagen-referencia {
            width: 95vw;
            max-width: 800px;
            margin: 20px auto;
        }
        #imagen-referencia img {
            width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }

    </style>
</head>
<body>

    <div id="info-panel">
        <h1>Calculador distancia de graves según Hz.</h1>
        
        <div id="frecuencia-info" class="control-group">Frecuencia: 100 Hz (L.O.: 3.40 m) | Ideal: 1.70 m</div>
        <label for="sliderFrecuencia" class="slider-label">Control de Frecuencia (Hz) [30 - 400 Hz]:</label>
        <div class="slider-container">
            <input type="range" id="sliderFrecuencia" min="30" max="400" step="5" value="100" oninput="actualizarValores()"> 
        </div>
        
        <div id="separacion-info" class="control-group">Separación: 0.85 metros - Máxima Coherencia</div>
        <label for="sliderSeparacion" class="slider-label">Control de Separación (Metros) [0.1 - 4.0 m]:</label>
        <div class="slider-container">
            <input type="range" id="sliderSeparacion" min="0.1" max="4.0" step="0.05" value="0.85" oninput="actualizarValores()">
        </div>
        
        <div id="rango-description"></div>

        <p style="font-size: 0.75em; margin-top: 5px;">
            **Leyenda:** <span style="color:#4CAF50; font-weight: bold;">Verde</span> = Refuerzo (Suma) | <span style="color:#FF5733; font-weight: bold;">Rojo</span> = Cancelación (Resta)
        </p>
    </div>

    <div id="container">
        <div id="label-freq" class="scene-label"></div>
        <div id="label-distancia" class="scene-label"></div>
    </div>

    <div id="imagen-referencia">
        <h2 style="font-size: 1.2em; margin-bottom: 10px; color: #ffffff;">Rangos de Frecuencia Musical</h2>
        <img src="https://maurocasarin.github.io/SONIDO/index_archivos/image005.jpg" alt="Gráfico de Rangos de Frecuencia para Mezcla de Sonido" />
    </div>

    <!-- Carga de la librería Three.js (la necesitamos para WebGL) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // --- VARIABLES GLOBALES ---
        let scene, camera, renderer, plane, material, sub1, sub2;
        const SIMULATION_SIZE_Y = 8; 
        const SEGMENTS = 256;
        const VELOCIDAD_SONIDO = 340; 
        
        // Elementos DOM para las etiquetas
        const container = document.getElementById('container');
        const labelFreq = document.getElementById('label-freq');
        const labelDistancia = document.getElementById('label-distancia');
        
        // Vectores para la proyección de coordenadas
        const vectorFreq = new THREE.Vector3(0, 0, SIMULATION_SIZE_Y / 2 * 0.875); 
        const vectorDist = new THREE.Vector3(0, 0, -0.5); 

        // --- INICIALIZACIÓN DE THREE.JS ---
        function initThree() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setClearColor(0x1e1e1e);
            container.appendChild(renderer.domElement);

            scene = new THREE.Scene();
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            camera = new THREE.OrthographicCamera();
            camera.position.set(0, 5, 0); 
            camera.lookAt(0, 0, 0);

            const geometry = new THREE.PlaneGeometry(SIMULATION_SIZE_Y, SIMULATION_SIZE_Y, SEGMENTS, SEGMENTS);
            material = new THREE.ShaderMaterial({
                uniforms: {
                    u_lambda: { value: 3.4 }, u_separation: { value: 0.85 }, u_size: { value: SIMULATION_SIZE_Y },
                    u_red_color: { value: new THREE.Color(0xFF5733) }, u_green_color: { value: new THREE.Color(0x4CAF50) },
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
                `,
                fragmentShader: `
                    uniform float u_lambda; uniform float u_separation; uniform float u_size; uniform vec3 u_red_color; uniform vec3 u_green_color; varying vec2 vUv;
                    void main() {
                        vec2 pos = (vUv - 0.5) * u_size; 
                        float sub_offset = u_separation / 2.0;
                        float r1 = distance(pos, vec2(-sub_offset, 0.0));
                        float r2 = distance(pos, vec2(sub_offset, 0.0));
                        float deltaR = r2 - r1;
                        float phase_diff = (deltaR / u_lambda) * 6.2831853;
                        float intensity = 2.0 * abs(cos(phase_diff / 2.0));
                        
                        // *** MÁXIMO CONTRASTE (power=4.0) ***
                        float power = pow(intensity / 2.0, 4.0); 
                        vec3 final_color = mix(u_red_color, u_green_color, power);
                        
                        float border_fade = 1.0 - smoothstep(2.5, 4.0, length(pos));
                        final_color *= border_fade;
                        gl_FragColor = vec4(final_color, 1.0);
                    }
                `,
                transparent: true, side: THREE.DoubleSide
            });

            plane = new THREE.Mesh(geometry, material);
            plane.rotation.x = -Math.PI / 2;
            scene.add(plane);
            
            // 4. Bafles 3D
            const bafleGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            const bafleMat = new THREE.MeshBasicMaterial({ color: 0x444444, wireframe: false }); 
            const bafleEdgeMat = new THREE.LineBasicMaterial({ color: 0xffffff }); 
            const coneGeo = new THREE.ConeGeometry(0.15, 0.15, 16);
            const coneMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            coneGeo.translate(0, 0.15, -0.15);
            
            sub1 = new THREE.Mesh(bafleGeo, bafleMat);
            sub1.add(new THREE.LineSegments(new THREE.EdgesGeometry(bafleGeo), bafleEdgeMat));
            sub1.add(new THREE.Mesh(coneGeo, coneMat));
            scene.add(sub1);
            
            sub2 = new THREE.Mesh(bafleGeo, bafleMat);
            sub2.add(new THREE.LineSegments(new THREE.EdgesGeometry(bafleGeo), bafleEdgeMat));
            sub2.add(new THREE.Mesh(coneGeo, coneMat));
            scene.add(sub2);
            
            window.addEventListener('resize', onWindowResize, false);
            onWindowResize();
        }

        function onWindowResize() {
            const rect = container.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;
            
            const aspectRatio = width / height;
            
            let viewHeight = SIMULATION_SIZE_Y;
            let viewWidth = viewHeight * aspectRatio;

            if (viewWidth < SIMULATION_SIZE_Y) {
                viewWidth = SIMULATION_SIZE_Y;
                viewHeight = viewWidth / aspectRatio;
            }

            camera.left = -viewWidth / 2;
            camera.right = viewWidth / 2;
            camera.top = viewHeight / 2;
            camera.bottom = -viewHeight / 2;
            
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        // --- FUNCIÓN DE ACTUALIZACIÓN DE ETIQUETAS DE TEXTO ---
        function updateLabels() {
            const rect = container.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;

            let posFreq = vectorFreq.clone().project(camera);
            labelFreq.style.left = `${(posFreq.x * 0.5 + 0.5) * width}px`;
            labelFreq.style.top = `${(-posFreq.y * 0.5 + 0.5) * height}px`;

            let posDist = vectorDist.clone().project(camera);
            labelDistancia.style.left = `${(posDist.x * 0.5 + 0.5) * width}px`;
            labelDistancia.style.top = `${(-posDist.y * 0.5 + 0.5) * height - 30}px`;
        }


        // --- BUCLE DE ANIMACIÓN ---
        function animate() {
            requestAnimationFrame(animate);
            updateLabels(); 
            renderer.render(scene, camera);
        }
        
        // --- CÁLCULOS Y CONTROLES ---
        function getRangeDescription(f) {
            if (f < 63) {
                return "Sub Bajos (25-63 Hz): A menudo se percibe como una vibración en lugar de un tono puro. La mayoría de la música generalmente no baja de los 30 Hz.";
            } else if (f >= 63 && f < 250) {
                return "Bajos (63-250 Hz): Una frecuencia que puede sentirse retumbante, pero también añade calidez y potencia. Frecuencia donde instrumentos como el bombo o las cuerdas más graves del bajo pueden tener su fundamental, proporcionando esa sensación de 'retumbo'.";
            } else if (f >= 250 && f <= 400) {
                return "Medios Bajos (250-500 Hz): Frecuencia que da 'cuerpo' y calidez al sonido. Un exceso de esta frecuencia puede hacer que el audio suene apagado, mientras que una cantidad adecuada proporciona una base sólida para la mezcla. Fundamental para la sensación de ritmo y potencia.";
            }
            return "";
        }

        window.actualizarValores = function() {
            const frecuenciaHz = parseFloat(document.getElementById('sliderFrecuencia').value);
            const separacionMetros = parseFloat(document.getElementById('sliderSeparacion').value);
            const LONGITUD_ONDA = VELOCIDAD_SONIDO / frecuenciaHz;
            
            // 1. ACTUALIZAR SHADER y BAFLES
            if (material) {
                material.uniforms.u_lambda.value = LONGITUD_ONDA;
                material.uniforms.u_separation.value = separacionMetros;
            }
            const offset = separacionMetros / 2;
            if (sub1 && sub2) {
                sub1.position.x = -offset;
                sub2.position.x = offset;
            }

            // 2. ACTUALIZAR ETIQUETAS DOM
            labelFreq.textContent = `Frecuencia: ${frecuenciaHz.toFixed(0)} Hz`;
            labelDistancia.textContent = `Separación: ${separacionMetros.toFixed(2)} Metros`;

            // 3. ACTUALIZAR TEXTO EN EL PANEL (UI)
            const controlDirectividad = LONGITUD_ONDA / 2;
            const coherenciaMax = LONGITUD_ONDA / 4;
            let comentarioSeparacion = '';

            if (separacionMetros < coherenciaMax * 1.1) {
                comentarioSeparacion = " - Máxima Coherencia (Fuente única)";
            } else if (separacionMetros < controlDirectividad * 1.1) {
                comentarioSeparacion = " - Ideal para Control de Directividad (Arreglo Lineal)";
            } else if (separacionMetros >= controlDirectividad * 1.1) {
                 comentarioSeparacion = " - **LOBING** Severo (Cancelaciones fuertes)";
            } 
            
            document.getElementById('frecuencia-info').innerHTML = `Frecuencia: ${frecuenciaHz.toFixed(0)} Hz (L.O.: ${LONGITUD_ONDA.toFixed(2)} m) | Ideal: ${controlDirectividad.toFixed(2)} m`;
            document.getElementById('separacion-info').innerHTML = `Separación: ${separacionMetros.toFixed(2)} m ${comentarioSeparacion}`;
            document.getElementById('rango-description').innerHTML = getRangeDescription(frecuenciaHz);
        }

        // --- INICIO DE LA APLICACIÓN ---
        initThree();
        actualizarValores();
        animate();
    </script>

</body>
</html>