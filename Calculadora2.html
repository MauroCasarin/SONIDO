<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculadora de Distancia de Subgraves 3D</title>
    <!-- Carga de Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Carga de Three.js (Biblioteca 3D) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Carga del OrbitControls (Interacción de la cámara) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- Configuración de Estilos -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117;
        }
        /* Estilo para el contenedor del canvas 3D */
        #canvas-container {
            height: 300px; 
            background-color: #1f2937;
            border: 1px solid #374151;
            position: relative;
            overflow: hidden;
        }
        /* Estilos menores del control deslizante y marcadores */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; border: 1px solid #000; height: 24px; width: 24px; border-radius: 50%; background: #10b981; cursor: pointer; box-shadow: 0 0 5px rgba(16, 185, 129, 0.7);
        }
        .frequency-marker { position: absolute; top: 0; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; }
        .frequency-marker-line { width: 1px; height: 8px; background-color: #4b5563; }
        .frequency-marker-text { font-size: 0.75rem; color: #9ca3af; margin-top: 2px; }
    </style>
</head>
<body class="p-4 md:p-8 min-h-screen flex items-center justify-center">

    <div id="calculator-card" class="w-full max-w-xl bg-gray-800 p-6 md:p-8 rounded-xl shadow-2xl border border-gray-700">
        <h1 class="text-3xl font-extrabold text-white text-center mb-6">Cálculo de Distancia de Subgraves <span class="text-xs text-gray-500 block -mt-2">(Visualización 3D)</span></h1>
        
        <p class="text-gray-400 text-center mb-8">Selecciona la frecuencia de corte (Hz) para calcular la separación ideal</p>

        <!-- Sección de Control Deslizante (Slider) CON REGLA INFERIOR (Se mantiene) -->
        <div class="mb-6 p-4 bg-gray-700 rounded-lg shadow-inner">
            <label for="frequency-slider" class="block text-lg font-semibold mb-3 text-white">Selecciona la frecuencia.</label>
            <input type="range" id="frequency-slider" min="30" max="300" value="80" step="1"
                   class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
            <div class="flex justify-between mt-2 text-gray-400 font-mono text-sm relative h-10">
                <div class="absolute w-full -top-3">
                    <span class="frequency-marker" style="left: 0%;"><span class="frequency-marker-line"></span><span class="frequency-marker-text">30 Hz</span></span>
                    <span class="frequency-marker" style="left: 25.93%;"><span class="frequency-marker-line"></span><span class="frequency-marker-text">100 Hz</span></span>
                    <span class="frequency-marker" style="left: 62.96%;"><span class="frequency-marker-line"></span><span class="frequency-marker-text">200 Hz</span></span>
                    <span class="frequency-marker" style="left: 100%;"><span class="frequency-marker-line"></span><span class="frequency-marker-text">300 Hz</span></span>
                </div>
                <span class="text-xs text-gray-500">30 Hz</span>
                <span id="current-frequency" class="text-2xl font-bold text-emerald-400">80 Hz</span>
                <span class="text-xs text-gray-500">300 Hz</span>
            </div>
        </div>

        <!-- Sección de Rango de Frecuencia (Mismo) -->
        <div id="frequency-range-info" class="mb-8 p-4 bg-gray-900 rounded-lg border border-gray-700">
            <h3 class="text-lg font-bold text-center mb-2 text-white"><span id="range-name">Rango: BAJOS</span></h3>
            <p id="range-description" class="text-gray-400 text-sm text-center">Una frecuencia que puede sentirse retumbante, pero también añade calidez y potencia. Frecuencia donde instrumentos como el bombo o las cuerdas más graves del bajo pueden tener su fundamental, proporcionando esa sensación de 'retumbo'.</p>
        </div>

        <!-- Visualización 3D (CANVAS de WebGL/Three.js) -->
        <h2 class="text-xl font-bold text-white mb-3 text-center">Visualización 3D de Acoplamiento</h2>
        <div id="canvas-container" class="w-full rounded-lg shadow-lg mb-4">
            <canvas id="subwoofer-canvas"></canvas>
            <!-- Overlay para texto de Distancia Ideal -->
            <div id="ideal-distance-text" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 font-extrabold text-4xl text-emerald-400 pointer-events-none z-10 text-shadow-lg">1.06 m</div>
        </div>

        <!-- Sección de Resultados Numéricos (Mismos) -->
        <div class="space-y-4">
            <div class="p-4 bg-gray-700 rounded-lg flex items-center justify-between">
                <span class="text-gray-300 font-medium">Longitud de Onda (<span class="font-serif italic text-lg">&lambda;</span>):</span>
                <div class="text-right">
                    <span id="result-wavelength" class="text-xl font-bold text-yellow-400">4.25 m</span>
                    <span class="text-sm text-gray-400 block">(&lambda; = 340 m/s / Hz)</span>
                </div>
            </div>
            <div class="p-4 bg-gray-700 rounded-lg flex items-center justify-between border-l-4 border-emerald-500">
                <span class="text-gray-300 font-medium font-bold text-lg">Distancia Ideal:</span>
                <div class="text-right">
                    <span id="result-initial-numeric" class="text-3xl font-extrabold text-emerald-400">1.06 m</span>
                    <span class="text-sm text-gray-400 block">Separación óptima de centros acústicos</span>
                </div>
            </div>
            <div class="p-4 bg-gray-700 rounded-lg flex items-center justify-between border-l-4 border-red-500">
                <span class="text-gray-300 font-medium">Distancia Máxima Teórica:</span>
                <div class="text-right">
                    <span id="result-max" class="text-xl font-bold text-red-400">2.83 m</span>
                    <span class="text-sm text-gray-400 block">(2&lambda;/3 límite teórico)</span>
                </div>
            </div>
        </div>
        
        <div class="mt-8 text-sm text-gray-500 text-center">
            <p>*Velocidad del sonido utilizada: 340 m/s. La visualización 3D es una representación esquemática del acoplamiento.</p>
            <p class="mt-2 text-xs text-gray-600">Puedes mover la escena con el ratón (clic y arrastrar) o con dos dedos en móvil.</p>
        </div>
    </div>

    <script>
        // --- CONSTANTES Y CONFIGURACIÓN ---
        const VELOCIDAD_SONIDO = 340;
        const RANGOS_FRECUENCIA = [
            { name: "SUB BAJOS", min: 30, max: 79, description: "A menudo se percibe como una vibración en lugar de un tono puro. Los sonidos de frecuencia ultra baja por debajo de 25 Hz son poco comunes en la mayoría de la música, que generalmente no baja de los 30 Hz." },
            { name: "BAJOS", min: 80, max: 149, description: "Una frecuencia que puede sentirse retumbante, pero también añade calidez y potencia. Frecuencia donde instrumentos como el bombo o las cuerdas más graves del bajo pueden tener su fundamental, proporcionando esa sensación de 'retumbo'." },
            { name: "MEDIOS BAJOS", min: 150, max: 300, description: "Frecuencia que da 'cuerpo' y calidez al sonido. Un exceso de esta frecuencia puede hacer que el audio suene apagado, mientras que una cantidad adecuada proporciona una base sólida para la mezcla. Fundamental para la sensación de ritmo y potencia" }
        ];

        // --- REFERENCIAS DOM Y VARIABLES THREE.JS GLOBALES ---
        const slider = document.getElementById('frequency-slider');
        const currentFrequencyDisplay = document.getElementById('current-frequency');
        const resultWavelength = document.getElementById('result-wavelength');
        const resultInitialNumeric = document.getElementById('result-initial-numeric');
        const resultMax = document.getElementById('result-max');
        const rangeNameDisplay = document.getElementById('range-name');
        const rangeDescriptionDisplay = document.getElementById('range-description');
        const canvasContainer = document.getElementById('canvas-container');
        const idealDistanceTextOverlay = document.getElementById('ideal-distance-text');
        
        // Variables Three.js
        let scene, camera, renderer, controls, sub1, sub2, idealLine, waveMesh, subDistance;
        const SUB_WIDTH = 0.5;  // Ancho (X)
        const SUB_HEIGHT = 0.7; // Altura (Y)
        const SUB_DEPTH = 0.5;  // Profundidad (Z)
        const SCENE_DISTANCE_SCALE = 6; // Distancia total visualizada
        let animationFrameId;

        // --- FUNCIONES DE LÓGICA DE CÁLCULO ---

        function updateRangeInfo(frequency) {
            const currentRange = RANGOS_FRECUENCIA.find(range => 
                frequency >= range.min && frequency <= range.max
            );
            if (currentRange) {
                rangeNameDisplay.textContent = `Rango: ${currentRange.name}`;
                rangeDescriptionDisplay.textContent = currentRange.description;
            } else {
                rangeNameDisplay.textContent = "Rango: Fuera de Audio Profesional";
                rangeDescriptionDisplay.textContent = "Esta frecuencia está fuera de la zona típica de cruce de subgraves (30-300 Hz). Los cálculos son correctos, pero el acoplamiento no es relevante.";
            }
        }

        function calculateAndUpdate() {
            const frequency = parseFloat(slider.value);
            currentFrequencyDisplay.textContent = `${frequency} Hz`;
            updateRangeInfo(frequency);

            // CÁLCULOS
            const wavelength = VELOCIDAD_SONIDO / frequency;
            const initialDistance = wavelength / 4; // Distancia Ideal
            const maxDistance = (2 * wavelength) / 3;

            // Actualizar resultados DOM
            resultWavelength.textContent = `${wavelength.toFixed(2)} m`;
            resultInitialNumeric.textContent = `${initialDistance.toFixed(2)} m`; 
            resultMax.textContent = `${maxDistance.toFixed(2)} m`;
            idealDistanceTextOverlay.textContent = `${initialDistance.toFixed(2)} m`;

            // Actualizar la visualización 3D
            subDistance = initialDistance;
            if (subDistance > SCENE_DISTANCE_SCALE / 2) {
                subDistance = SCENE_DISTANCE_SCALE / 2;
                idealDistanceTextOverlay.textContent = `${initialDistance.toFixed(2)} m (Escala Máx.)`;
            }
            update3DScene(wavelength, subDistance);
        }

        // --- FUNCIONES DE VISUALIZACIÓN 3D (THREE.JS) ---

        function init3DScene() {
            // 1. SCENE
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1f2937); // Fondo Gray-800

            // 2. CAMERA
            const aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
            camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 100);
            camera.position.set(0, 2.5, 5); // Posición inicial ajustada para mejor vista
            camera.lookAt(0, 0, 0); // Mirar al centro de la escena

            // 3. RENDERER
            renderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.getElementById('subwoofer-canvas') });
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // 4. LIGHTS
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); 
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6); 
            directionalLight.position.set(5, 10, 7);
            scene.add(directionalLight);

            // 5. CONTROLS
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; 
            controls.dampingFactor = 0.05;
            controls.minDistance = 3;
            controls.maxDistance = 15;
            controls.target.set(0, 0, 0); 
            controls.update();

            // 6. Objetos Estáticos (Suelo)
            const floorGeometry = new THREE.PlaneGeometry(SCENE_DISTANCE_SCALE * 2, SCENE_DISTANCE_SCALE * 2);
            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x2d3748, side: THREE.DoubleSide }); 
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = Math.PI / 2; 
            floor.position.y = -SUB_HEIGHT / 2; 
            scene.add(floor);
            
            // 7. Objetos Dinámicos
            createSubwoofers();
            createIdealLine();
            createWaveMesh();

            // 8. Iniciar el loop de animación
            animate();
        }
        
        /**
         * Crea la geometría de los subwoofers 3D y simula los drivers.
         */
        function createSubwoofers() {
            // Material para los lados (Negro sólido)
            const sideMaterial = new THREE.MeshLambertMaterial({ color: 0x101010 });
            // Material para la cara frontal (Negro más brillante para simular parrilla)
            const frontMaterial = new THREE.MeshLambertMaterial({ color: 0x0a0a0a }); 
            
            // 6 materiales para cada cara del cubo (frontal es el índice 4)
            const materials = [
                sideMaterial, // Derecha
                sideMaterial, // Izquierda
                sideMaterial, // Arriba
                sideMaterial, // Abajo
                frontMaterial, // Frente (Índice 4)
                sideMaterial   // Detrás
            ];

            const geometry = new THREE.BoxGeometry(SUB_WIDTH, SUB_HEIGHT, SUB_DEPTH);
            
            // Subwoofer 1 (IZQUIERDA)
            sub1 = new THREE.Mesh(geometry, materials);
            sub1.position.set(0, 0, 0); 
            scene.add(sub1);
            
            // Subwoofer 2 (DERECHA)
            sub2 = new THREE.Mesh(geometry, materials);
            sub2.position.set(0, 0, 0); 
            scene.add(sub2);
            
            // *** Simulación de Drivers/Conos ***
            const driverRadius = SUB_WIDTH * 0.4;
            const driverDepth = SUB_DEPTH * 0.01;
            const driverGeometry = new THREE.CylinderGeometry(driverRadius, driverRadius, driverDepth, 32);
            const driverMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 }); 

            const driver1 = new THREE.Mesh(driverGeometry, driverMaterial);
            driver1.rotation.x = Math.PI / 2;
            driver1.position.z = SUB_DEPTH / 2 + driverDepth / 2; 
            sub1.add(driver1);
            
            const driver2 = new THREE.Mesh(driverGeometry, driverMaterial.clone());
            driver2.rotation.x = Math.PI / 2;
            driver2.position.z = SUB_DEPTH / 2 + driverDepth / 2;
            sub2.add(driver2);

            // Simulación de "Logo" azul (Cilindro)
            const logoGeometry = new THREE.CylinderGeometry(driverRadius * 0.15, driverRadius * 0.15, driverDepth, 16);
            const logoMaterial = new THREE.MeshBasicMaterial({ color: 0x007bff }); 
            const logo1 = new THREE.Mesh(logoGeometry, logoMaterial);
            logo1.rotation.x = Math.PI / 2;
            logo1.position.z = SUB_DEPTH / 2 + driverDepth / 2 + 0.001; 
            logo1.position.y = -SUB_HEIGHT * 0.3; // Posición baja
            sub1.add(logo1);
            
            const logo2 = new THREE.Mesh(logoGeometry, logoMaterial.clone());
            logo2.rotation.x = Math.PI / 2;
            logo2.position.z = SUB_DEPTH / 2 + driverDepth / 2 + 0.001; 
            logo2.position.y = -SUB_HEIGHT * 0.3; 
            sub2.add(logo2);
        }
        
        /**
         * Crea la línea discontinua 3D para la distancia ideal (λ/4).
         */
        function createIdealLine() {
            const material = new THREE.LineDashedMaterial({
                color: 0x10b981, // Esmeralda
                linewidth: 3,
                scale: 1,
                dashSize: 0.2,
                gapSize: 0.1,
            });
            const points = [];
            const lineY = SUB_HEIGHT / 2 + 0.5; // Altura sobre los subs
            points.push(new THREE.Vector3(0, lineY, 0));
            points.push(new THREE.Vector3(0, lineY, 0)); 
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            idealLine = new THREE.Line(geometry, material);
            idealLine.computeLineDistances(); 
            scene.add(idealLine);
        }
        
        /**
         * Crea la malla que será deformada para simular la onda de interferencia.
         */
        function createWaveMesh() {
            const geometry = new THREE.PlaneGeometry(SCENE_DISTANCE_SCALE, SCENE_DISTANCE_SCALE, 64, 64);
            const material = new THREE.MeshLambertMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide,
                depthWrite: false, 
                vertexColors: true 
            });
            waveMesh = new THREE.Mesh(geometry, material);
            waveMesh.rotation.x = -Math.PI / 2; 
            waveMesh.position.y = -SUB_HEIGHT / 2 + 0.01; 
            scene.add(waveMesh);
        }

        /**
         * Actualiza las posiciones de los subwoofers, la línea y la forma/color de la onda.
         */
        function update3DScene(wavelength, subDistance) {
            // 1. Posiciones de los Subwoofers
            const halfDistance = subDistance / 2;
            sub1.position.x = -halfDistance;
            sub2.position.x = halfDistance;

            // 2. Línea de Distancia Ideal
            const points = idealLine.geometry.attributes.position.array;
            const lineY = SUB_HEIGHT / 2 + 0.3; // Más cerca de los bafles
            points[0] = -halfDistance; points[1] = lineY; points[2] = 0; // Sub 1
            points[3] = halfDistance; points[4] = lineY; points[5] = 0;  // Sub 2
            idealLine.geometry.attributes.position.needsUpdate = true;
            idealLine.computeLineDistances();

            // 3. Deformación y Color de la Onda 
            const positionAttribute = waveMesh.geometry.attributes.position;
            const positions = positionAttribute.array;
            
            // Asegurar el atributo de color
            if (!waveMesh.geometry.attributes.color) {
                waveMesh.geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(positions.length), 3));
            }
            const colors = waveMesh.geometry.attributes.color.array;

            // Constantes de color (RGB)
            const RED = new THREE.Color(0xf87171);   // Refuerzo
            const GREEN = new THREE.Color(0x34d399); // Coherencia
            const BLUE = new THREE.Color(0x60a5fa);  // Cancelación

            for (let i = 0; i < positions.length / 3; i++) {
                const x = positions[i * 3];
                const z = positions[i * 3 + 2];
                const L1 = Math.sqrt(Math.pow(x - sub1.position.x, 2) + Math.pow(z, 2));
                const L2 = Math.sqrt(Math.pow(x - sub2.position.x, 2) + Math.pow(z, 2));
                const delta_L = Math.abs(L1 - L2);
                
                const phase = (delta_L / wavelength) * 2 * Math.PI;
                const M_amplitude = Math.abs(Math.cos(phase / 2)); 

                // Deformación (Altura de la Onda)
                const waveHeight = M_amplitude * 0.4; // Altura máxima de 0.4m
                positions[i * 3 + 1] = waveHeight; 

                // Mapeo de Colores
                let color;
                if (M_amplitude > 0.8) {
                    color = RED;
                } else if (M_amplitude >= 0.3) {
                    color = GREEN;
                } else {
                    color = BLUE;
                }
                
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            positionAttribute.needsUpdate = true;
            waveMesh.geometry.attributes.color.needsUpdate = true;
            waveMesh.geometry.computeVertexNormals(); 
        }
        
        /**
         * Loop de animación.
         */
        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            
            if (controls) {
                controls.update(); 
            }
            
            if (waveMesh) {
                waveMesh.rotation.z += 0.0005; 
            }

            renderer.render(scene, camera);
        }

        // --- MANEJO DE EVENTOS ---

        function onWindowResize() {
            if (camera && renderer) {
                camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
                if (!animationFrameId) {
                    renderer.render(scene, camera);
                }
            }
        }

        // Inicialización al cargar la página
        window.onload = function() {
            init3DScene(); 
            calculateAndUpdate(); // Primer cálculo y dibujo 3D
            slider.addEventListener('input', calculateAndUpdate);
            window.addEventListener('resize', onWindowResize);
        };
        
        window.onbeforeunload = function () {
            cancelAnimationFrame(animationFrameId);
        };

    </script>

</body>
</html>